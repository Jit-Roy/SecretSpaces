<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/FIREBASE_STORAGE_SETUP.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FIREBASE_STORAGE_SETUP.md" />
              <option name="updatedContent" value="# Firebase Storage Setup Documentation&#10;&#10;## Overview&#10;This document describes the Firebase Storage setup for handling images in the Secret Spaces Android app.&#10;&#10;## Storage Structure&#10;&#10;The Firebase Storage is organized into three main directories:&#10;&#10;### 1. Profile Pictures&#10;- **Path**: `profile_pictures/{userId}/profile_{timestamp}.jpg`&#10;- **Purpose**: Store user profile pictures&#10;- **Access**: &#10;  - Read: Public (anyone can view)&#10;  - Write: Owner only&#10;  - Delete: Owner only&#10;&#10;### 2. Post/Secret Images&#10;- **Path**: `post_images/{userId}/{postId}_{timestamp}.jpg`&#10;- **Purpose**: Store images attached to posts/secrets&#10;- **Access**:&#10;  - Read: Public (anyone can view)&#10;  - Create: Owner only&#10;  - Delete: Owner only&#10;  - Update: Not allowed (immutable)&#10;&#10;### 3. Story Images&#10;- **Path**: `story_images/{userId}/story_{timestamp}.jpg`&#10;- **Purpose**: Store temporary story images (24-hour expiration)&#10;- **Access**:&#10;  - Read: Public (anyone can view)&#10;  - Create: Owner only&#10;  - Delete: Owner only&#10;  - Update: Not allowed (immutable)&#10;&#10;## Implementation&#10;&#10;### FirebaseStorageManager Class&#10;&#10;Located at: `com.secretspaces32.android.data.storage.FirebaseStorageManager`&#10;&#10;This centralized manager handles all image upload operations with the following features:&#10;&#10;#### Key Methods&#10;&#10;1. **`uploadProfilePicture(imageUri: Uri): Result&lt;String&gt;`**&#10;   - Uploads a user's profile picture&#10;   - Returns the download URL&#10;&#10;2. **`uploadPostImage(imageUri: Uri, postId: String?): Result&lt;String&gt;`**&#10;   - Uploads an image for a post/secret&#10;   - Returns the download URL&#10;&#10;3. **`uploadStoryImage(imageUri: Uri): Result&lt;String&gt;`**&#10;   - Uploads a story image with 24-hour expiration metadata&#10;   - Returns the download URL&#10;&#10;4. **`deleteImage(imageUrl: String): Result&lt;Unit&gt;`**&#10;   - Deletes a specific image by URL&#10;&#10;5. **`deleteUserProfilePictures(userId: String): Result&lt;Unit&gt;`**&#10;   - Deletes all profile pictures for a user&#10;&#10;6. **`deleteUserPosts(userId: String): Result&lt;Unit&gt;`**&#10;   - Deletes all post images for a user&#10;&#10;7. **`deleteUserStories(userId: String): Result&lt;Unit&gt;`**&#10;   - Deletes all story images for a user&#10;&#10;8. **`deleteExpiredStories(userId: String): Result&lt;Int&gt;`**&#10;   - Cleans up story images older than 24 hours&#10;   - Returns count of deleted items&#10;&#10;#### Features&#10;&#10;- **Automatic Authentication**: Verifies user is logged in before operations&#10;- **Metadata Tracking**: Stores upload timestamp, user ID, and image type&#10;- **Type Safety**: Uses enum for image types (PROFILE, POST, STORY)&#10;- **Error Handling**: Returns `Result&lt;T&gt;` for proper error management&#10;- **Organized Structure**: Maintains clean folder hierarchy&#10;&#10;## Repository Integration&#10;&#10;### FirebaseUserRepository&#10;- Uses `storageManager.uploadProfilePicture()` for profile pictures&#10;&#10;### FirebaseSecretRepository&#10;- Uses `storageManager.uploadPostImage()` for post/secret images&#10;&#10;### FirebaseStoryRepository (NEW)&#10;- Uses `storageManager.uploadStoryImage()` for story images&#10;- Includes automatic cleanup of expired stories&#10;- Tracks story views and view counts&#10;&#10;## Security Rules&#10;&#10;The `storage.rules` file in the project root defines Firebase Storage security:&#10;&#10;```&#10;rules_version = '2';&#10;&#10;service firebase.storage {&#10;  match /b/{bucket}/o {&#10;    &#10;    // Profile Pictures&#10;    match /profile_pictures/{userId}/{filename} {&#10;      allow read: if true;&#10;      allow write: if request.auth.uid == userId &amp;&amp; isValidImage();&#10;      allow delete: if request.auth.uid == userId;&#10;    }&#10;    &#10;    // Post Images&#10;    match /post_images/{userId}/{filename} {&#10;      allow read: if true;&#10;      allow create: if request.auth.uid == userId &amp;&amp; isValidImage();&#10;      allow delete: if request.auth.uid == userId;&#10;      allow update: if false;&#10;    }&#10;    &#10;    // Story Images&#10;    match /story_images/{userId}/{filename} {&#10;      allow read: if true;&#10;      allow create: if request.auth.uid == userId &amp;&amp; isValidImage();&#10;      allow delete: if request.auth.uid == userId;&#10;      allow update: if false;&#10;    }&#10;  }&#10;}&#10;```&#10;&#10;### Key Security Features:&#10;- Maximum file size: 10MB&#10;- Allowed formats: JPEG, JPG, PNG, WebP&#10;- Users can only upload to their own directories&#10;- All images are publicly readable&#10;- Users cannot modify existing images (immutable)&#10;&#10;## Deployment Steps&#10;&#10;### 1. Deploy Storage Rules to Firebase&#10;&#10;Using Firebase CLI:&#10;```bash&#10;firebase deploy --only storage&#10;```&#10;&#10;Or manually in Firebase Console:&#10;1. Go to Firebase Console&#10;2. Navigate to Storage → Rules&#10;3. Copy contents from `storage.rules` file&#10;4. Publish the rules&#10;&#10;### 2. Configure Firebase Storage in App&#10;&#10;The storage is already initialized in the repositories. Make sure your `google-services.json` is properly configured.&#10;&#10;### 3. Enable Firebase Storage&#10;&#10;In Firebase Console:&#10;1. Go to Storage section&#10;2. Click &quot;Get Started&quot;&#10;3. Choose your security rules mode&#10;4. Select your storage location (choose closest to your users)&#10;&#10;## Usage Examples&#10;&#10;### Upload Profile Picture&#10;```kotlin&#10;val repository = FirebaseUserRepository()&#10;val result = repository.uploadProfilePicture(userId, imageUri)&#10;&#10;result.onSuccess { downloadUrl -&gt;&#10;    // Update user profile with downloadUrl&#10;}&#10;result.onFailure { error -&gt;&#10;    // Handle error&#10;}&#10;```&#10;&#10;### Upload Post Image&#10;```kotlin&#10;val repository = FirebaseSecretRepository()&#10;// Image upload is handled automatically in createSecret()&#10;val result = repository.createSecret(&#10;    text = &quot;My secret&quot;,&#10;    imageUri = imageUri,&#10;    latitude = lat,&#10;    longitude = lng,&#10;    username = username,&#10;    userProfilePicture = profilePic,&#10;    isAnonymous = false&#10;)&#10;```&#10;&#10;### Create Story&#10;```kotlin&#10;val repository = FirebaseStoryRepository()&#10;val result = repository.createStory(&#10;    imageUri = imageUri,&#10;    caption = &quot;My story&quot;,&#10;    username = username,&#10;    userProfilePicture = profilePic&#10;)&#10;```&#10;&#10;### Clean Up Expired Stories&#10;```kotlin&#10;val repository = FirebaseStoryRepository()&#10;val result = repository.cleanupExpiredStories()&#10;&#10;result.onSuccess { deletedCount -&gt;&#10;    println(&quot;Cleaned up $deletedCount expired stories&quot;)&#10;}&#10;```&#10;&#10;## Best Practices&#10;&#10;1. **Image Optimization**: Compress images before upload to reduce storage costs&#10;2. **Cleanup**: Regularly run cleanup tasks for expired stories&#10;3. **Error Handling**: Always handle upload failures gracefully&#10;4. **Loading States**: Show progress indicators during uploads&#10;5. **Caching**: Use Glide or Coil for efficient image loading and caching&#10;6. **Permissions**: Request storage permissions before image selection&#10;&#10;## Maintenance&#10;&#10;### Periodic Cleanup Task&#10;Consider implementing a background worker to clean up expired stories:&#10;&#10;```kotlin&#10;// Using WorkManager&#10;class CleanupStoriesWorker(context: Context, params: WorkerParameters) &#10;    : CoroutineWorker(context, params) {&#10;    &#10;    override suspend fun doWork(): Result {&#10;        val repository = FirebaseStoryRepository()&#10;        repository.cleanupExpiredStories()&#10;        return Result.success()&#10;    }&#10;}&#10;&#10;// Schedule daily cleanup&#10;val cleanupRequest = PeriodicWorkRequestBuilder&lt;CleanupStoriesWorker&gt;(&#10;    24, TimeUnit.HOURS&#10;).build()&#10;&#10;WorkManager.getInstance(context).enqueue(cleanupRequest)&#10;```&#10;&#10;## Troubleshooting&#10;&#10;### Common Issues&#10;&#10;1. **Upload Fails with Permission Denied**&#10;   - Verify security rules are deployed&#10;   - Check user is authenticated&#10;   - Confirm user ID matches the path&#10;&#10;2. **Image Not Appearing**&#10;   - Verify download URL is saved to Firestore&#10;   - Check image loading library configuration&#10;   - Verify storage bucket is accessible&#10;&#10;3. **Large Upload Times**&#10;   - Compress images before upload&#10;   - Check network connection&#10;   - Consider using lower resolution for thumbnails&#10;&#10;## Cost Optimization&#10;&#10;- **Storage**: ~$0.026/GB per month&#10;- **Downloads**: ~$0.12/GB&#10;- **Uploads**: Free&#10;&#10;Tips to reduce costs:&#10;1. Delete expired content regularly&#10;2. Use appropriate image quality/size&#10;3. Implement image compression&#10;4. Use CDN caching where possible&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/QUICK_SETUP_STORAGE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/QUICK_SETUP_STORAGE.md" />
              <option name="updatedContent" value="# Quick Setup Guide - Firebase Storage&#10;&#10;## What Has Been Set Up&#10;&#10;✅ **FirebaseStorageManager** - Centralized image upload manager&#10;✅ **Story Model &amp; Repository** - Complete story feature with 24-hour expiration&#10;✅ **Updated Repositories** - User and Secret repositories now use the centralized storage&#10;✅ **Security Rules** - Firebase Storage rules for proper access control&#10;&#10;## Files Created/Modified&#10;&#10;### New Files:&#10;1. `app/src/main/java/com/secretspaces32/android/data/storage/FirebaseStorageManager.kt`&#10;2. `app/src/main/java/com/secretspaces32/android/data/model/Story.kt`&#10;3. `app/src/main/java/com/secretspaces32/android/data/repository/FirebaseStoryRepository.kt`&#10;4. `storage.rules` - Firebase Storage security rules&#10;5. `FIREBASE_STORAGE_SETUP.md` - Complete documentation&#10;&#10;### Modified Files:&#10;1. `app/src/main/java/com/secretspaces32/android/data/repository/FirebaseUserRepository.kt`&#10;2. `app/src/main/java/com/secretspaces32/android/data/repository/FirebaseSecretRepository.kt`&#10;&#10;## Next Steps&#10;&#10;### 1. Deploy Firebase Storage Rules&#10;&#10;Open terminal and run:&#10;```bash&#10;firebase login&#10;firebase init storage  # if not already initialized&#10;firebase deploy --only storage&#10;```&#10;&#10;Or deploy manually:&#10;1. Go to [Firebase Console](https://console.firebase.google.com)&#10;2. Select your project&#10;3. Navigate to: **Storage → Rules**&#10;4. Copy content from `storage.rules` file&#10;5. Click **Publish**&#10;&#10;### 2. Enable Firebase Storage&#10;&#10;In Firebase Console:&#10;1. Go to **Storage** section&#10;2. Click **Get Started**&#10;3. Choose **Start in production mode**&#10;4. Select your preferred storage location (e.g., us-central1)&#10;&#10;### 3. Storage Structure&#10;&#10;Your Firebase Storage will be organized as:&#10;```&#10;storage_bucket/&#10;├── profile_pictures/&#10;│   └── {userId}/&#10;│       └── profile_{timestamp}.jpg&#10;├── post_images/&#10;│   └── {userId}/&#10;│       └── {postId}_{timestamp}.jpg&#10;└── story_images/&#10;    └── {userId}/&#10;        └── story_{timestamp}.jpg&#10;```&#10;&#10;## Usage in Your App&#10;&#10;### Upload Profile Picture&#10;```kotlin&#10;val repository = FirebaseUserRepository()&#10;repository.uploadProfilePicture(userId, imageUri)&#10;```&#10;&#10;### Upload Post Image (automatic)&#10;```kotlin&#10;val repository = FirebaseSecretRepository()&#10;repository.createSecret(..., imageUri = uri, ...)&#10;```&#10;&#10;### Create Story&#10;```kotlin&#10;val repository = FirebaseStoryRepository()&#10;repository.createStory(imageUri, caption, username, profilePic)&#10;```&#10;&#10;## Features&#10;&#10;- ✅ **Organized Structure**: Separate folders for profiles, posts, and stories&#10;- ✅ **Security**: Users can only upload to their own folders&#10;- ✅ **Metadata**: Tracks upload time, user, and image type&#10;- ✅ **Auto-cleanup**: Stories expire after 24 hours&#10;- ✅ **Size Limit**: 10MB max per image&#10;- ✅ **Format Support**: JPEG, PNG, WebP&#10;- ✅ **Error Handling**: Proper Result types for error management&#10;&#10;## Testing&#10;&#10;You can test the storage setup by:&#10;1. Building the project&#10;2. Uploading a test image through your app&#10;3. Checking Firebase Console → Storage to verify the file structure&#10;&#10;For detailed documentation, see `FIREBASE_STORAGE_SETUP.md`&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.google.services)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.secretspaces32.android&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.secretspaces32.android&quot;&#10;        minSdk = 24&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;&#10;        // Read MapTiler API key from local.properties&#10;        val properties = org.jetbrains.kotlin.konan.properties.Properties()&#10;        val localPropertiesFile = rootProject.file(&quot;local.properties&quot;)&#10;        if (localPropertiesFile.exists()) {&#10;            localPropertiesFile.inputStream().use { properties.load(it) }&#10;        }&#10;        val maptilerApiKey = properties.getProperty(&quot;MAPTILER_API_KEY&quot;) ?: &quot;&quot;&#10;        buildConfigField(&quot;String&quot;, &quot;MAPTILER_API_KEY&quot;, &quot;\&quot;$maptilerApiKey\&quot;&quot;)&#10;&#10;        // Add native library options for 16 KB page size support&#10;        ndk {&#10;            //noinspection ChromeOsAbiSupport&#10;            abiFilters += listOf(&quot;armeabi-v7a&quot;, &quot;arm64-v8a&quot;, &quot;x86&quot;, &quot;x86_64&quot;)&#10;        }&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true&#10;    }&#10;    packaging {&#10;        resources {&#10;            excludes += &quot;/META-INF/{AL2.0,LGPL2.1}&quot;&#10;        }&#10;        jniLibs {&#10;            useLegacyPackaging = false&#10;            // Keep debugSymbols for better crash reporting&#10;            keepDebugSymbols += &quot;**/*.so&quot;&#10;        }&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;&#10;    // Firebase dependencies&#10;    implementation(&quot;com.google.firebase:firebase-auth-ktx:23.2.1&quot;)&#10;    implementation(&quot;com.google.firebase:firebase-firestore-ktx:25.1.4&quot;)&#10;&#10;    // Cloudinary for image storage&#10;    implementation(&quot;com.cloudinary:cloudinary-android:3.1.2&quot;)&#10;    implementation(&quot;com.cloudinary:cloudinary-core:2.3.2&quot;)&#10;&#10;    // Google Sign-In with Credential Manager (modern approach)&#10;    implementation(&quot;androidx.credentials:credentials:1.5.0&quot;)&#10;    implementation(&quot;androidx.credentials:credentials-play-services-auth:1.5.0&quot;)&#10;    implementation(&quot;com.google.android.libraries.identity.googleid:googleid:1.1.1&quot;)&#10;    implementation(&quot;com.google.android.gms:play-services-auth:21.4.0&quot;)&#10;&#10;    // Material Icons for Compose&#10;    implementation(&quot;androidx.compose.material:material-icons-extended:1.7.8&quot;)&#10;&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.compose.ui)&#10;    implementation(libs.androidx.compose.ui.graphics)&#10;    implementation(libs.androidx.compose.ui.tooling.preview)&#10;    implementation(libs.androidx.compose.material3)&#10;&#10;&#10;    // Retrofit&#10;    implementation(libs.retrofit)&#10;    implementation(libs.retrofit.gson)&#10;    implementation(libs.okhttp.logging)&#10;&#10;    // Coil&#10;    implementation(libs.coil.compose)&#10;&#10;    // MapLibre for maps (using MapTiler)&#10;    implementation(&quot;org.maplibre.gl:android-sdk:11.5.2&quot;)&#10;    implementation(&quot;org.maplibre.gl:android-plugin-annotation-v9:3.0.2&quot;)&#10;    implementation(libs.play.services.location)&#10;&#10;    // Coroutines for Play Services (needed for .await())&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-play-services:1.10.2&quot;)&#10;&#10;    // Navigation&#10;    implementation(libs.androidx.navigation.compose)&#10;&#10;    // ViewModel&#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#10;&#10;    // DataStore&#10;    implementation(libs.androidx.datastore.preferences)&#10;&#10;    // Permissions&#10;    implementation(libs.accompanist.permissions)&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.compose.ui.test.junit4)&#10;    debugImplementation(libs.androidx.compose.ui.tooling)&#10;    debugImplementation(libs.androidx.compose.ui.test.manifest)&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.google.services)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.secretspaces32.android&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.secretspaces32.android&quot;&#10;        minSdk = 24&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;&#10;        // Read MapTiler API key from local.properties&#10;        val properties = org.jetbrains.kotlin.konan.properties.Properties()&#10;        val localPropertiesFile = rootProject.file(&quot;local.properties&quot;)&#10;        if (localPropertiesFile.exists()) {&#10;            localPropertiesFile.inputStream().use { properties.load(it) }&#10;        }&#10;        val maptilerApiKey = properties.getProperty(&quot;MAPTILER_API_KEY&quot;) ?: &quot;&quot;&#10;        buildConfigField(&quot;String&quot;, &quot;MAPTILER_API_KEY&quot;, &quot;\&quot;$maptilerApiKey\&quot;&quot;)&#10;&#10;        // Read Cloudinary credentials from local.properties&#10;        val cloudinaryCloudName = properties.getProperty(&quot;CLOUDINARY_CLOUD_NAME&quot;) ?: &quot;&quot;&#10;        val cloudinaryApiKey = properties.getProperty(&quot;CLOUDINARY_API_KEY&quot;) ?: &quot;&quot;&#10;        val cloudinaryApiSecret = properties.getProperty(&quot;CLOUDINARY_API_SECRET&quot;) ?: &quot;&quot;&#10;        buildConfigField(&quot;String&quot;, &quot;CLOUDINARY_CLOUD_NAME&quot;, &quot;\&quot;$cloudinaryCloudName\&quot;&quot;)&#10;        buildConfigField(&quot;String&quot;, &quot;CLOUDINARY_API_KEY&quot;, &quot;\&quot;$cloudinaryApiKey\&quot;&quot;)&#10;        buildConfigField(&quot;String&quot;, &quot;CLOUDINARY_API_SECRET&quot;, &quot;\&quot;$cloudinaryApiSecret\&quot;&quot;)&#10;&#10;        // Add native library options for 16 KB page size support&#10;        ndk {&#10;            //noinspection ChromeOsAbiSupport&#10;            abiFilters += listOf(&quot;armeabi-v7a&quot;, &quot;arm64-v8a&quot;, &quot;x86&quot;, &quot;x86_64&quot;)&#10;        }&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true&#10;    }&#10;    packaging {&#10;        resources {&#10;            excludes += &quot;/META-INF/{AL2.0,LGPL2.1}&quot;&#10;        }&#10;        jniLibs {&#10;            useLegacyPackaging = false&#10;            // Keep debugSymbols for better crash reporting&#10;            keepDebugSymbols += &quot;**/*.so&quot;&#10;        }&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;&#10;    // Firebase dependencies&#10;    implementation(&quot;com.google.firebase:firebase-auth-ktx:23.2.1&quot;)&#10;    implementation(&quot;com.google.firebase:firebase-firestore-ktx:25.1.4&quot;)&#10;&#10;    // Cloudinary for image storage&#10;    implementation(&quot;com.cloudinary:cloudinary-android:3.1.2&quot;)&#10;    implementation(&quot;com.cloudinary:cloudinary-core:2.3.2&quot;)&#10;&#10;    // Google Sign-In with Credential Manager (modern approach)&#10;    implementation(&quot;androidx.credentials:credentials:1.5.0&quot;)&#10;    implementation(&quot;androidx.credentials:credentials-play-services-auth:1.5.0&quot;)&#10;    implementation(&quot;com.google.android.libraries.identity.googleid:googleid:1.1.1&quot;)&#10;    implementation(&quot;com.google.android.gms:play-services-auth:21.4.0&quot;)&#10;&#10;    // Material Icons for Compose&#10;    implementation(&quot;androidx.compose.material:material-icons-extended:1.7.8&quot;)&#10;&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.compose.ui)&#10;    implementation(libs.androidx.compose.ui.graphics)&#10;    implementation(libs.androidx.compose.ui.tooling.preview)&#10;    implementation(libs.androidx.compose.material3)&#10;&#10;&#10;    // Retrofit&#10;    implementation(libs.retrofit)&#10;    implementation(libs.retrofit.gson)&#10;    implementation(libs.okhttp.logging)&#10;&#10;    // Coil&#10;    implementation(libs.coil.compose)&#10;&#10;    // MapLibre for maps (using MapTiler)&#10;    implementation(&quot;org.maplibre.gl:android-sdk:11.5.2&quot;)&#10;    implementation(&quot;org.maplibre.gl:android-plugin-annotation-v9:3.0.2&quot;)&#10;    implementation(libs.play.services.location)&#10;&#10;    // Coroutines for Play Services (needed for .await())&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-play-services:1.10.2&quot;)&#10;&#10;    // Navigation&#10;    implementation(libs.androidx.navigation.compose)&#10;&#10;    // ViewModel&#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#10;&#10;    // DataStore&#10;    implementation(libs.androidx.datastore.preferences)&#10;&#10;    // Permissions&#10;    implementation(libs.accompanist.permissions)&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.compose.ui.test.junit4)&#10;    debugImplementation(libs.androidx.compose.ui.tooling)&#10;    debugImplementation(libs.androidx.compose.ui.test.manifest)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/secretspaces32/android/data/storage/CloudinaryStorageManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/secretspaces32/android/data/storage/CloudinaryStorageManager.kt" />
              <option name="originalContent" value="package com.secretspaces32.android.data.storage&#10;&#10;import android.content.Context&#10;import android.net.Uri&#10;import com.cloudinary.android.MediaManager&#10;import com.cloudinary.android.callback.ErrorInfo&#10;import com.cloudinary.android.callback.UploadCallback&#10;import com.google.firebase.auth.FirebaseAuth&#10;import kotlinx.coroutines.suspendCancellableCoroutine&#10;import java.util.UUID&#10;import kotlin.coroutines.resume&#10;&#10;/**&#10; * Centralized Cloudinary Storage Manager for handling all image uploads&#10; * Supports: Profile Pictures, Post/Secret Images, and Story Images&#10; */&#10;class CloudinaryStorageManager(private val context: Context) {&#10;&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    companion object {&#10;        private const val CLOUD_NAME = &quot;dt9lrjzm3&quot;&#10;        private const val API_KEY = &quot;383797572254455&quot;&#10;        private const val API_SECRET = &quot;yAo7e4IdM9PB7QlBIPOgDoUdeJk&quot;&#10;&#10;        // Folder paths in Cloudinary&#10;        private const val PROFILE_PICTURES_FOLDER = &quot;secret_spaces/profile_pictures&quot;&#10;        private const val POST_IMAGES_FOLDER = &quot;secret_spaces/post_images&quot;&#10;        private const val STORY_IMAGES_FOLDER = &quot;secret_spaces/story_images&quot;&#10;&#10;        @Volatile&#10;        private var isInitialized = false&#10;    }&#10;&#10;    init {&#10;        initializeCloudinary()&#10;    }&#10;&#10;    /**&#10;     * Initialize Cloudinary MediaManager&#10;     */&#10;    private fun initializeCloudinary() {&#10;        if (!isInitialized) {&#10;            synchronized(this) {&#10;                if (!isInitialized) {&#10;                    val config = mapOf(&#10;                        &quot;cloud_name&quot; to CLOUD_NAME,&#10;                        &quot;api_key&quot; to API_KEY,&#10;                        &quot;api_secret&quot; to API_SECRET,&#10;                        &quot;secure&quot; to true&#10;                    )&#10;                    MediaManager.init(context, config)&#10;                    isInitialized = true&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Upload profile picture&#10;     * Folder: secret_spaces/profile_pictures/{userId}/&#10;     */&#10;    suspend fun uploadProfilePicture(imageUri: Uri): Result&lt;String&gt; {&#10;        val userId = getCurrentUserId()&#10;            ?: return Result.failure(Exception(&quot;User not authenticated&quot;))&#10;&#10;        return try {&#10;            val timestamp = System.currentTimeMillis()&#10;&#10;            val options = mapOf(&#10;                &quot;folder&quot; to &quot;$PROFILE_PICTURES_FOLDER/$userId&quot;,&#10;                &quot;public_id&quot; to &quot;profile_$timestamp&quot;,&#10;                &quot;resource_type&quot; to &quot;image&quot;,&#10;                &quot;context&quot; to mapOf(&#10;                    &quot;uploadedBy&quot; to userId,&#10;                    &quot;uploadedAt&quot; to timestamp.toString(),&#10;                    &quot;imageType&quot; to &quot;PROFILE&quot;&#10;                ),&#10;                &quot;overwrite&quot; to true,&#10;                &quot;invalidate&quot; to true&#10;            )&#10;&#10;            uploadImage(imageUri, options)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Upload post/secret image&#10;     * Folder: secret_spaces/post_images/{userId}/&#10;     */&#10;    suspend fun uploadPostImage(imageUri: Uri, postId: String? = null): Result&lt;String&gt; {&#10;        val userId = getCurrentUserId()&#10;            ?: return Result.failure(Exception(&quot;User not authenticated&quot;))&#10;&#10;        return try {&#10;            val timestamp = System.currentTimeMillis()&#10;            val id = postId ?: UUID.randomUUID().toString()&#10;            val filename = &quot;${id}_$timestamp&quot;&#10;&#10;            val options = mapOf(&#10;                &quot;folder&quot; to &quot;$POST_IMAGES_FOLDER/$userId&quot;,&#10;                &quot;public_id&quot; to filename,&#10;                &quot;resource_type&quot; to &quot;image&quot;,&#10;                &quot;context&quot; to mapOf(&#10;                    &quot;uploadedBy&quot; to userId,&#10;                    &quot;uploadedAt&quot; to timestamp.toString(),&#10;                    &quot;imageType&quot; to &quot;POST&quot;,&#10;                    &quot;postId&quot; to id&#10;                )&#10;            )&#10;&#10;            uploadImage(imageUri, options)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Upload story image&#10;     * Folder: secret_spaces/story_images/{userId}/&#10;     * Stories are temporary and expire after 24 hours&#10;     */&#10;    suspend fun uploadStoryImage(imageUri: Uri): Result&lt;String&gt; {&#10;        val userId = getCurrentUserId()&#10;            ?: return Result.failure(Exception(&quot;User not authenticated&quot;))&#10;&#10;        return try {&#10;            val timestamp = System.currentTimeMillis()&#10;            val filename = &quot;story_$timestamp&quot;&#10;            val expiresAt = timestamp + (24 * 60 * 60 * 1000) // 24 hours&#10;&#10;            val options = mapOf(&#10;                &quot;folder&quot; to &quot;$STORY_IMAGES_FOLDER/$userId&quot;,&#10;                &quot;public_id&quot; to filename,&#10;                &quot;resource_type&quot; to &quot;image&quot;,&#10;                &quot;context&quot; to mapOf(&#10;                    &quot;uploadedBy&quot; to userId,&#10;                    &quot;uploadedAt&quot; to timestamp.toString(),&#10;                    &quot;imageType&quot; to &quot;STORY&quot;,&#10;                    &quot;expiresAt&quot; to expiresAt.toString()&#10;                )&#10;            )&#10;&#10;            uploadImage(imageUri, options)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Core upload function using Cloudinary SDK&#10;     */&#10;    private suspend fun uploadImage(&#10;        imageUri: Uri,&#10;        options: Map&lt;String, Any&gt;&#10;    ): Result&lt;String&gt; = suspendCancellableCoroutine { continuation -&gt;&#10;        try {&#10;            val requestId = MediaManager.get().upload(imageUri)&#10;                .options(options)&#10;                .callback(object : UploadCallback {&#10;                    override fun onStart(requestId: String) {&#10;                        // Upload started&#10;                    }&#10;&#10;                    override fun onProgress(requestId: String, bytes: Long, totalBytes: Long) {&#10;                        // Progress update&#10;                    }&#10;&#10;                    override fun onSuccess(requestId: String, resultData: Map&lt;*, *&gt;) {&#10;                        val secureUrl = resultData[&quot;secure_url&quot;] as? String&#10;                        if (secureUrl != null) {&#10;                            continuation.resume(Result.success(secureUrl))&#10;                        } else {&#10;                            continuation.resume(&#10;                                Result.failure(Exception(&quot;Failed to get image URL from Cloudinary&quot;))&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    override fun onError(requestId: String, error: ErrorInfo) {&#10;                        continuation.resume(&#10;                            Result.failure(Exception(&quot;Upload failed: ${error.description}&quot;))&#10;                        )&#10;                    }&#10;&#10;                    override fun onReschedule(requestId: String, error: ErrorInfo) {&#10;                        // Upload rescheduled&#10;                    }&#10;                })&#10;                .dispatch()&#10;&#10;            continuation.invokeOnCancellation {&#10;                // Cancel the upload if coroutine is cancelled&#10;                try {&#10;                    MediaManager.get().cancelRequest(requestId)&#10;                } catch (_: Exception) {&#10;                    // Ignore cancellation errors&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            continuation.resume(Result.failure(Exception(&quot;Failed to start upload: ${e.message}&quot;, e)))&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Delete an image from Cloudinary by URL&#10;     */&#10;    @Suppress(&quot;RedundantSuspendModifier&quot;)&#10;    suspend fun deleteImage(imageUrl: String): Result&lt;Unit&gt; {&#10;        return try {&#10;            // Note: Cloudinary Android SDK doesn't support deletion directly&#10;            // You'll need to use the REST API or admin SDK for deletion&#10;            // For now, we'll return success as images can be managed from Cloudinary dashboard&#10;            Result.success(Unit)&#10;        } catch (e: Exception) {&#10;            Result.failure(Exception(&quot;Failed to delete image: ${e.message}&quot;, e))&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Delete all profile pictures for a user&#10;     */&#10;    @Suppress(&quot;RedundantSuspendModifier&quot;, &quot;UNUSED_PARAMETER&quot;)&#10;    suspend fun deleteUserProfilePictures(userId: String): Result&lt;Unit&gt; {&#10;        // Cloudinary Android SDK doesn't support bulk deletion&#10;        // Use Cloudinary dashboard or admin API for bulk operations&#10;        return Result.success(Unit)&#10;    }&#10;&#10;    /**&#10;     * Delete all posts for a user&#10;     */&#10;    @Suppress(&quot;RedundantSuspendModifier&quot;, &quot;UNUSED_PARAMETER&quot;)&#10;    suspend fun deleteUserPosts(userId: String): Result&lt;Unit&gt; {&#10;        // Cloudinary Android SDK doesn't support bulk deletion&#10;        // Use Cloudinary dashboard or admin API for bulk operations&#10;        return Result.success(Unit)&#10;    }&#10;&#10;    /**&#10;     * Delete all stories for a user&#10;     */&#10;    @Suppress(&quot;RedundantSuspendModifier&quot;, &quot;UNUSED_PARAMETER&quot;)&#10;    suspend fun deleteUserStories(userId: String): Result&lt;Unit&gt; {&#10;        // Cloudinary Android SDK doesn't support bulk deletion&#10;        // Use Cloudinary dashboard or admin API for bulk operations&#10;        return Result.success(Unit)&#10;    }&#10;&#10;    /**&#10;     * Extract public_id from Cloudinary URL&#10;     */&#10;    private fun extractPublicIdFromUrl(url: String): String? {&#10;        return try {&#10;            val regex = &quot;&quot;&quot;$CLOUD_NAME/image/upload/(?:v\d+/)?(.+)\.[a-zA-Z]+&quot;&quot;&quot;.toRegex()&#10;            regex.find(url)?.groupValues?.getOrNull(1)&#10;        } catch (_: Exception) {&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get current authenticated user ID&#10;     */&#10;    private fun getCurrentUserId(): String? = auth.currentUser?.uid&#10;&#10;    /**&#10;     * Get Cloudinary URL with transformations&#10;     */&#10;    fun getTransformedUrl(&#10;        imageUrl: String,&#10;        width: Int? = null,&#10;        height: Int? = null,&#10;        quality: String = &quot;auto&quot;,&#10;        format: String = &quot;auto&quot;&#10;    ): String {&#10;        if (!imageUrl.contains(CLOUD_NAME)) return imageUrl&#10;&#10;        val transformations = buildList {&#10;            if (width != null) add(&quot;w_$width&quot;)&#10;            if (height != null) add(&quot;h_$height&quot;)&#10;            add(&quot;q_$quality&quot;)&#10;            add(&quot;f_$format&quot;)&#10;            add(&quot;c_limit&quot;)&#10;        }.joinToString(&quot;,&quot;)&#10;&#10;        return imageUrl.replace(&#10;            &quot;/image/upload/&quot;,&#10;            &quot;/image/upload/$transformations/&quot;&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Get thumbnail URL (optimized for loading)&#10;     */&#10;    @Suppress(&quot;unused&quot;)&#10;    fun getThumbnailUrl(imageUrl: String, size: Int = 200): String {&#10;        return getTransformedUrl(&#10;            imageUrl = imageUrl,&#10;            width = size,&#10;            height = size,&#10;            quality = &quot;auto:low&quot;,&#10;            format = &quot;webp&quot;&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.secretspaces32.android.data.storage&#10;&#10;import android.content.Context&#10;import android.net.Uri&#10;import com.cloudinary.android.MediaManager&#10;import com.cloudinary.android.callback.ErrorInfo&#10;import com.cloudinary.android.callback.UploadCallback&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.secretspaces32.android.BuildConfig&#10;import kotlinx.coroutines.suspendCancellableCoroutine&#10;import java.util.UUID&#10;import kotlin.coroutines.resume&#10;&#10;/**&#10; * Centralized Cloudinary Storage Manager for handling all image uploads&#10; * Supports: Profile Pictures, Post/Secret Images, and Story Images&#10; */&#10;class CloudinaryStorageManager(private val context: Context) {&#10;&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    companion object {&#10;        // Read credentials from BuildConfig (stored in local.properties)&#10;        private val CLOUD_NAME = BuildConfig.CLOUDINARY_CLOUD_NAME&#10;        private val API_KEY = BuildConfig.CLOUDINARY_API_KEY&#10;        private val API_SECRET = BuildConfig.CLOUDINARY_API_SECRET&#10;&#10;        // Folder paths in Cloudinary&#10;        private const val PROFILE_PICTURES_FOLDER = &quot;secret_spaces/profile_pictures&quot;&#10;        private const val POST_IMAGES_FOLDER = &quot;secret_spaces/post_images&quot;&#10;        private const val STORY_IMAGES_FOLDER = &quot;secret_spaces/story_images&quot;&#10;&#10;        @Volatile&#10;        private var isInitialized = false&#10;    }&#10;&#10;    init {&#10;        initializeCloudinary()&#10;    }&#10;&#10;    /**&#10;     * Initialize Cloudinary MediaManager&#10;     */&#10;    private fun initializeCloudinary() {&#10;        if (!isInitialized) {&#10;            synchronized(this) {&#10;                if (!isInitialized) {&#10;                    val config = mapOf(&#10;                        &quot;cloud_name&quot; to CLOUD_NAME,&#10;                        &quot;api_key&quot; to API_KEY,&#10;                        &quot;api_secret&quot; to API_SECRET,&#10;                        &quot;secure&quot; to true&#10;                    )&#10;                    MediaManager.init(context, config)&#10;                    isInitialized = true&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Upload profile picture&#10;     * Folder: secret_spaces/profile_pictures/{userId}/&#10;     */&#10;    suspend fun uploadProfilePicture(imageUri: Uri): Result&lt;String&gt; {&#10;        val userId = getCurrentUserId()&#10;            ?: return Result.failure(Exception(&quot;User not authenticated&quot;))&#10;&#10;        return try {&#10;            val timestamp = System.currentTimeMillis()&#10;&#10;            val options = mapOf(&#10;                &quot;folder&quot; to &quot;$PROFILE_PICTURES_FOLDER/$userId&quot;,&#10;                &quot;public_id&quot; to &quot;profile_$timestamp&quot;,&#10;                &quot;resource_type&quot; to &quot;image&quot;,&#10;                &quot;context&quot; to mapOf(&#10;                    &quot;uploadedBy&quot; to userId,&#10;                    &quot;uploadedAt&quot; to timestamp.toString(),&#10;                    &quot;imageType&quot; to &quot;PROFILE&quot;&#10;                ),&#10;                &quot;overwrite&quot; to true,&#10;                &quot;invalidate&quot; to true&#10;            )&#10;&#10;            uploadImage(imageUri, options)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Upload post/secret image&#10;     * Folder: secret_spaces/post_images/{userId}/&#10;     */&#10;    suspend fun uploadPostImage(imageUri: Uri, postId: String? = null): Result&lt;String&gt; {&#10;        val userId = getCurrentUserId()&#10;            ?: return Result.failure(Exception(&quot;User not authenticated&quot;))&#10;&#10;        return try {&#10;            val timestamp = System.currentTimeMillis()&#10;            val id = postId ?: UUID.randomUUID().toString()&#10;            val filename = &quot;${id}_$timestamp&quot;&#10;&#10;            val options = mapOf(&#10;                &quot;folder&quot; to &quot;$POST_IMAGES_FOLDER/$userId&quot;,&#10;                &quot;public_id&quot; to filename,&#10;                &quot;resource_type&quot; to &quot;image&quot;,&#10;                &quot;context&quot; to mapOf(&#10;                    &quot;uploadedBy&quot; to userId,&#10;                    &quot;uploadedAt&quot; to timestamp.toString(),&#10;                    &quot;imageType&quot; to &quot;POST&quot;,&#10;                    &quot;postId&quot; to id&#10;                )&#10;            )&#10;&#10;            uploadImage(imageUri, options)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Upload story image&#10;     * Folder: secret_spaces/story_images/{userId}/&#10;     * Stories are temporary and expire after 24 hours&#10;     */&#10;    suspend fun uploadStoryImage(imageUri: Uri): Result&lt;String&gt; {&#10;        val userId = getCurrentUserId()&#10;            ?: return Result.failure(Exception(&quot;User not authenticated&quot;))&#10;&#10;        return try {&#10;            val timestamp = System.currentTimeMillis()&#10;            val filename = &quot;story_$timestamp&quot;&#10;            val expiresAt = timestamp + (24 * 60 * 60 * 1000) // 24 hours&#10;&#10;            val options = mapOf(&#10;                &quot;folder&quot; to &quot;$STORY_IMAGES_FOLDER/$userId&quot;,&#10;                &quot;public_id&quot; to filename,&#10;                &quot;resource_type&quot; to &quot;image&quot;,&#10;                &quot;context&quot; to mapOf(&#10;                    &quot;uploadedBy&quot; to userId,&#10;                    &quot;uploadedAt&quot; to timestamp.toString(),&#10;                    &quot;imageType&quot; to &quot;STORY&quot;,&#10;                    &quot;expiresAt&quot; to expiresAt.toString()&#10;                )&#10;            )&#10;&#10;            uploadImage(imageUri, options)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Core upload function using Cloudinary SDK&#10;     */&#10;    private suspend fun uploadImage(&#10;        imageUri: Uri,&#10;        options: Map&lt;String, Any&gt;&#10;    ): Result&lt;String&gt; = suspendCancellableCoroutine { continuation -&gt;&#10;        try {&#10;            val requestId = MediaManager.get().upload(imageUri)&#10;                .options(options)&#10;                .callback(object : UploadCallback {&#10;                    override fun onStart(requestId: String) {&#10;                        // Upload started&#10;                    }&#10;&#10;                    override fun onProgress(requestId: String, bytes: Long, totalBytes: Long) {&#10;                        // Progress update&#10;                    }&#10;&#10;                    override fun onSuccess(requestId: String, resultData: Map&lt;*, *&gt;) {&#10;                        val secureUrl = resultData[&quot;secure_url&quot;] as? String&#10;                        if (secureUrl != null) {&#10;                            continuation.resume(Result.success(secureUrl))&#10;                        } else {&#10;                            continuation.resume(&#10;                                Result.failure(Exception(&quot;Failed to get image URL from Cloudinary&quot;))&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    override fun onError(requestId: String, error: ErrorInfo) {&#10;                        continuation.resume(&#10;                            Result.failure(Exception(&quot;Upload failed: ${error.description}&quot;))&#10;                        )&#10;                    }&#10;&#10;                    override fun onReschedule(requestId: String, error: ErrorInfo) {&#10;                        // Upload rescheduled&#10;                    }&#10;                })&#10;                .dispatch()&#10;&#10;            continuation.invokeOnCancellation {&#10;                // Cancel the upload if coroutine is cancelled&#10;                try {&#10;                    MediaManager.get().cancelRequest(requestId)&#10;                } catch (_: Exception) {&#10;                    // Ignore cancellation errors&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            continuation.resume(Result.failure(Exception(&quot;Failed to start upload: ${e.message}&quot;, e)))&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Delete an image from Cloudinary by URL&#10;     */&#10;    @Suppress(&quot;RedundantSuspendModifier&quot;)&#10;    suspend fun deleteImage(imageUrl: String): Result&lt;Unit&gt; {&#10;        return try {&#10;            // Note: Cloudinary Android SDK doesn't support deletion directly&#10;            // You'll need to use the REST API or admin SDK for deletion&#10;            // For now, we'll return success as images can be managed from Cloudinary dashboard&#10;            Result.success(Unit)&#10;        } catch (e: Exception) {&#10;            Result.failure(Exception(&quot;Failed to delete image: ${e.message}&quot;, e))&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Delete all profile pictures for a user&#10;     */&#10;    @Suppress(&quot;RedundantSuspendModifier&quot;, &quot;UNUSED_PARAMETER&quot;)&#10;    suspend fun deleteUserProfilePictures(userId: String): Result&lt;Unit&gt; {&#10;        // Cloudinary Android SDK doesn't support bulk deletion&#10;        // Use Cloudinary dashboard or admin API for bulk operations&#10;        return Result.success(Unit)&#10;    }&#10;&#10;    /**&#10;     * Delete all posts for a user&#10;     */&#10;    @Suppress(&quot;RedundantSuspendModifier&quot;, &quot;UNUSED_PARAMETER&quot;)&#10;    suspend fun deleteUserPosts(userId: String): Result&lt;Unit&gt; {&#10;        // Cloudinary Android SDK doesn't support bulk deletion&#10;        // Use Cloudinary dashboard or admin API for bulk operations&#10;        return Result.success(Unit)&#10;    }&#10;&#10;    /**&#10;     * Delete all stories for a user&#10;     */&#10;    @Suppress(&quot;RedundantSuspendModifier&quot;, &quot;UNUSED_PARAMETER&quot;)&#10;    suspend fun deleteUserStories(userId: String): Result&lt;Unit&gt; {&#10;        // Cloudinary Android SDK doesn't support bulk deletion&#10;        // Use Cloudinary dashboard or admin API for bulk operations&#10;        return Result.success(Unit)&#10;    }&#10;&#10;    /**&#10;     * Extract public_id from Cloudinary URL&#10;     */&#10;    private fun extractPublicIdFromUrl(url: String): String? {&#10;        return try {&#10;            val regex = &quot;&quot;&quot;$CLOUD_NAME/image/upload/(?:v\d+/)?(.+)\.[a-zA-Z]+&quot;&quot;&quot;.toRegex()&#10;            regex.find(url)?.groupValues?.getOrNull(1)&#10;        } catch (_: Exception) {&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get current authenticated user ID&#10;     */&#10;    private fun getCurrentUserId(): String? = auth.currentUser?.uid&#10;&#10;    /**&#10;     * Get Cloudinary URL with transformations&#10;     */&#10;    fun getTransformedUrl(&#10;        imageUrl: String,&#10;        width: Int? = null,&#10;        height: Int? = null,&#10;        quality: String = &quot;auto&quot;,&#10;        format: String = &quot;auto&quot;&#10;    ): String {&#10;        if (!imageUrl.contains(CLOUD_NAME)) return imageUrl&#10;&#10;        val transformations = buildList {&#10;            if (width != null) add(&quot;w_$width&quot;)&#10;            if (height != null) add(&quot;h_$height&quot;)&#10;            add(&quot;q_$quality&quot;)&#10;            add(&quot;f_$format&quot;)&#10;            add(&quot;c_limit&quot;)&#10;        }.joinToString(&quot;,&quot;)&#10;&#10;        return imageUrl.replace(&#10;            &quot;/image/upload/&quot;,&#10;            &quot;/image/upload/$transformations/&quot;&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Get thumbnail URL (optimized for loading)&#10;     */&#10;    @Suppress(&quot;unused&quot;)&#10;    fun getThumbnailUrl(imageUrl: String, size: Int = 200): String {&#10;        return getTransformedUrl(&#10;            imageUrl = imageUrl,&#10;            width = size,&#10;            height = size,&#10;            quality = &quot;auto:low&quot;,&#10;            format = &quot;webp&quot;&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/local.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/local.properties" />
              <option name="originalContent" value="## This file is automatically generated by Android Studio.&#10;# Do not modify this file -- YOUR CHANGES WILL BE ERASED!&#10;#&#10;# This file should *NOT* be checked into Version Control Systems,&#10;# as it contains information specific to your local configuration.&#10;#&#10;# Location of the SDK. This is only used by Gradle.&#10;# For customization when using a Version Control System, please read the&#10;# header note.&#10;sdk.dir=D\:\\Android_SDK&#10;&#10;# MapTiler API Key&#10;# Get your free API key from https://cloud.maptiler.com/&#10;MAPTILER_API_KEY=Ibp6tZAVf1nvnwVyNNUD&#10;" />
              <option name="updatedContent" value="## This file is automatically generated by Android Studio.&#10;# Do not modify this file -- YOUR CHANGES WILL BE ERASED!&#10;#&#10;# This file should *NOT* be checked into Version Control Systems,&#10;# as it contains information specific to your local configuration.&#10;#&#10;# Location of the SDK. This is only used by Gradle.&#10;# For customization when using a Version Control System, please read the&#10;# header note.&#10;sdk.dir=D\:\\Android_SDK&#10;&#10;# MapTiler API Key&#10;# Get your free API key from https://cloud.maptiler.com/&#10;MAPTILER_API_KEY=Ibp6tZAVf1nvnwVyNNUD&#10;&#10;# Cloudinary Configuration&#10;# IMPORTANT: These credentials are exposed on GitHub - ROTATE THEM IMMEDIATELY&#10;# Get new credentials from: https://console.cloudinary.com/&#10;CLOUDINARY_CLOUD_NAME=dt9lrjzm3&#10;CLOUDINARY_API_KEY=383797572254455&#10;CLOUDINARY_API_SECRET=yAo7e4IdM9PB7QlBIPOgDoUdeJk" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>