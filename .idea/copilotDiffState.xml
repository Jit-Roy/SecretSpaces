<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/secretspaces32/android/ui/screens/MapScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/secretspaces32/android/ui/screens/MapScreen.kt" />
              <option name="originalContent" value="package com.secretspaces32.android.ui.screens&#10;&#10;import android.location.Location&#10;import androidx.compose.animation.*&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.shadow&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import com.google.gson.JsonPrimitive&#10;import com.secretspaces32.android.BuildConfig&#10;import com.secretspaces32.android.data.model.Secret&#10;import com.secretspaces32.android.ui.components.*&#10;import com.secretspaces32.android.ui.theme.*&#10;import com.secretspaces32.android.utils.LocationHelper&#10;import org.maplibre.android.MapLibre&#10;import org.maplibre.android.camera.CameraUpdateFactory&#10;import org.maplibre.android.geometry.LatLng&#10;import org.maplibre.android.maps.MapView&#10;import org.maplibre.android.plugins.annotation.SymbolManager&#10;import org.maplibre.android.plugins.annotation.SymbolOptions&#10;&#10;@Composable&#10;fun MapScreen(&#10;    currentLocation: Location?,&#10;    nearbySecrets: List&lt;Secret&gt;,&#10;    isLoading: Boolean,&#10;    onSecretClick: (Secret) -&gt; Unit,&#10;    onDropSecretClick: () -&gt; Unit,&#10;    onProfileClick: () -&gt; Unit,&#10;    onFeedClick: () -&gt; Unit&#10;) {&#10;    var showSecretPreview by remember { mutableStateOf&lt;Secret?&gt;(null) }&#10;    var bottomSheetOffset by remember { mutableFloatStateOf(0f) }&#10;    val maxDragDistance = 300f&#10;&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Map background&#10;        if (currentLocation != null) {&#10;            MapViewComposable(&#10;                currentLocation = currentLocation,&#10;                secrets = nearbySecrets,&#10;                onMarkerClick = { showSecretPreview = it }&#10;            )&#10;        } else {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .background(DarkBackground),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    CircularProgressIndicator(&#10;                        color = TealPrimary,&#10;                        modifier = Modifier.size(42.dp)&#10;                    )&#10;                    Text(&#10;                        text = &quot;Loading map...&quot;,&#10;                        color = Color.White,&#10;                        style = MaterialTheme.typography.bodyLarge&#10;                    )&#10;                    Text(&#10;                        text = &quot;Fetching your location&quot;,&#10;                        color = Color.White.copy(alpha = 0.6f),&#10;                        style = MaterialTheme.typography.bodySmall&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Top bar&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .statusBarsPadding()&#10;                .padding(horizontal = 20.dp, vertical = 16.dp),&#10;            horizontalArrangement = Arrangement.End&#10;        ) {&#10;            IconButton(&#10;                onClick = onProfileClick,&#10;                modifier = Modifier&#10;                    .size(42.dp)&#10;                    .shadow(10.dp, CircleShape)&#10;                    .background(DarkSurface.copy(alpha = 0.9f), CircleShape)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.AccountCircle,&#10;                    contentDescription = &quot;Profile&quot;,&#10;                    tint = TealPrimary,&#10;                    modifier = Modifier.size(26.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        // Bottom sheet (Nearby secrets)&#10;        Column(&#10;            modifier = Modifier&#10;                .align(Alignment.BottomCenter)&#10;                .fillMaxWidth()&#10;                .offset(y = bottomSheetOffset.dp)&#10;                .pointerInput(Unit) {&#10;                    detectDragGestures(&#10;                        onDragEnd = {&#10;                            if (bottomSheetOffset &lt; -maxDragDistance) onFeedClick()&#10;                            bottomSheetOffset = 0f&#10;                        },&#10;                        onDrag = { change, dragAmount -&gt;&#10;                            change.consume()&#10;                            val newOffset = bottomSheetOffset + dragAmount.y&#10;                            bottomSheetOffset = newOffset.coerceIn(-maxDragDistance, 0f)&#10;                        }&#10;                    )&#10;                }&#10;                .background(&#10;                    color = DarkSurface.copy(alpha = 0.98f),&#10;                    shape = RoundedCornerShape(topStart = 24.dp, topEnd = 24.dp)&#10;                )&#10;                .padding(top = 8.dp)&#10;        ) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .width(40.dp)&#10;                    .height(4.dp)&#10;                    .background(Color.White.copy(alpha = 0.3f), RoundedCornerShape(2.dp))&#10;                    .align(Alignment.CenterHorizontally)&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 20.dp),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot; Nearby Secrets&quot;,&#10;                    style = MaterialTheme.typography.titleLarge.copy(&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = Color.White&#10;                    )&#10;                )&#10;&#10;                Surface(&#10;                    shape = RoundedCornerShape(12.dp),&#10;                    color = TealPrimary.copy(alpha = 0.25f)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;${nearbySecrets.size}&quot;,&#10;                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp),&#10;                        style = MaterialTheme.typography.labelLarge,&#10;                        color = TealPrimary,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            when {&#10;                isLoading -&gt; {&#10;                    LazyColumn(&#10;                        modifier = Modifier.height(240.dp),&#10;                        contentPadding = PaddingValues(horizontal = 20.dp, vertical = 8.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        items(2) { ShimmerLoadingCard() }&#10;                    }&#10;                }&#10;&#10;                nearbySecrets.isEmpty() -&gt; {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .height(200.dp)&#10;                            .padding(32.dp),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Column(&#10;                            horizontalAlignment = Alignment.CenterHorizontally,&#10;                            verticalArrangement = Arrangement.spacedBy(10.dp)&#10;                        ) {&#10;                            Text(&quot;&quot;, style = MaterialTheme.typography.displayMedium)&#10;                            Text(&#10;                                text = &quot;No secrets nearby&quot;,&#10;                                style = MaterialTheme.typography.titleMedium,&#10;                                color = Color.White&#10;                            )&#10;                            Text(&#10;                                text = &quot;Be the first to drop one!&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = Color.White.copy(alpha = 0.6f)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                else -&gt; {&#10;                    LazyColumn(&#10;                        modifier = Modifier.height(240.dp),&#10;                        contentPadding = PaddingValues(horizontal = 20.dp, vertical = 8.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        items(nearbySecrets.take(3), key = { it.id }) { secret -&gt;&#10;                            CompactSecretCard(secret = secret) { onSecretClick(secret) }&#10;                        }&#10;&#10;                        if (nearbySecrets.size &gt; 3) {&#10;                            item {&#10;                                Box(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .clickable { onFeedClick() }&#10;                                        .padding(vertical = 8.dp),&#10;                                    contentAlignment = Alignment.Center&#10;                                ) {&#10;                                    Row(&#10;                                        horizontalArrangement = Arrangement.spacedBy(6.dp),&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        Text(&#10;                                            text = &quot;See ${nearbySecrets.size - 3} more secrets&quot;,&#10;                                            style = MaterialTheme.typography.bodyMedium,&#10;                                            color = TealPrimary,&#10;                                            fontWeight = FontWeight.SemiBold&#10;                                        )&#10;                                        Icon(&#10;                                            imageVector = Icons.Default.KeyboardArrowUp,&#10;                                            contentDescription = null,&#10;                                            tint = TealPrimary,&#10;                                            modifier = Modifier.size(20.dp)&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 18.dp),&#10;                contentAlignment = Alignment.CenterEnd&#10;            ) {&#10;                FloatingActionButton(&#10;                    onClick = onDropSecretClick,&#10;                    modifier = Modifier&#10;                        .size(64.dp)&#10;                        .padding(end = 20.dp)&#10;                        .shadow(14.dp, CircleShape),&#10;                    containerColor = TealPrimary,&#10;                    contentColor = Color.White&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Add,&#10;                        contentDescription = &quot;Drop Secret&quot;,&#10;                        modifier = Modifier.size(28.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Secret Preview Modal&#10;        AnimatedVisibility(&#10;            visible = showSecretPreview != null,&#10;            enter = fadeIn() + scaleIn(initialScale = 0.8f),&#10;            exit = fadeOut() + scaleOut(targetScale = 0.8f)&#10;        ) {&#10;            showSecretPreview?.let { secret -&gt;&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .background(Color.Black.copy(alpha = 0.6f))&#10;                        .clickable { showSecretPreview = null },&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Card(&#10;                        modifier = Modifier.fillMaxWidth(0.9f),&#10;                        shape = RoundedCornerShape(24.dp),&#10;                        colors = CardDefaults.cardColors(containerColor = DarkSurface),&#10;                        elevation = CardDefaults.cardElevation(10.dp)&#10;                    ) {&#10;                        Column(modifier = Modifier.padding(24.dp)) {&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.SpaceBetween,&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot; Secret&quot;,&#10;                                    style = MaterialTheme.typography.titleLarge,&#10;                                    color = TealPrimary,&#10;                                    fontWeight = FontWeight.Bold&#10;                                )&#10;                                IconButton(&#10;                                    onClick = { showSecretPreview = null },&#10;                                    modifier = Modifier.size(32.dp)&#10;                                ) {&#10;                                    Icon(&#10;                                        imageVector = Icons.Default.Close,&#10;                                        contentDescription = &quot;Close&quot;,&#10;                                        tint = Color.White.copy(alpha = 0.7f)&#10;                                    )&#10;                                }&#10;                            }&#10;&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;                            Text(&#10;                                text = secret.text,&#10;                                style = MaterialTheme.typography.bodyLarge,&#10;                                color = Color.White,&#10;                                lineHeight = 24.sp&#10;                            )&#10;&#10;                            Spacer(modifier = Modifier.height(20.dp))&#10;&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.SpaceBetween,&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                secret.distance?.let { distance -&gt;&#10;                                    Row(&#10;                                        horizontalArrangement = Arrangement.spacedBy(6.dp),&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        Icon(&#10;                                            imageVector = Icons.Default.LocationOn,&#10;                                            contentDescription = null,&#10;                                            tint = AquaGreen,&#10;                                            modifier = Modifier.size(18.dp)&#10;                                        )&#10;                                        Text(&#10;                                            text = LocationHelper.formatDistance(distance),&#10;                                            style = MaterialTheme.typography.bodyMedium,&#10;                                            color = AquaGreen&#10;                                        )&#10;                                    }&#10;                                }&#10;&#10;                                Button(&#10;                                    onClick = {&#10;                                        showSecretPreview = null&#10;                                        onSecretClick(secret)&#10;                                    },&#10;                                    colors = ButtonDefaults.buttonColors(containerColor = TealPrimary),&#10;                                    shape = RoundedCornerShape(12.dp)&#10;                                ) {&#10;                                    Text(&quot;View Details&quot;)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CompactSecretCard(secret: Secret, onClick: () -&gt; Unit) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        shape = RoundedCornerShape(16.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = DarkBackground.copy(alpha = 0.7f)&#10;        ),&#10;        onClick = onClick&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.padding(16.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.weight(1f),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                Text(&#10;                    text = secret.text,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    color = Color.White,&#10;                    maxLines = 2&#10;                )&#10;                Row(&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    secret.distance?.let { distance -&gt;&#10;                        Row(&#10;                            horizontalArrangement = Arrangement.spacedBy(4.dp),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.LocationOn,&#10;                                contentDescription = null,&#10;                                tint = AquaGreen,&#10;                                modifier = Modifier.size(14.dp)&#10;                            )&#10;                            Text(&#10;                                text = LocationHelper.formatDistance(distance),&#10;                                style = MaterialTheme.typography.labelMedium,&#10;                                color = AquaGreen&#10;                            )&#10;                        }&#10;                    }&#10;                    Text(&#10;                        text = LocationHelper.formatTimestamp(secret.timestamp),&#10;                        style = MaterialTheme.typography.labelMedium,&#10;                        color = Color.White.copy(alpha = 0.5f)&#10;                    )&#10;                }&#10;            }&#10;            Icon(&#10;                imageVector = Icons.Default.ChevronRight,&#10;                contentDescription = null,&#10;                tint = TealPrimary.copy(alpha = 0.6f),&#10;                modifier = Modifier.size(24.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MapViewComposable(&#10;    currentLocation: Location,&#10;    secrets: List&lt;Secret&gt;,&#10;    onMarkerClick: (Secret) -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val lifecycleOwner = LocalLifecycleOwner.current&#10;    val lifecycle = lifecycleOwner.lifecycle&#10;&#10;    var mapView by remember { mutableStateOf&lt;MapView?&gt;(null) }&#10;    var symbolManager by remember { mutableStateOf&lt;SymbolManager?&gt;(null) }&#10;    var isMapReady by remember { mutableStateOf(false) }&#10;&#10;    DisposableEffect(Unit) {&#10;        try {&#10;            MapLibre.getInstance(context)&#10;        } catch (e: Exception) {&#10;            println(&quot;MapLibre initialization error: ${e.message}&quot;)&#10;            e.printStackTrace()&#10;        }&#10;        onDispose {&#10;            try {&#10;                symbolManager?.onDestroy()&#10;                mapView?.onPause()&#10;                mapView?.onStop()&#10;                mapView?.onDestroy()&#10;            } catch (e: Exception) {&#10;                println(&quot;Cleanup error: ${e.message}&quot;)&#10;                e.printStackTrace()&#10;            }&#10;            symbolManager = null&#10;            mapView = null&#10;        }&#10;    }&#10;&#10;    Box(modifier = Modifier.fillMaxSize().background(DarkBackground)) {&#10;        AndroidView(&#10;            factory = { ctx -&gt;&#10;                try {&#10;                    println(&quot;Creating MapView...&quot;)&#10;                    MapView(ctx).apply {&#10;                        this.id = android.view.View.generateViewId()&#10;                        setBackgroundColor(android.graphics.Color.BLACK)&#10;&#10;                        // Store reference immediately&#10;                        mapView = this&#10;&#10;                        // Initialize lifecycle immediately in factory&#10;                        this.onCreate(null)&#10;                        this.onStart()&#10;                        this.onResume()&#10;&#10;                        println(&quot;MapView created and lifecycle initialized&quot;)&#10;&#10;                        // Setup map directly in factory using post to ensure view is attached&#10;                        this.post {&#10;                            println(&quot;Post called - setting up map...&quot;)&#10;                            try {&#10;                                this.getMapAsync { mapLibreMap -&gt;&#10;                                    println(&quot;✅ getMapAsync callback triggered!&quot;)&#10;                                    try {&#10;                                        println(&quot;Loading style...&quot;)&#10;                                        val styleUrl = &quot;https://api.maptiler.com/maps/streets-v2/style.json?key=${BuildConfig.MAPTILER_API_KEY}&quot;&#10;&#10;                                        mapLibreMap.setStyle(styleUrl) { style -&gt;&#10;                                            println(&quot;✅ Style callback triggered!&quot;)&#10;                                            try {&#10;                                                println(&quot;Adding markers...&quot;)&#10;                                                val position = LatLng(currentLocation.latitude, currentLocation.longitude)&#10;                                                mapLibreMap.moveCamera(CameraUpdateFactory.newLatLngZoom(position, 14.0))&#10;&#10;                                                // Clean up old symbol manager&#10;                                                symbolManager?.onDestroy()&#10;&#10;                                                // Create symbol manager&#10;                                                val newSymbolManager = SymbolManager(this, mapLibreMap, style)&#10;                                                newSymbolManager.iconAllowOverlap = true&#10;                                                newSymbolManager.textAllowOverlap = true&#10;                                                symbolManager = newSymbolManager&#10;&#10;                                                // Current location marker&#10;                                                newSymbolManager.create(&#10;                                                    SymbolOptions()&#10;                                                        .withLatLng(position)&#10;                                                        .withTextField(&quot;&quot;)&#10;                                                        .withTextSize(18f)&#10;                                                        .withTextColor(&quot;rgb(0, 217, 208)&quot;)&#10;                                                )&#10;&#10;                                                // Secret markers&#10;                                                secrets.forEach { secret -&gt;&#10;                                                    newSymbolManager.create(&#10;                                                        SymbolOptions()&#10;                                                            .withLatLng(LatLng(secret.latitude, secret.longitude))&#10;                                                            .withTextField(&quot;&quot;)&#10;                                                            .withTextSize(18f)&#10;                                                            .withTextColor(&quot;rgb(123, 97, 255)&quot;)&#10;                                                            .withData(JsonPrimitive(secret.id))&#10;                                                    )&#10;                                                }&#10;&#10;                                                newSymbolManager.addClickListener { symbol -&gt;&#10;                                                    symbol.data?.let { data -&gt;&#10;                                                        secrets.find { it.id == data.asString }?.let(onMarkerClick)&#10;                                                    }&#10;                                                    true&#10;                                                }&#10;&#10;                                                isMapReady = true&#10;                                                println(&quot;✅ Map setup complete!&quot;)&#10;                                            } catch (e: Exception) {&#10;                                                println(&quot;❌ Error in style callback: ${e.message}&quot;)&#10;                                                e.printStackTrace()&#10;                                                isMapReady = true&#10;                                            }&#10;                                        }&#10;                                    } catch (e: Exception) {&#10;                                        println(&quot;❌ Error setting style: ${e.message}&quot;)&#10;                                        e.printStackTrace()&#10;                                        isMapReady = true&#10;                                    }&#10;                                }&#10;                            } catch (e: Exception) {&#10;                                println(&quot;❌ Error in getMapAsync: ${e.message}&quot;)&#10;                                e.printStackTrace()&#10;                                isMapReady = true&#10;                            }&#10;                        }&#10;                    }&#10;                } catch (e: Exception) {&#10;                    println(&quot;MapView creation error: ${e.message}&quot;)&#10;                    e.printStackTrace()&#10;                    // Return a fallback view if map creation fails&#10;                    android.widget.FrameLayout(ctx).apply {&#10;                        setBackgroundColor(android.graphics.Color.BLACK)&#10;                    }&#10;                }&#10;            },&#10;            modifier = Modifier.fillMaxSize()&#10;        )&#10;&#10;        // Show loading indicator while map initializes&#10;        if (!isMapReady) {&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    CircularProgressIndicator(color = TealPrimary)&#10;                    Text(&#10;                        text = &quot;Initializing map...&quot;,&#10;                        color = Color.White,&#10;                        style = MaterialTheme.typography.bodyMedium&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Timeout fallback&#10;    LaunchedEffect(Unit) {&#10;        kotlinx.coroutines.delay(15000)&#10;        if (!isMapReady) {&#10;            println(&quot;⚠️ Map loading timeout after 15 seconds - forcing show&quot;)&#10;            isMapReady = true&#10;        }&#10;    }&#10;&#10;    DisposableEffect(lifecycle) {&#10;        val observer = LifecycleEventObserver { _, event -&gt;&#10;            println(&quot;Lifecycle event: $event&quot;)&#10;            when (event) {&#10;                Lifecycle.Event.ON_PAUSE -&gt; {&#10;                    try {&#10;                        mapView?.onPause()&#10;                    } catch (e: Exception) {&#10;                        println(&quot;onPause error: ${e.message}&quot;)&#10;                        e.printStackTrace()&#10;                    }&#10;                }&#10;                Lifecycle.Event.ON_RESUME -&gt; {&#10;                    try {&#10;                        mapView?.onResume()&#10;                    } catch (e: Exception) {&#10;                        println(&quot;onResume error: ${e.message}&quot;)&#10;                        e.printStackTrace()&#10;                    }&#10;                }&#10;                Lifecycle.Event.ON_STOP -&gt; {&#10;                    try {&#10;                        mapView?.onStop()&#10;                    } catch (e: Exception) {&#10;                        println(&quot;onStop error: ${e.message}&quot;)&#10;                        e.printStackTrace()&#10;                    }&#10;                }&#10;                Lifecycle.Event.ON_START -&gt; {&#10;                    try {&#10;                        mapView?.onStart()&#10;                    } catch (e: Exception) {&#10;                        println(&quot;onStart error: ${e.message}&quot;)&#10;                        e.printStackTrace()&#10;                    }&#10;                }&#10;                Lifecycle.Event.ON_DESTROY -&gt; {&#10;                    try {&#10;                        println(&quot;Calling onDestroy on MapView&quot;)&#10;                        symbolManager?.onDestroy()&#10;                        symbolManager = null&#10;                        mapView?.onDestroy()&#10;                        mapView = null&#10;                    } catch (e: Exception) {&#10;                        println(&quot;onDestroy error: ${e.message}&quot;)&#10;                        e.printStackTrace()&#10;                    }&#10;                }&#10;                else -&gt; {}&#10;            }&#10;        }&#10;&#10;        lifecycle.addObserver(observer)&#10;&#10;        onDispose {&#10;            lifecycle.removeObserver(observer)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.secretspaces32.android.ui.screens&#10;&#10;import android.location.Location&#10;import androidx.compose.animation.*&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.shadow&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import com.google.gson.JsonPrimitive&#10;import com.secretspaces32.android.BuildConfig&#10;import com.secretspaces32.android.data.model.Secret&#10;import com.secretspaces32.android.ui.components.*&#10;import com.secretspaces32.android.ui.theme.*&#10;import com.secretspaces32.android.utils.LocationHelper&#10;import org.maplibre.android.MapLibre&#10;import org.maplibre.android.camera.CameraUpdateFactory&#10;import org.maplibre.android.geometry.LatLng&#10;import org.maplibre.android.maps.MapView&#10;import org.maplibre.android.plugins.annotation.SymbolManager&#10;import org.maplibre.android.plugins.annotation.SymbolOptions&#10;&#10;@Composable&#10;fun MapScreen(&#10;    currentLocation: Location?,&#10;    nearbySecrets: List&lt;Secret&gt;,&#10;    isLoading: Boolean,&#10;    onSecretClick: (Secret) -&gt; Unit,&#10;    onDropSecretClick: () -&gt; Unit,&#10;    onProfileClick: () -&gt; Unit,&#10;    onFeedClick: () -&gt; Unit&#10;) {&#10;    var showSecretPreview by remember { mutableStateOf&lt;Secret?&gt;(null) }&#10;    var bottomSheetOffset by remember { mutableFloatStateOf(0f) }&#10;    val maxDragDistance = 300f&#10;&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Map background&#10;        if (currentLocation != null) {&#10;            MapViewComposable(&#10;                currentLocation = currentLocation,&#10;                secrets = nearbySecrets,&#10;                onMarkerClick = { showSecretPreview = it }&#10;            )&#10;        } else {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .background(DarkBackground),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    CircularProgressIndicator(&#10;                        color = TealPrimary,&#10;                        modifier = Modifier.size(42.dp)&#10;                    )&#10;                    Text(&#10;                        text = &quot;Loading map...&quot;,&#10;                        color = Color.White,&#10;                        style = MaterialTheme.typography.bodyLarge&#10;                    )&#10;                    Text(&#10;                        text = &quot;Fetching your location&quot;,&#10;                        color = Color.White.copy(alpha = 0.6f),&#10;                        style = MaterialTheme.typography.bodySmall&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Top bar&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .statusBarsPadding()&#10;                .padding(horizontal = 20.dp, vertical = 16.dp),&#10;            horizontalArrangement = Arrangement.End&#10;        ) {&#10;            IconButton(&#10;                onClick = onProfileClick,&#10;                modifier = Modifier&#10;                    .size(42.dp)&#10;                    .shadow(10.dp, CircleShape)&#10;                    .background(DarkSurface.copy(alpha = 0.9f), CircleShape)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.AccountCircle,&#10;                    contentDescription = &quot;Profile&quot;,&#10;                    tint = TealPrimary,&#10;                    modifier = Modifier.size(26.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        // Bottom sheet (Nearby secrets)&#10;        Column(&#10;            modifier = Modifier&#10;                .align(Alignment.BottomCenter)&#10;                .fillMaxWidth()&#10;                .offset(y = bottomSheetOffset.dp)&#10;                .pointerInput(Unit) {&#10;                    detectDragGestures(&#10;                        onDragEnd = {&#10;                            if (bottomSheetOffset &lt; -maxDragDistance) onFeedClick()&#10;                            bottomSheetOffset = 0f&#10;                        },&#10;                        onDrag = { change, dragAmount -&gt;&#10;                            change.consume()&#10;                            val newOffset = bottomSheetOffset + dragAmount.y&#10;                            bottomSheetOffset = newOffset.coerceIn(-maxDragDistance, 0f)&#10;                        }&#10;                    )&#10;                }&#10;                .background(&#10;                    color = DarkSurface.copy(alpha = 0.98f),&#10;                    shape = RoundedCornerShape(topStart = 24.dp, topEnd = 24.dp)&#10;                )&#10;                .padding(top = 8.dp)&#10;        ) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .width(40.dp)&#10;                    .height(4.dp)&#10;                    .background(Color.White.copy(alpha = 0.3f), RoundedCornerShape(2.dp))&#10;                    .align(Alignment.CenterHorizontally)&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 20.dp),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot; Nearby Secrets&quot;,&#10;                    style = MaterialTheme.typography.titleLarge.copy(&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = Color.White&#10;                    )&#10;                )&#10;&#10;                Surface(&#10;                    shape = RoundedCornerShape(12.dp),&#10;                    color = TealPrimary.copy(alpha = 0.25f)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;${nearbySecrets.size}&quot;,&#10;                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp),&#10;                        style = MaterialTheme.typography.labelLarge,&#10;                        color = TealPrimary,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            when {&#10;                isLoading -&gt; {&#10;                    LazyColumn(&#10;                        modifier = Modifier.height(240.dp),&#10;                        contentPadding = PaddingValues(horizontal = 20.dp, vertical = 8.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        items(2) { ShimmerLoadingCard() }&#10;                    }&#10;                }&#10;&#10;                nearbySecrets.isEmpty() -&gt; {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .height(200.dp)&#10;                            .padding(32.dp),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Column(&#10;                            horizontalAlignment = Alignment.CenterHorizontally,&#10;                            verticalArrangement = Arrangement.spacedBy(10.dp)&#10;                        ) {&#10;                            Text(&quot;&quot;, style = MaterialTheme.typography.displayMedium)&#10;                            Text(&#10;                                text = &quot;No secrets nearby&quot;,&#10;                                style = MaterialTheme.typography.titleMedium,&#10;                                color = Color.White&#10;                            )&#10;                            Text(&#10;                                text = &quot;Be the first to drop one!&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = Color.White.copy(alpha = 0.6f)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                else -&gt; {&#10;                    LazyColumn(&#10;                        modifier = Modifier.height(240.dp),&#10;                        contentPadding = PaddingValues(horizontal = 20.dp, vertical = 8.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        items(nearbySecrets.take(3), key = { it.id }) { secret -&gt;&#10;                            CompactSecretCard(secret = secret) { onSecretClick(secret) }&#10;                        }&#10;&#10;                        if (nearbySecrets.size &gt; 3) {&#10;                            item {&#10;                                Box(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .clickable { onFeedClick() }&#10;                                        .padding(vertical = 8.dp),&#10;                                    contentAlignment = Alignment.Center&#10;                                ) {&#10;                                    Row(&#10;                                        horizontalArrangement = Arrangement.spacedBy(6.dp),&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        Text(&#10;                                            text = &quot;See ${nearbySecrets.size - 3} more secrets&quot;,&#10;                                            style = MaterialTheme.typography.bodyMedium,&#10;                                            color = TealPrimary,&#10;                                            fontWeight = FontWeight.SemiBold&#10;                                        )&#10;                                        Icon(&#10;                                            imageVector = Icons.Default.KeyboardArrowUp,&#10;                                            contentDescription = null,&#10;                                            tint = TealPrimary,&#10;                                            modifier = Modifier.size(20.dp)&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 18.dp),&#10;                contentAlignment = Alignment.CenterEnd&#10;            ) {&#10;                FloatingActionButton(&#10;                    onClick = onDropSecretClick,&#10;                    modifier = Modifier&#10;                        .size(64.dp)&#10;                        .padding(end = 20.dp)&#10;                        .shadow(14.dp, CircleShape),&#10;                    containerColor = TealPrimary,&#10;                    contentColor = Color.White&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Add,&#10;                        contentDescription = &quot;Drop Secret&quot;,&#10;                        modifier = Modifier.size(28.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Secret Preview Modal&#10;        AnimatedVisibility(&#10;            visible = showSecretPreview != null,&#10;            enter = fadeIn() + scaleIn(initialScale = 0.8f),&#10;            exit = fadeOut() + scaleOut(targetScale = 0.8f)&#10;        ) {&#10;            showSecretPreview?.let { secret -&gt;&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .background(Color.Black.copy(alpha = 0.6f))&#10;                        .clickable { showSecretPreview = null },&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Card(&#10;                        modifier = Modifier.fillMaxWidth(0.9f),&#10;                        shape = RoundedCornerShape(24.dp),&#10;                        colors = CardDefaults.cardColors(containerColor = DarkSurface),&#10;                        elevation = CardDefaults.cardElevation(10.dp)&#10;                    ) {&#10;                        Column(modifier = Modifier.padding(24.dp)) {&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.SpaceBetween,&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot; Secret&quot;,&#10;                                    style = MaterialTheme.typography.titleLarge,&#10;                                    color = TealPrimary,&#10;                                    fontWeight = FontWeight.Bold&#10;                                )&#10;                                IconButton(&#10;                                    onClick = { showSecretPreview = null },&#10;                                    modifier = Modifier.size(32.dp)&#10;                                ) {&#10;                                    Icon(&#10;                                        imageVector = Icons.Default.Close,&#10;                                        contentDescription = &quot;Close&quot;,&#10;                                        tint = Color.White.copy(alpha = 0.7f)&#10;                                    )&#10;                                }&#10;                            }&#10;&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;                            Text(&#10;                                text = secret.text,&#10;                                style = MaterialTheme.typography.bodyLarge,&#10;                                color = Color.White,&#10;                                lineHeight = 24.sp&#10;                            )&#10;&#10;                            Spacer(modifier = Modifier.height(20.dp))&#10;&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.SpaceBetween,&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                secret.distance?.let { distance -&gt;&#10;                                    Row(&#10;                                        horizontalArrangement = Arrangement.spacedBy(6.dp),&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        Icon(&#10;                                            imageVector = Icons.Default.LocationOn,&#10;                                            contentDescription = null,&#10;                                            tint = AquaGreen,&#10;                                            modifier = Modifier.size(18.dp)&#10;                                        )&#10;                                        Text(&#10;                                            text = LocationHelper.formatDistance(distance),&#10;                                            style = MaterialTheme.typography.bodyMedium,&#10;                                            color = AquaGreen&#10;                                        )&#10;                                    }&#10;                                }&#10;&#10;                                Button(&#10;                                    onClick = {&#10;                                        showSecretPreview = null&#10;                                        onSecretClick(secret)&#10;                                    },&#10;                                    colors = ButtonDefaults.buttonColors(containerColor = TealPrimary),&#10;                                    shape = RoundedCornerShape(12.dp)&#10;                                ) {&#10;                                    Text(&quot;View Details&quot;)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CompactSecretCard(secret: Secret, onClick: () -&gt; Unit) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        shape = RoundedCornerShape(16.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = DarkBackground.copy(alpha = 0.7f)&#10;        ),&#10;        onClick = onClick&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.padding(16.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.weight(1f),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                Text(&#10;                    text = secret.text,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    color = Color.White,&#10;                    maxLines = 2&#10;                )&#10;                Row(&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    secret.distance?.let { distance -&gt;&#10;                        Row(&#10;                            horizontalArrangement = Arrangement.spacedBy(4.dp),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.LocationOn,&#10;                                contentDescription = null,&#10;                                tint = AquaGreen,&#10;                                modifier = Modifier.size(14.dp)&#10;                            )&#10;                            Text(&#10;                                text = LocationHelper.formatDistance(distance),&#10;                                style = MaterialTheme.typography.labelMedium,&#10;                                color = AquaGreen&#10;                            )&#10;                        }&#10;                    }&#10;                    Text(&#10;                        text = LocationHelper.formatTimestamp(secret.timestamp),&#10;                        style = MaterialTheme.typography.labelMedium,&#10;                        color = Color.White.copy(alpha = 0.5f)&#10;                    )&#10;                }&#10;            }&#10;            Icon(&#10;                imageVector = Icons.Default.ChevronRight,&#10;                contentDescription = null,&#10;                tint = TealPrimary.copy(alpha = 0.6f),&#10;                modifier = Modifier.size(24.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MapViewComposable(&#10;    currentLocation: Location,&#10;    secrets: List&lt;Secret&gt;,&#10;    onMarkerClick: (Secret) -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val lifecycleOwner = LocalLifecycleOwner.current&#10;    val lifecycle = lifecycleOwner.lifecycle&#10;&#10;    var mapView by remember { mutableStateOf&lt;MapView?&gt;(null) }&#10;    var symbolManager by remember { mutableStateOf&lt;SymbolManager?&gt;(null) }&#10;    var isMapReady by remember { mutableStateOf(false) }&#10;&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            try {&#10;                symbolManager?.onDestroy()&#10;                mapView?.onPause()&#10;                mapView?.onStop()&#10;                mapView?.onDestroy()&#10;            } catch (e: Exception) {&#10;                println(&quot;Cleanup error: ${e.message}&quot;)&#10;                e.printStackTrace()&#10;            }&#10;            symbolManager = null&#10;            mapView = null&#10;        }&#10;    }&#10;&#10;    Box(modifier = Modifier.fillMaxSize().background(DarkBackground)) {&#10;        AndroidView(&#10;            factory = { ctx -&gt;&#10;                try {&#10;                    println(&quot;Creating MapView...&quot;)&#10;                    &#10;                    // Initialize MapLibre BEFORE creating MapView&#10;                    try {&#10;                        MapLibre.getInstance(ctx)&#10;                        println(&quot;MapLibre already initialized&quot;)&#10;                    } catch (e: Exception) {&#10;                        // MapLibre not initialized, initialize it now&#10;                        println(&quot;Initializing MapLibre...&quot;)&#10;                        MapLibre.getInstance(ctx)&#10;                        println(&quot;MapLibre initialized successfully&quot;)&#10;                    }&#10;                    &#10;                    MapView(ctx).apply {&#10;                        this.id = android.view.View.generateViewId()&#10;                        setBackgroundColor(android.graphics.Color.BLACK)&#10;&#10;                        // Store reference immediately&#10;                        mapView = this&#10;&#10;                        // Initialize lifecycle immediately in factory&#10;                        this.onCreate(null)&#10;                        this.onStart()&#10;                        this.onResume()&#10;&#10;                        println(&quot;MapView created and lifecycle initialized&quot;)&#10;&#10;                        // Setup map directly in factory using post to ensure view is attached&#10;                        this.post {&#10;                            println(&quot;Post called - setting up map...&quot;)&#10;                            try {&#10;                                this.getMapAsync { mapLibreMap -&gt;&#10;                                    println(&quot;✅ getMapAsync callback triggered!&quot;)&#10;                                    try {&#10;                                        println(&quot;Loading style...&quot;)&#10;                                        val styleUrl = &quot;https://api.maptiler.com/maps/streets-v2/style.json?key=${BuildConfig.MAPTILER_API_KEY}&quot;&#10;&#10;                                        mapLibreMap.setStyle(styleUrl) { style -&gt;&#10;                                            println(&quot;✅ Style callback triggered!&quot;)&#10;                                            try {&#10;                                                println(&quot;Adding markers...&quot;)&#10;                                                val position = LatLng(currentLocation.latitude, currentLocation.longitude)&#10;                                                mapLibreMap.moveCamera(CameraUpdateFactory.newLatLngZoom(position, 14.0))&#10;&#10;                                                // Clean up old symbol manager&#10;                                                symbolManager?.onDestroy()&#10;&#10;                                                // Create symbol manager&#10;                                                val newSymbolManager = SymbolManager(this, mapLibreMap, style)&#10;                                                newSymbolManager.iconAllowOverlap = true&#10;                                                newSymbolManager.textAllowOverlap = true&#10;                                                symbolManager = newSymbolManager&#10;&#10;                                                // Current location marker&#10;                                                newSymbolManager.create(&#10;                                                    SymbolOptions()&#10;                                                        .withLatLng(position)&#10;                                                        .withTextField(&quot;&quot;)&#10;                                                        .withTextSize(18f)&#10;                                                        .withTextColor(&quot;rgb(0, 217, 208)&quot;)&#10;                                                )&#10;&#10;                                                // Secret markers&#10;                                                secrets.forEach { secret -&gt;&#10;                                                    newSymbolManager.create(&#10;                                                        SymbolOptions()&#10;                                                            .withLatLng(LatLng(secret.latitude, secret.longitude))&#10;                                                            .withTextField(&quot;&quot;)&#10;                                                            .withTextSize(18f)&#10;                                                            .withTextColor(&quot;rgb(123, 97, 255)&quot;)&#10;                                                            .withData(JsonPrimitive(secret.id))&#10;                                                    )&#10;                                                }&#10;&#10;                                                newSymbolManager.addClickListener { symbol -&gt;&#10;                                                    symbol.data?.let { data -&gt;&#10;                                                        secrets.find { it.id == data.asString }?.let(onMarkerClick)&#10;                                                    }&#10;                                                    true&#10;                                                }&#10;&#10;                                                isMapReady = true&#10;                                                println(&quot;✅ Map setup complete!&quot;)&#10;                                            } catch (e: Exception) {&#10;                                                println(&quot;❌ Error in style callback: ${e.message}&quot;)&#10;                                                e.printStackTrace()&#10;                                                isMapReady = true&#10;                                            }&#10;                                        }&#10;                                    } catch (e: Exception) {&#10;                                        println(&quot;❌ Error setting style: ${e.message}&quot;)&#10;                                        e.printStackTrace()&#10;                                        isMapReady = true&#10;                                    }&#10;                                }&#10;                            } catch (e: Exception) {&#10;                                println(&quot;❌ Error in getMapAsync: ${e.message}&quot;)&#10;                                e.printStackTrace()&#10;                                isMapReady = true&#10;                            }&#10;                        }&#10;                    }&#10;                } catch (e: Exception) {&#10;                    println(&quot;MapView creation error: ${e.message}&quot;)&#10;                    e.printStackTrace()&#10;                    // Return a fallback view if map creation fails&#10;                    android.widget.FrameLayout(ctx).apply {&#10;                        setBackgroundColor(android.graphics.Color.BLACK)&#10;                    }&#10;                }&#10;            },&#10;            modifier = Modifier.fillMaxSize()&#10;        )&#10;&#10;        // Show loading indicator while map initializes&#10;        if (!isMapReady) {&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    CircularProgressIndicator(color = TealPrimary)&#10;                    Text(&#10;                        text = &quot;Initializing map...&quot;,&#10;                        color = Color.White,&#10;                        style = MaterialTheme.typography.bodyMedium&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Timeout fallback&#10;    LaunchedEffect(Unit) {&#10;        kotlinx.coroutines.delay(15000)&#10;        if (!isMapReady) {&#10;            println(&quot;⚠️ Map loading timeout after 15 seconds - forcing show&quot;)&#10;            isMapReady = true&#10;        }&#10;    }&#10;&#10;    DisposableEffect(lifecycle) {&#10;        val observer = LifecycleEventObserver { _, event -&gt;&#10;            println(&quot;Lifecycle event: $event&quot;)&#10;            when (event) {&#10;                Lifecycle.Event.ON_PAUSE -&gt; {&#10;                    try {&#10;                        mapView?.onPause()&#10;                    } catch (e: Exception) {&#10;                        println(&quot;onPause error: ${e.message}&quot;)&#10;                        e.printStackTrace()&#10;                    }&#10;                }&#10;                Lifecycle.Event.ON_RESUME -&gt; {&#10;                    try {&#10;                        mapView?.onResume()&#10;                    } catch (e: Exception) {&#10;                        println(&quot;onResume error: ${e.message}&quot;)&#10;                        e.printStackTrace()&#10;                    }&#10;                }&#10;                Lifecycle.Event.ON_STOP -&gt; {&#10;                    try {&#10;                        mapView?.onStop()&#10;                    } catch (e: Exception) {&#10;                        println(&quot;onStop error: ${e.message}&quot;)&#10;                        e.printStackTrace()&#10;                    }&#10;                }&#10;                Lifecycle.Event.ON_START -&gt; {&#10;                    try {&#10;                        mapView?.onStart()&#10;                    } catch (e: Exception) {&#10;                        println(&quot;onStart error: ${e.message}&quot;)&#10;                        e.printStackTrace()&#10;                    }&#10;                }&#10;                Lifecycle.Event.ON_DESTROY -&gt; {&#10;                    try {&#10;                        println(&quot;Calling onDestroy on MapView&quot;)&#10;                        symbolManager?.onDestroy()&#10;                        symbolManager = null&#10;                        mapView?.onDestroy()&#10;                        mapView = null&#10;                    } catch (e: Exception) {&#10;                        println(&quot;onDestroy error: ${e.message}&quot;)&#10;                        e.printStackTrace()&#10;                    }&#10;                }&#10;                else -&gt; {}&#10;            }&#10;        }&#10;&#10;        lifecycle.addObserver(observer)&#10;&#10;        onDispose {&#10;            lifecycle.removeObserver(observer)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>