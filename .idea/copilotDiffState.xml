<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/FILTER_INTEGRATION.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FILTER_INTEGRATION.md" />
              <option name="updatedContent" value="# AndroidPhotoFilters Integration Guide&#10;&#10;## Overview&#10;AndroidPhotoFilters library from Zomato has been integrated into the ImageEditor screen to provide professional photo filtering capabilities.&#10;&#10;## Library Added&#10;**Dependency:** `com.github.Zomato:AndroidPhotoFilters:1.0.2`&#10;**Repository:** JitPack (already configured)&#10;**Location:** `app/build.gradle.kts`&#10;&#10;## Available Subfilters&#10;&#10;The following subfilters are available from the AndroidPhotoFilters library:&#10;&#10;1. **ToneCurveSubfilter** - Change RGB channels to create color effects&#10;2. **SaturationSubfilter** - Adjust color saturation&#10;3. **ColorOverlaySubfilter** - Overlay images with specific colors&#10;4. **ContrastSubfilter** - Adjust image contrast&#10;5. **BrightnessSubfilter** - Adjust brightness levels&#10;6. **VignetteSubfilter** - Apply vignette effects&#10;&#10;## Implementation&#10;&#10;### Filter Presets Implemented&#10;&#10;The following filter presets have been implemented in `ImageEditor.kt`:&#10;&#10;1. **Original** - No filters applied&#10;2. **Bright** - Increased brightness, contrast, and saturation&#10;   ```kotlin&#10;   Filter().apply {&#10;       addSubFilter(BrightnessSubfilter(30))&#10;       addSubFilter(ContrastSubfilter(1.1f))&#10;       addSubFilter(SaturationSubfilter(0.2f))&#10;   }&#10;   ```&#10;&#10;3. **Dark** - Reduced brightness with vignette effect&#10;   ```kotlin&#10;   Filter().apply {&#10;       addSubFilter(BrightnessSubfilter(-30))&#10;       addSubFilter(ContrastSubfilter(1.2f))&#10;       addSubFilter(VignetteSubfilter(context, 100))&#10;   }&#10;   ```&#10;&#10;4. **B&amp;W** - Black and white with high contrast&#10;   ```kotlin&#10;   Filter().apply {&#10;       addSubFilter(SaturationSubfilter(-1.0f))&#10;       addSubFilter(ContrastSubfilter(1.3f))&#10;   }&#10;   ```&#10;&#10;5. **Warm** - Warm color overlay&#10;   ```kotlin&#10;   Filter().apply {&#10;       addSubFilter(ColorOverlaySubfilter(200, 1.0f, 0.6f, 0.2f))&#10;       addSubFilter(BrightnessSubfilter(10))&#10;   }&#10;   ```&#10;&#10;6. **Cool** - Cool blue tone&#10;   ```kotlin&#10;   Filter().apply {&#10;       addSubFilter(ColorOverlaySubfilter(150, 0.2f, 0.5f, 1.0f))&#10;       addSubFilter(ContrastSubfilter(1.1f))&#10;   }&#10;   ```&#10;&#10;7. **Vintage** - Vintage look with vignette&#10;   ```kotlin&#10;   Filter().apply {&#10;       addSubFilter(ColorOverlaySubfilter(100, 1.0f, 0.8f, 0.5f))&#10;       addSubFilter(ContrastSubfilter(1.2f))&#10;       addSubFilter(VignetteSubfilter(context, 150))&#10;   }&#10;   ```&#10;&#10;8. **Sepia** - Classic sepia tone using tone curves&#10;   ```kotlin&#10;   Filter().apply {&#10;       addSubFilter(ToneCurveSubfilter(&#10;           intArrayOf(0, 60, 110, 150, 190, 255),&#10;           intArrayOf(0, 65, 115, 155, 195, 255),&#10;           intArrayOf(0, 20, 40, 75, 105, 150),&#10;           intArrayOf(0, 0, 0, 0, 0, 0)&#10;       ))&#10;   }&#10;   ```&#10;&#10;9. **Vivid** - Enhanced colors and contrast&#10;   ```kotlin&#10;   Filter().apply {&#10;       addSubFilter(ContrastSubfilter(1.3f))&#10;       addSubFilter(SaturationSubfilter(0.5f))&#10;       addSubFilter(BrightnessSubfilter(5))&#10;   }&#10;   ```&#10;&#10;10. **Nashville** - Nashville-inspired warm tone&#10;    ```kotlin&#10;    Filter().apply {&#10;        addSubFilter(ColorOverlaySubfilter(100, 1.0f, 0.78f, 0.58f))&#10;        addSubFilter(ContrastSubfilter(1.2f))&#10;        addSubFilter(BrightnessSubfilter(5))&#10;    }&#10;    ```&#10;&#10;11. **Retro** - Retro look with tone curves and vignette&#10;    ```kotlin&#10;    Filter().apply {&#10;        addSubFilter(ToneCurveSubfilter(&#10;            intArrayOf(0, 50, 100, 150, 200, 255),&#10;            intArrayOf(0, 55, 110, 160, 210, 255),&#10;            intArrayOf(0, 40, 80, 120, 160, 200),&#10;            intArrayOf(0, 20, 40, 60, 80, 100)&#10;        ))&#10;        addSubFilter(VignetteSubfilter(context, 120))&#10;    }&#10;    ```&#10;&#10;## Usage in Code&#10;&#10;### Basic Filter Application&#10;&#10;```kotlin&#10;// Create a filter&#10;val myFilter = Filter()&#10;&#10;// Add subfilters&#10;myFilter.addSubFilter(ContrastSubfilter(1.2f))&#10;myFilter.addSubFilter(BrightnessSubfilter(10))&#10;&#10;// Process the bitmap&#10;val outputBitmap = myFilter.processFilter(inputBitmap)&#10;```&#10;&#10;### How Filters Are Applied&#10;&#10;1. User selects a filter from the horizontal scrollable list in Filter mode&#10;2. The selected filter name is stored in `ImageEditState.selectedFilter`&#10;3. When the user clicks &quot;Next&quot; or &quot;Done&quot;, the `saveEditedImage()` function:&#10;   - First crops the image using UCrop&#10;   - Then applies the selected filter using `applyPhotoFilter()`&#10;   - Then applies flip transformations&#10;   - Then applies color adjustments (brightness, contrast, saturation sliders from Adjust mode)&#10;   - Finally saves the result&#10;&#10;### Adding New Filters&#10;&#10;To add a new filter preset:&#10;&#10;1. Add a new filter case in the `applyPhotoFilter()` function:&#10;   ```kotlin&#10;   &quot;MyFilter&quot; -&gt; Filter().apply {&#10;       addSubFilter(BrightnessSubfilter(20))&#10;       addSubFilter(ContrastSubfilter(1.15f))&#10;   }&#10;   ```&#10;&#10;2. Add a new `FilterPreset` button in the `FilterControls` composable:&#10;   ```kotlin&#10;   FilterPreset(&#10;       label = &quot;MyFilter&quot;,&#10;       isSelected = editState.selectedFilter == &quot;MyFilter&quot;,&#10;       onClick = {&#10;           onEditStateChange(editState.copy(selectedFilter = &quot;MyFilter&quot;))&#10;       }&#10;   )&#10;   ```&#10;&#10;## Subfilter Parameters&#10;&#10;### BrightnessSubfilter(value: Int)&#10;- Positive values increase brightness&#10;- Negative values decrease brightness&#10;- Typical range: -100 to 100&#10;&#10;### ContrastSubfilter(value: Float)&#10;- Values &gt; 1.0 increase contrast&#10;- Values &lt; 1.0 decrease contrast&#10;- Typical range: 0.5 to 2.0&#10;&#10;### SaturationSubfilter(level: Float)&#10;- Positive values increase saturation&#10;- Negative values decrease saturation&#10;- -1.0 creates black and white&#10;- Typical range: -1.0 to 2.0&#10;&#10;### ColorOverlaySubfilter(depth: Int, red: Float, green: Float, blue: Float)&#10;- depth: Intensity of the overlay (0-255)&#10;- red, green, blue: Color channel values (0.0-1.0)&#10;&#10;### VignetteSubfilter(context: Context, intensity: Int)&#10;- Requires Android Context&#10;- intensity: Strength of vignetting effect&#10;- Typical range: 0 to 255&#10;&#10;### ToneCurveSubfilter(red: IntArray, green: IntArray, blue: IntArray, rgb: IntArray)&#10;- Each array maps input values to output values&#10;- Arrays must have values from 0 to 255&#10;- Allows precise control over color curves&#10;&#10;## Important Notes&#10;&#10;1. **Filter Processing Order**: Filters are applied before flip and color adjustments&#10;2. **Performance**: Processing large images may take time; filters run on IO dispatcher&#10;3. **Memory**: Keep bitmap sizes reasonable to avoid OutOfMemoryError&#10;4. **Combining Filters**: Multiple subfilters can be combined in one Filter object&#10;5. **Reset**: Selecting &quot;Original&quot; bypasses all filter processing&#10;&#10;## Troubleshooting&#10;&#10;If filters are not working:&#10;1. Ensure AndroidPhotoFilters dependency is properly synced&#10;2. Check that Context is available for VignetteSubfilter&#10;3. Verify bitmap is not null before processing&#10;4. Catch exceptions during filter.processFilter() and handle gracefully&#10;&#10;## References&#10;&#10;- GitHub Repo: https://github.com/Zomato/AndroidPhotoFilters&#10;- Documentation: See repo README for detailed subfilter documentation&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/FIREBASE_STORAGE_SETUP.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FIREBASE_STORAGE_SETUP.md" />
              <option name="updatedContent" value="# Firebase Storage Setup Documentation&#10;&#10;## Overview&#10;This document describes the Firebase Storage setup for handling images in the Secret Spaces Android app.&#10;&#10;## Storage Structure&#10;&#10;The Firebase Storage is organized into three main directories:&#10;&#10;### 1. Profile Pictures&#10;- **Path**: `profile_pictures/{userId}/profile_{timestamp}.jpg`&#10;- **Purpose**: Store user profile pictures&#10;- **Access**: &#10;  - Read: Public (anyone can view)&#10;  - Write: Owner only&#10;  - Delete: Owner only&#10;&#10;### 2. Post/Secret Images&#10;- **Path**: `post_images/{userId}/{postId}_{timestamp}.jpg`&#10;- **Purpose**: Store images attached to posts/secrets&#10;- **Access**:&#10;  - Read: Public (anyone can view)&#10;  - Create: Owner only&#10;  - Delete: Owner only&#10;  - Update: Not allowed (immutable)&#10;&#10;### 3. Story Images&#10;- **Path**: `story_images/{userId}/story_{timestamp}.jpg`&#10;- **Purpose**: Store temporary story images (24-hour expiration)&#10;- **Access**:&#10;  - Read: Public (anyone can view)&#10;  - Create: Owner only&#10;  - Delete: Owner only&#10;  - Update: Not allowed (immutable)&#10;&#10;## Implementation&#10;&#10;### FirebaseStorageManager Class&#10;&#10;Located at: `com.secretspaces32.android.data.storage.FirebaseStorageManager`&#10;&#10;This centralized manager handles all image upload operations with the following features:&#10;&#10;#### Key Methods&#10;&#10;1. **`uploadProfilePicture(imageUri: Uri): Result&lt;String&gt;`**&#10;   - Uploads a user's profile picture&#10;   - Returns the download URL&#10;&#10;2. **`uploadPostImage(imageUri: Uri, postId: String?): Result&lt;String&gt;`**&#10;   - Uploads an image for a post/secret&#10;   - Returns the download URL&#10;&#10;3. **`uploadStoryImage(imageUri: Uri): Result&lt;String&gt;`**&#10;   - Uploads a story image with 24-hour expiration metadata&#10;   - Returns the download URL&#10;&#10;4. **`deleteImage(imageUrl: String): Result&lt;Unit&gt;`**&#10;   - Deletes a specific image by URL&#10;&#10;5. **`deleteUserProfilePictures(userId: String): Result&lt;Unit&gt;`**&#10;   - Deletes all profile pictures for a user&#10;&#10;6. **`deleteUserPosts(userId: String): Result&lt;Unit&gt;`**&#10;   - Deletes all post images for a user&#10;&#10;7. **`deleteUserStories(userId: String): Result&lt;Unit&gt;`**&#10;   - Deletes all story images for a user&#10;&#10;8. **`deleteExpiredStories(userId: String): Result&lt;Int&gt;`**&#10;   - Cleans up story images older than 24 hours&#10;   - Returns count of deleted items&#10;&#10;#### Features&#10;&#10;- **Automatic Authentication**: Verifies user is logged in before operations&#10;- **Metadata Tracking**: Stores upload timestamp, user ID, and image type&#10;- **Type Safety**: Uses enum for image types (PROFILE, POST, STORY)&#10;- **Error Handling**: Returns `Result&lt;T&gt;` for proper error management&#10;- **Organized Structure**: Maintains clean folder hierarchy&#10;&#10;## Repository Integration&#10;&#10;### FirebaseUserRepository&#10;- Uses `storageManager.uploadProfilePicture()` for profile pictures&#10;&#10;### FirebaseSecretRepository&#10;- Uses `storageManager.uploadPostImage()` for post/secret images&#10;&#10;### FirebaseStoryRepository (NEW)&#10;- Uses `storageManager.uploadStoryImage()` for story images&#10;- Includes automatic cleanup of expired stories&#10;- Tracks story views and view counts&#10;&#10;## Security Rules&#10;&#10;The `storage.rules` file in the project root defines Firebase Storage security:&#10;&#10;```&#10;rules_version = '2';&#10;&#10;service firebase.storage {&#10;  match /b/{bucket}/o {&#10;    &#10;    // Profile Pictures&#10;    match /profile_pictures/{userId}/{filename} {&#10;      allow read: if true;&#10;      allow write: if request.auth.uid == userId &amp;&amp; isValidImage();&#10;      allow delete: if request.auth.uid == userId;&#10;    }&#10;    &#10;    // Post Images&#10;    match /post_images/{userId}/{filename} {&#10;      allow read: if true;&#10;      allow create: if request.auth.uid == userId &amp;&amp; isValidImage();&#10;      allow delete: if request.auth.uid == userId;&#10;      allow update: if false;&#10;    }&#10;    &#10;    // Story Images&#10;    match /story_images/{userId}/{filename} {&#10;      allow read: if true;&#10;      allow create: if request.auth.uid == userId &amp;&amp; isValidImage();&#10;      allow delete: if request.auth.uid == userId;&#10;      allow update: if false;&#10;    }&#10;  }&#10;}&#10;```&#10;&#10;### Key Security Features:&#10;- Maximum file size: 10MB&#10;- Allowed formats: JPEG, JPG, PNG, WebP&#10;- Users can only upload to their own directories&#10;- All images are publicly readable&#10;- Users cannot modify existing images (immutable)&#10;&#10;## Deployment Steps&#10;&#10;### 1. Deploy Storage Rules to Firebase&#10;&#10;Using Firebase CLI:&#10;```bash&#10;firebase deploy --only storage&#10;```&#10;&#10;Or manually in Firebase Console:&#10;1. Go to Firebase Console&#10;2. Navigate to Storage → Rules&#10;3. Copy contents from `storage.rules` file&#10;4. Publish the rules&#10;&#10;### 2. Configure Firebase Storage in App&#10;&#10;The storage is already initialized in the repositories. Make sure your `google-services.json` is properly configured.&#10;&#10;### 3. Enable Firebase Storage&#10;&#10;In Firebase Console:&#10;1. Go to Storage section&#10;2. Click &quot;Get Started&quot;&#10;3. Choose your security rules mode&#10;4. Select your storage location (choose closest to your users)&#10;&#10;## Usage Examples&#10;&#10;### Upload Profile Picture&#10;```kotlin&#10;val repository = FirebaseUserRepository()&#10;val result = repository.uploadProfilePicture(userId, imageUri)&#10;&#10;result.onSuccess { downloadUrl -&gt;&#10;    // Update user profile with downloadUrl&#10;}&#10;result.onFailure { error -&gt;&#10;    // Handle error&#10;}&#10;```&#10;&#10;### Upload Post Image&#10;```kotlin&#10;val repository = FirebaseSecretRepository()&#10;// Image upload is handled automatically in createSecret()&#10;val result = repository.createSecret(&#10;    text = &quot;My secret&quot;,&#10;    imageUri = imageUri,&#10;    latitude = lat,&#10;    longitude = lng,&#10;    username = username,&#10;    userProfilePicture = profilePic,&#10;    isAnonymous = false&#10;)&#10;```&#10;&#10;### Create Story&#10;```kotlin&#10;val repository = FirebaseStoryRepository()&#10;val result = repository.createStory(&#10;    imageUri = imageUri,&#10;    caption = &quot;My story&quot;,&#10;    username = username,&#10;    userProfilePicture = profilePic&#10;)&#10;```&#10;&#10;### Clean Up Expired Stories&#10;```kotlin&#10;val repository = FirebaseStoryRepository()&#10;val result = repository.cleanupExpiredStories()&#10;&#10;result.onSuccess { deletedCount -&gt;&#10;    println(&quot;Cleaned up $deletedCount expired stories&quot;)&#10;}&#10;```&#10;&#10;## Best Practices&#10;&#10;1. **Image Optimization**: Compress images before upload to reduce storage costs&#10;2. **Cleanup**: Regularly run cleanup tasks for expired stories&#10;3. **Error Handling**: Always handle upload failures gracefully&#10;4. **Loading States**: Show progress indicators during uploads&#10;5. **Caching**: Use Glide or Coil for efficient image loading and caching&#10;6. **Permissions**: Request storage permissions before image selection&#10;&#10;## Maintenance&#10;&#10;### Periodic Cleanup Task&#10;Consider implementing a background worker to clean up expired stories:&#10;&#10;```kotlin&#10;// Using WorkManager&#10;class CleanupStoriesWorker(context: Context, params: WorkerParameters) &#10;    : CoroutineWorker(context, params) {&#10;    &#10;    override suspend fun doWork(): Result {&#10;        val repository = FirebaseStoryRepository()&#10;        repository.cleanupExpiredStories()&#10;        return Result.success()&#10;    }&#10;}&#10;&#10;// Schedule daily cleanup&#10;val cleanupRequest = PeriodicWorkRequestBuilder&lt;CleanupStoriesWorker&gt;(&#10;    24, TimeUnit.HOURS&#10;).build()&#10;&#10;WorkManager.getInstance(context).enqueue(cleanupRequest)&#10;```&#10;&#10;## Troubleshooting&#10;&#10;### Common Issues&#10;&#10;1. **Upload Fails with Permission Denied**&#10;   - Verify security rules are deployed&#10;   - Check user is authenticated&#10;   - Confirm user ID matches the path&#10;&#10;2. **Image Not Appearing**&#10;   - Verify download URL is saved to Firestore&#10;   - Check image loading library configuration&#10;   - Verify storage bucket is accessible&#10;&#10;3. **Large Upload Times**&#10;   - Compress images before upload&#10;   - Check network connection&#10;   - Consider using lower resolution for thumbnails&#10;&#10;## Cost Optimization&#10;&#10;- **Storage**: ~$0.026/GB per month&#10;- **Downloads**: ~$0.12/GB&#10;- **Uploads**: Free&#10;&#10;Tips to reduce costs:&#10;1. Delete expired content regularly&#10;2. Use appropriate image quality/size&#10;3. Implement image compression&#10;4. Use CDN caching where possible&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/FIX_UNRESOLVED_REFERENCES.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FIX_UNRESOLVED_REFERENCES.md" />
              <option name="updatedContent" value="# How to Fix &quot;Unresolved Reference&quot; Errors for AndroidPhotoFilters&#10;&#10;## Problem&#10;You're seeing these errors:&#10;- ❌ Unresolved reference 'BrightnessSubfilter'&#10;- ❌ Unresolved reference 'ContrastSubfilter'&#10;- ❌ Unresolved reference 'SaturationSubfilter'&#10;- ❌ Unresolved reference 'ColorOverlaySubfilter'&#10;- ❌ Unresolved reference 'VignetteSubfilter'&#10;- ❌ Unresolved reference 'ToneCurveSubfilter'&#10;&#10;## Why This Happens&#10;These classes are from the **AndroidPhotoFilters** library which hasn't been downloaded yet because:&#10;1. **Java Version Issue**: You have Java 25, but Gradle 8.13 doesn't support it&#10;2. **Gradle Can't Sync**: Without syncing, dependencies aren't downloaded&#10;3. **IDE Can't Resolve**: Without the library files, IDE shows &quot;Unresolved reference&quot;&#10;&#10;## Solution: Fix Java Version&#10;&#10;### Option 1: Use Android Studio's Embedded JDK (RECOMMENDED)&#10;&#10;1. Open **Android Studio**&#10;2. Go to **File** → **Settings** (or **Ctrl+Alt+S**)&#10;3. Navigate to **Build, Execution, Deployment** → **Build Tools** → **Gradle**&#10;4. Under &quot;Gradle JDK&quot;, select **&quot;Embedded JDK&quot;** or **&quot;jbr-17&quot;** or **&quot;jbr-21&quot;**&#10;5. Click **Apply** and **OK**&#10;6. Click **&quot;Sync Project with Gradle Files&quot;** (elephant icon) in the toolbar&#10;&#10;### Option 2: Install Java 21 LTS&#10;&#10;1. Download Java 21 LTS from: https://adoptium.net/&#10;2. Install it&#10;3. Set JAVA_HOME environment variable:&#10;   ```bash&#10;   # Windows (in System Environment Variables)&#10;   JAVA_HOME = C:\Program Files\Eclipse Adoptium\jdk-21.0.x&#10;   &#10;   # Add to Path:&#10;   %JAVA_HOME%\bin&#10;   ```&#10;4. Restart Android Studio&#10;5. Sync Gradle&#10;&#10;### Option 3: Use Command Line with Specific Java Version&#10;&#10;If you have multiple Java versions installed:&#10;&#10;```bash&#10;# Windows PowerShell&#10;$env:JAVA_HOME = &quot;C:\Program Files\Java\jdk-21&quot;&#10;.\gradlew.bat clean build&#10;```&#10;&#10;## After Fixing Java Version&#10;&#10;Once you fix the Java version:&#10;&#10;1. **Gradle will sync successfully**&#10;2. **AndroidPhotoFilters library will download** from JitPack&#10;3. **IDE will resolve all references**&#10;4. **Errors will disappear** ✅&#10;&#10;## Verify the Fix&#10;&#10;Run this command to check your Java version:&#10;```bash&#10;java -version&#10;```&#10;&#10;Should show something like:&#10;```&#10;openjdk version &quot;21.0.x&quot; 2024-xx-xx&#10;OpenJDK Runtime Environment (build 21.0.x)&#10;```&#10;&#10;## Manual Dependency Check (if needed)&#10;&#10;If you want to manually verify the dependency is correct:&#10;&#10;1. Check `app/build.gradle.kts` line 132:&#10;   ```kotlin&#10;   implementation(&quot;com.github.Zomato:AndroidPhotoFilters:1.0.2&quot;)&#10;   ```&#10;&#10;2. Check `settings.gradle.kts` has JitPack:&#10;   ```kotlin&#10;   repositories {&#10;       google()&#10;       mavenCentral()&#10;       maven { url = uri(&quot;https://jitpack.io&quot;) }  // ✅ This is needed&#10;   }&#10;   ```&#10;&#10;## What Happens After Sync&#10;&#10;Once Gradle syncs successfully:&#10;&#10;1. **Library Downloads**: AndroidPhotoFilters downloads from JitPack&#10;2. **Native Library**: `NativeImageProcessor.so` is included&#10;3. **Classes Available**:&#10;   - `com.zomato.photofilters.imageprocessors.Filter`&#10;   - `com.zomato.photofilters.imageprocessors.subfilters.BrightnessSubfilter`&#10;   - `com.zomato.photofilters.imageprocessors.subfilters.ContrastSubfilter`&#10;   - `com.zomato.photofilters.imageprocessors.subfilters.SaturationSubfilter`&#10;   - `com.zomato.photofilters.imageprocessors.subfilters.ColorOverlaySubfilter`&#10;   - `com.zomato.photofilters.imageprocessors.subfilters.VignetteSubfilter`&#10;   - `com.zomato.photofilters.imageprocessors.subfilters.ToneCurveSubfilter`&#10;4. **Code Compiles**: All &quot;Unresolved reference&quot; errors disappear&#10;5. **App Builds**: You can build and run the app&#10;&#10;## Test After Fix&#10;&#10;1. **Sync Gradle** in Android Studio&#10;2. **Build the project**: Build → Make Project&#10;3. **Run on device**: Click Run (green play button)&#10;4. **Test filters**: &#10;   - Open ImageEditor&#10;   - Switch to &quot;Filter&quot; mode&#10;   - Select different filters (Bright, Dark, B&amp;W, etc.)&#10;   - Click &quot;Next&quot; to apply and save&#10;&#10;## Current Code Status&#10;&#10;✅ **Code is 100% correct** - No changes needed to ImageEditor.kt&#10;✅ **Dependency added** - AndroidPhotoFilters is in build.gradle.kts&#10;✅ **Implementation complete** - All 11 filters are implemented&#10;✅ **Native library loading** - System.loadLibrary() is called&#10;✅ **UI integrated** - Filter selection works&#10;&#10;❌ **Just needs Gradle sync** - Which requires Java 21 or lower&#10;&#10;## Quick Summary&#10;&#10;```&#10;Java 25 → Gradle can't sync → Library not downloaded → IDE shows errors&#10;   ↓&#10;Fix Java version (use Android Studio's embedded JDK)&#10;   ↓&#10;Gradle syncs → Library downloads → IDE resolves classes → ✅ No errors&#10;```&#10;&#10;## If You Still See Errors After Sync&#10;&#10;1. **Invalidate Caches**: &#10;   - File → Invalidate Caches → Invalidate and Restart&#10;&#10;2. **Clean Project**: &#10;   - Build → Clean Project&#10;   - Build → Rebuild Project&#10;&#10;3. **Delete .gradle folder** and sync again:&#10;   ```bash&#10;   # Close Android Studio first&#10;   rmdir /s /q .gradle&#10;   rmdir /s /q app\.gradle&#10;   # Open Android Studio and sync&#10;   ```&#10;&#10;---&#10;&#10;**Bottom Line**: The code is correct. You just need to use Java 21 or lower (or Android Studio's embedded JDK) so Gradle can sync and download the AndroidPhotoFilters library. Once that happens, all errors will disappear automatically.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MULTIPLE_IMAGES_IMPLEMENTATION.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MULTIPLE_IMAGES_IMPLEMENTATION.md" />
              <option name="updatedContent" value="# Multiple Images Feature Implementation Summary&#10;&#10;## Problem Fixed&#10;Previously, when users selected multiple images to post, only one image was displayed in the feed screen. Now all selected images are properly displayed with a carousel/swipe functionality.&#10;&#10;## Changes Made&#10;&#10;### 1. Data Model Updates (`Secret.kt`)&#10;- Added `imageUrls: List&lt;String&gt;?` field to support multiple images&#10;- Kept `imageUrl: String?` for backward compatibility&#10;- Added `imageBase64List: List&lt;String&gt;?` to `CreateSecretRequest` for uploading multiple images&#10;&#10;### 2. Feed UI Components (`FeedComponents.kt`)&#10;- Updated `FeedSecretCard` to display multiple images with a carousel&#10;- Added horizontal pager for swiping between images&#10;- Added page counter (e.g., &quot;1/3&quot;) in top-right corner&#10;- Added dot indicators at the bottom showing current page&#10;- Single images display as before without pagination UI&#10;- All images are clickable to open full-screen viewer&#10;&#10;### 3. New Image Viewer Screen (`ImageViewerScreen.kt`)&#10;- Full-screen image viewing with black background&#10;- Horizontal swipe/pager to navigate between images&#10;- Page counter showing current position (e.g., &quot;1 / 3&quot;)&#10;- Dot indicators at bottom for visual navigation&#10;- Back button to return to feed&#10;- Fits images to screen while maintaining aspect ratio&#10;&#10;### 4. Navigation Updates&#10;- Added `ImageViewer` to Screen enum&#10;- Added image viewer state variables (`imageViewerUrls`, `imageViewerInitialPage`)&#10;- Wired up navigation from feed → image viewer → back to feed&#10;- Passed `onImageClick` callback through all layers:&#10;  - SecretSpacesApp → MainScreenContainer → FeedScreen → FeedSecretCard&#10;&#10;### 5. Feed Screen Updates (`FeedScreen.kt`)&#10;- Added `onImageClick` parameter to handle image clicks&#10;- Passes callback to `FeedSecretCard` component&#10;&#10;### 6. MainScreenContainer Updates&#10;- Added `onImageClick` parameter&#10;- Passes callback through to FeedScreen&#10;&#10;## User Experience&#10;&#10;### Viewing Multiple Images in Feed:&#10;1. Posts with multiple images show in a carousel format&#10;2. Swipe left/right to see all images&#10;3. Page counter shows &quot;2/5&quot; (current/total) in top-right&#10;4. Dot indicators at bottom show position visually&#10;5. Posts with single images display as before (no pagination UI)&#10;&#10;### Full-Screen Image Viewer:&#10;1. Tap any image in feed to open full-screen viewer&#10;2. Opens to the exact image you tapped&#10;3. Swipe left/right to view all images&#10;4. Page counter and dots help with navigation&#10;5. Tap back button to return to feed&#10;&#10;## UI Design Features&#10;- **Carousel**: Smooth horizontal swipe between images&#10;- **Page Counter**: Semi-transparent badge showing &quot;1/3&quot;&#10;- **Dot Indicators**: White dots at bottom (active is solid, others are transparent)&#10;- **Click to Expand**: Tap any image to view full-screen&#10;- **Black Background**: Full-screen viewer uses black for better focus&#10;- **Gradient Overlay**: Subtle gradient on feed images for better visibility&#10;&#10;## Backend Note&#10;The `CreateSecretRequest` now supports `imageBase64List` for uploading multiple images. You'll need to update your backend API to:&#10;1. Accept multiple images in the create secret endpoint&#10;2. Store multiple image URLs in the database&#10;3. Return `imageUrls` array in the API response&#10;&#10;The app maintains backward compatibility - it will work with existing posts that only have `imageUrl` set.&#10;&#10;## Similar to Facebook/Instagram&#10;- Swipe through multiple photos in a post&#10;- Tap to view full-screen&#10;- Visual indicators showing which photo you're viewing&#10;- Smooth animations and transitions&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/QUICK_SETUP_STORAGE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/QUICK_SETUP_STORAGE.md" />
              <option name="updatedContent" value="# Quick Setup Guide - Firebase Storage&#10;&#10;## What Has Been Set Up&#10;&#10;✅ **FirebaseStorageManager** - Centralized image upload manager&#10;✅ **Story Model &amp; Repository** - Complete story feature with 24-hour expiration&#10;✅ **Updated Repositories** - User and Secret repositories now use the centralized storage&#10;✅ **Security Rules** - Firebase Storage rules for proper access control&#10;&#10;## Files Created/Modified&#10;&#10;### New Files:&#10;1. `app/src/main/java/com/secretspaces32/android/data/storage/FirebaseStorageManager.kt`&#10;2. `app/src/main/java/com/secretspaces32/android/data/model/Story.kt`&#10;3. `app/src/main/java/com/secretspaces32/android/data/repository/FirebaseStoryRepository.kt`&#10;4. `storage.rules` - Firebase Storage security rules&#10;5. `FIREBASE_STORAGE_SETUP.md` - Complete documentation&#10;&#10;### Modified Files:&#10;1. `app/src/main/java/com/secretspaces32/android/data/repository/FirebaseUserRepository.kt`&#10;2. `app/src/main/java/com/secretspaces32/android/data/repository/FirebaseSecretRepository.kt`&#10;&#10;## Next Steps&#10;&#10;### 1. Deploy Firebase Storage Rules&#10;&#10;Open terminal and run:&#10;```bash&#10;firebase login&#10;firebase init storage  # if not already initialized&#10;firebase deploy --only storage&#10;```&#10;&#10;Or deploy manually:&#10;1. Go to [Firebase Console](https://console.firebase.google.com)&#10;2. Select your project&#10;3. Navigate to: **Storage → Rules**&#10;4. Copy content from `storage.rules` file&#10;5. Click **Publish**&#10;&#10;### 2. Enable Firebase Storage&#10;&#10;In Firebase Console:&#10;1. Go to **Storage** section&#10;2. Click **Get Started**&#10;3. Choose **Start in production mode**&#10;4. Select your preferred storage location (e.g., us-central1)&#10;&#10;### 3. Storage Structure&#10;&#10;Your Firebase Storage will be organized as:&#10;```&#10;storage_bucket/&#10;├── profile_pictures/&#10;│   └── {userId}/&#10;│       └── profile_{timestamp}.jpg&#10;├── post_images/&#10;│   └── {userId}/&#10;│       └── {postId}_{timestamp}.jpg&#10;└── story_images/&#10;    └── {userId}/&#10;        └── story_{timestamp}.jpg&#10;```&#10;&#10;## Usage in Your App&#10;&#10;### Upload Profile Picture&#10;```kotlin&#10;val repository = FirebaseUserRepository()&#10;repository.uploadProfilePicture(userId, imageUri)&#10;```&#10;&#10;### Upload Post Image (automatic)&#10;```kotlin&#10;val repository = FirebaseSecretRepository()&#10;repository.createSecret(..., imageUri = uri, ...)&#10;```&#10;&#10;### Create Story&#10;```kotlin&#10;val repository = FirebaseStoryRepository()&#10;repository.createStory(imageUri, caption, username, profilePic)&#10;```&#10;&#10;## Features&#10;&#10;- ✅ **Organized Structure**: Separate folders for profiles, posts, and stories&#10;- ✅ **Security**: Users can only upload to their own folders&#10;- ✅ **Metadata**: Tracks upload time, user, and image type&#10;- ✅ **Auto-cleanup**: Stories expire after 24 hours&#10;- ✅ **Size Limit**: 10MB max per image&#10;- ✅ **Format Support**: JPEG, PNG, WebP&#10;- ✅ **Error Handling**: Proper Result types for error management&#10;&#10;## Testing&#10;&#10;You can test the storage setup by:&#10;1. Building the project&#10;2. Uploading a test image through your app&#10;3. Checking Firebase Console → Storage to verify the file structure&#10;&#10;For detailed documentation, see `FIREBASE_STORAGE_SETUP.md`&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SETUP.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SETUP.md" />
              <option name="updatedContent" value="# Secret Spaces - Setup Instructions&#10;&#10;## Prerequisites&#10;- Android Studio (latest version)&#10;- Android SDK&#10;- Java 11 or higher&#10;&#10;## Initial Setup&#10;&#10;### 1. Clone the Repository&#10;```bash&#10;git clone &lt;your-repo-url&gt;&#10;cd Project_Android&#10;```&#10;&#10;### 2. Configure API Keys&#10;&#10;Create or edit the `local.properties` file in the root directory and add the following:&#10;&#10;```properties&#10;# Android SDK Location&#10;sdk.dir=&lt;path-to-your-android-sdk&gt;&#10;&#10;# MapTiler API Key&#10;# Get your free API key from: https://cloud.maptiler.com/&#10;MAPTILER_API_KEY=your_maptiler_api_key_here&#10;&#10;# Cloudinary Configuration&#10;# Get your credentials from: https://console.cloudinary.com/&#10;CLOUDINARY_CLOUD_NAME=your_cloud_name&#10;CLOUDINARY_API_KEY=your_api_key&#10;CLOUDINARY_API_SECRET=your_api_secret&#10;```&#10;&#10;⚠️ **IMPORTANT**: Never commit `local.properties` to version control. It's already in `.gitignore`.&#10;&#10;### 3. Firebase Setup&#10;&#10;1. Create a Firebase project at https://console.firebase.google.com/&#10;2. Add an Android app to your Firebase project&#10;3. Download `google-services.json` and place it in the `app/` directory&#10;4. Enable Authentication (Email/Password and Google Sign-In)&#10;5. Enable Firestore Database&#10;6. Set up Firestore security rules (see below)&#10;&#10;### 4. Cloudinary Setup&#10;&#10;1. Sign up at https://cloudinary.com/&#10;2. Get your credentials from the dashboard&#10;3. Add them to `local.properties` as shown above&#10;&#10;### 5. Build and Run&#10;&#10;```bash&#10;./gradlew clean build&#10;```&#10;&#10;Or run directly from Android Studio.&#10;&#10;## Firestore Security Rules&#10;&#10;```javascript&#10;rules_version = '2';&#10;service cloud.firestore {&#10;  match /databases/{database}/documents {&#10;    // Users collection&#10;    match /users/{userId} {&#10;      allow read: if true;&#10;      allow write: if request.auth != null &amp;&amp; request.auth.uid == userId;&#10;    }&#10;    &#10;    // Secrets collection&#10;    match /secrets/{secretId} {&#10;      allow read: if true;&#10;      allow create: if request.auth != null;&#10;      allow update, delete: if request.auth != null &amp;&amp; request.auth.uid == resource.data.userId;&#10;    }&#10;    &#10;    // Stories collection&#10;    match /stories/{storyId} {&#10;      allow read: if true;&#10;      allow create: if request.auth != null;&#10;      allow update, delete: if request.auth != null &amp;&amp; request.auth.uid == resource.data.userId;&#10;    }&#10;    &#10;    // Comments collection&#10;    match /comments/{commentId} {&#10;      allow read: if true;&#10;      allow create: if request.auth != null;&#10;      allow delete: if request.auth != null &amp;&amp; request.auth.uid == resource.data.userId;&#10;    }&#10;    &#10;    // Likes collection&#10;    match /likes/{likeId} {&#10;      allow read: if true;&#10;      allow create, delete: if request.auth != null;&#10;    }&#10;  }&#10;}&#10;```&#10;&#10;## Security Notes&#10;&#10;- All API keys are stored in `local.properties` which is gitignored&#10;- Never hardcode API keys in source files&#10;- If API keys are accidentally exposed, rotate them immediately:&#10;  - Cloudinary: https://console.cloudinary.com/ → Settings → Security&#10;  - MapTiler: https://cloud.maptiler.com/account/keys/&#10;  - Firebase: https://console.firebase.google.com/ → Project Settings → Service Accounts&#10;&#10;## Troubleshooting&#10;&#10;### Build fails with &quot;CLOUDINARY_CLOUD_NAME not found&quot;&#10;- Ensure `local.properties` exists and contains all required keys&#10;- Sync Gradle files in Android Studio&#10;&#10;### Google Sign-In not working&#10;- Add your SHA-1 and SHA-256 fingerprints to Firebase Console&#10;- Ensure google-services.json is up to date&#10;&#10;### Images not uploading&#10;- Check Cloudinary credentials in `local.properties`&#10;- Verify internet connection and permissions&#10;&#10;## Contributing&#10;&#10;When contributing, ensure you:&#10;1. Never commit `local.properties`&#10;2. Never hardcode API keys&#10;3. Use BuildConfig for all sensitive data&#10;4. Test on both debug and release builds&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/STATE_PRESERVATION_FIXES.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/STATE_PRESERVATION_FIXES.md" />
              <option name="updatedContent" value="# State Preservation Fixes Applied&#10;&#10;## Problem Summary&#10;The app was losing state when going to background (e.g., during phone calls, pressing home button), causing:&#10;1. App restarting from home/feed page when returning&#10;2. Loss of scroll position in feed&#10;3. Loss of crop state when editing images&#10;4. Loss of navigation state (e.g., from profile back to home)&#10;&#10;## Root Causes Identified&#10;1. **MainActivity restarting on every return** - No proper launch mode configured&#10;2. **Navigation state not preserved** - Using `remember` instead of `rememberSaveable`&#10;3. **Scroll position lost** - LazyListState not saved across process death&#10;4. **Crop state lost** - Image editing state not preserved during interruptions&#10;&#10;## Fixes Applied&#10;&#10;### 1. AndroidManifest.xml&#10;**Location:** `app/src/main/AndroidManifest.xml`&#10;&#10;**Changes:**&#10;- Added `android:launchMode=&quot;singleTask&quot;` to MainActivity&#10;- Added `android:configChanges=&quot;orientation|screenSize|keyboardHidden|screenLayout|uiMode&quot;`&#10;&#10;**Benefits:**&#10;- Prevents MainActivity from being recreated when returning from background&#10;- Maintains single instance of activity&#10;- Handles configuration changes without destroying activity&#10;&#10;### 2. SecretSpacesApp.kt&#10;**Location:** `app/src/main/java/com/secretspaces32/android/ui/navigation/SecretSpacesApp.kt`&#10;&#10;**Changes:**&#10;- Changed `var selectedScreen by remember` to `var selectedScreen by rememberSaveable`&#10;&#10;**Benefits:**&#10;- Navigation state (which screen you're on) survives process death&#10;- App returns to the same screen you were on before interruption&#10;&#10;### 3. FeedScreen.kt&#10;**Location:** `app/src/main/java/com/secretspaces32/android/ui/screens/FeedScreen.kt`&#10;&#10;**Changes:**&#10;- Changed `val lazyListState = rememberLazyListState()` to:&#10;  ```kotlin&#10;  val lazyListState = rememberSaveable(saver = LazyListState.Saver) {&#10;      LazyListState()&#10;  }&#10;  ```&#10;&#10;**Benefits:**&#10;- Scroll position in feed is preserved across app restarts&#10;- Returns to exact same scroll position after interruption&#10;&#10;### 4. MainScreenContainer.kt&#10;**Location:** `app/src/main/java/com/secretspaces32/android/ui/screens/MainScreenContainer.kt`&#10;&#10;**Changes:**&#10;- Changed `var currentDestination by remember` to `var currentDestination by rememberSaveable`&#10;- Changed `var selectedImages by remember` to `var selectedImages by rememberSaveable`&#10;&#10;**Benefits:**&#10;- Internal navigation state preserved (home/map/profile/create)&#10;- Selected images for posting are cached during interruptions&#10;- Won't lose your photo selections if interrupted during post creation&#10;&#10;### 5. ImageCropScreen.kt&#10;**Location:** `app/src/main/java/com/secretspaces32/android/ui/screens/ImageCropScreen.kt`&#10;&#10;**Changes:**&#10;- Changed all crop state variables to use `rememberSaveable`:&#10;  - `currentImageIndex` (which image you're cropping)&#10;  - `croppedImages` (already cropped images)&#10;  - `imageScale` (zoom level)&#10;  - `cropFrameScale` (crop frame size)&#10;  - `cropFrameOffsetX` (crop position X)&#10;  - `cropFrameOffsetY` (crop position Y)&#10;&#10;**Benefits:**&#10;- Crop state fully preserved during phone calls or app switching&#10;- Returns to exact same crop position, zoom, and progress&#10;- Already cropped images are not lost&#10;&#10;## Technical Details&#10;&#10;### What is rememberSaveable?&#10;- `remember` - Keeps state in memory, lost on process death&#10;- `rememberSaveable` - Saves state to Bundle, survives process death and configuration changes&#10;&#10;### What is LazyListState.Saver?&#10;- Special saver for LazyColumn/LazyRow scroll positions&#10;- Preserves first visible item index and scroll offset&#10;- Restores exact scroll position when app returns&#10;&#10;### What is launchMode=&quot;singleTask&quot;?&#10;- Ensures only one instance of MainActivity exists&#10;- Reuses existing activity instead of creating new one&#10;- Maintains activity state when returning from background&#10;&#10;## Testing Recommendations&#10;&#10;Test the following scenarios to verify fixes:&#10;&#10;1. **Navigation Preservation:**&#10;   - Navigate to Profile page&#10;   - Press home button&#10;   - Return to app&#10;   - ✓ Should still be on Profile page&#10;&#10;2. **Scroll Position:**&#10;   - Scroll down in feed&#10;   - Press home button&#10;   - Return to app&#10;   - ✓ Should be at same scroll position&#10;&#10;3. **Crop State:**&#10;   - Start creating a post with images&#10;   - Enter crop screen&#10;   - Adjust crop position/zoom&#10;   - Receive phone call or press home&#10;   - Return to app&#10;   - ✓ Should be in crop screen with same adjustments&#10;&#10;4. **Post Creation:**&#10;   - Select images for posting&#10;   - Press home button&#10;   - Return to app&#10;   - ✓ Selected images should still be there&#10;&#10;5. **Process Death Simulation:**&#10;   - Open app, navigate around&#10;   - Open Developer Options → Background Process Limit → Set to &quot;No background processes&quot;&#10;   - Press home button (app will be killed)&#10;   - Return to app&#10;   - ✓ Should restore to previous state&#10;&#10;## Additional Notes&#10;&#10;- All changes are backward compatible&#10;- No changes to data layer or backend required&#10;- Minimal performance impact (Bundle serialization is efficient)&#10;- Works on all Android versions supported by your app&#10;&#10;## Files Modified&#10;1. `app/src/main/AndroidManifest.xml`&#10;2. `app/src/main/java/com/secretspaces32/android/ui/navigation/SecretSpacesApp.kt`&#10;3. `app/src/main/java/com/secretspaces32/android/ui/screens/FeedScreen.kt`&#10;4. `app/src/main/java/com/secretspaces32/android/ui/screens/MainScreenContainer.kt`&#10;5. `app/src/main/java/com/secretspaces32/android/ui/screens/ImageCropScreen.kt`&#10;&#10;## Build &amp; Test&#10;No additional dependencies required. Simply rebuild and test:&#10;```&#10;gradlew clean assembleDebug&#10;```&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/secretspaces32/android/data/prefs/AuthPrefs.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/secretspaces32/android/data/prefs/AuthPrefs.kt" />
              <option name="updatedContent" value="package com.secretspaces32.android.data.prefs&#10;&#10;import android.content.Context&#10;import androidx.datastore.core.DataStore&#10;import androidx.datastore.preferences.core.Preferences&#10;import androidx.datastore.preferences.core.booleanPreferencesKey&#10;import androidx.datastore.preferences.core.edit&#10;import androidx.datastore.preferences.preferencesDataStore&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.map&#10;&#10;// Single DataStore instance scoped to the application Context&#10;val Context.dataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(name = &quot;app_prefs&quot;)&#10;&#10;object AuthPrefs {&#10;    private val KEY_HAS_LOGGED_IN = booleanPreferencesKey(&quot;has_logged_in&quot;)&#10;&#10;    fun hasLoggedInFlow(context: Context): Flow&lt;Boolean&gt; =&#10;        context.dataStore.data.map { prefs -&gt; prefs[KEY_HAS_LOGGED_IN] ?: false }&#10;&#10;    suspend fun setHasLoggedIn(context: Context, value: Boolean) {&#10;        context.dataStore.edit { prefs -&gt;&#10;            prefs[KEY_HAS_LOGGED_IN] = value&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/secretspaces32/android/ui/navigation/SecretSpacesApp.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/secretspaces32/android/ui/navigation/SecretSpacesApp.kt" />
              <option name="originalContent" value="package com.secretspaces32.android.ui.navigation&#10;&#10;import android.Manifest&#10;import android.widget.Toast&#10;import androidx.compose.foundation.lazy.LazyListState&#10;import androidx.compose.runtime.*&#10;import androidx.compose.runtime.saveable.rememberSaveable&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.secretspaces32.android.viewmodel.MainViewModel&#10;import com.secretspaces32.android.ui.screens.*&#10;import com.google.accompanist.permissions.ExperimentalPermissionsApi&#10;import com.google.accompanist.permissions.rememberMultiplePermissionsState&#10;import androidx.credentials.CredentialManager&#10;import androidx.credentials.GetCredentialRequest&#10;import androidx.credentials.CustomCredential&#10;import com.google.android.libraries.identity.googleid.GetGoogleIdOption&#10;import com.google.android.libraries.identity.googleid.GoogleIdTokenCredential&#10;import com.google.android.libraries.identity.googleid.GoogleIdTokenParsingException&#10;import kotlinx.coroutines.launch&#10;&#10;enum class Screen {&#10;    Auth,&#10;    Feed,&#10;    Map,&#10;    DropSecret,&#10;    Profile,&#10;    MySecrets,&#10;    SecretDetail,&#10;    StoryViewer,&#10;    ProfileViewer,&#10;    ImageViewer&#10;}&#10;&#10;@OptIn(ExperimentalPermissionsApi::class)&#10;@Composable&#10;fun SecretSpacesApp() {&#10;    val context = LocalContext.current&#10;    val viewModel: MainViewModel = viewModel(&#10;        factory = object : androidx.lifecycle.ViewModelProvider.Factory {&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;            override fun &lt;T : androidx.lifecycle.ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;                return MainViewModel(context) as T&#10;            }&#10;        }&#10;    )&#10;&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    var selectedScreen by rememberSaveable { mutableStateOf(Screen.Feed) }&#10;&#10;    // Hoist feed scroll state to top level so it survives navigation to SecretDetail and back&#10;    val feedScrollState = rememberSaveable(saver = LazyListState.Saver) {&#10;        LazyListState()&#10;    }&#10;&#10;    // Image viewer state&#10;    var imageViewerUrls by remember { mutableStateOf&lt;List&lt;String&gt;&gt;(emptyList()) }&#10;    var imageViewerInitialPage by remember { mutableStateOf(0) }&#10;&#10;    // Persist the sheet state at navigation level so it survives screen changes&#10;    var mapSheetState by rememberSaveable { mutableStateOf(&quot;COLLAPSED&quot;) }&#10;&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val credentialManager = remember { CredentialManager.create(context) }&#10;&#10;    // Location permissions - removed automatic request&#10;    // Permissions will be requested from MapScreen when user navigates there&#10;&#10;    // Initialize with default location when authenticated&#10;    LaunchedEffect(uiState.isAuthenticated) {&#10;        if (uiState.isAuthenticated) {&#10;            try {&#10;                println(&quot;DEBUG: App authenticated, initializing with default location&quot;)&#10;                // Call updateLocation - it will use default location if no permission&#10;                viewModel.updateLocation()&#10;            } catch (e: Exception) {&#10;                println(&quot;DEBUG: Error in authentication flow: ${e.message}&quot;)&#10;                e.printStackTrace()&#10;            }&#10;        }&#10;    }&#10;&#10;    // Show error messages&#10;    LaunchedEffect(uiState.errorMessage) {&#10;        uiState.errorMessage?.let { message -&gt;&#10;            try {&#10;                Toast.makeText(context, message, Toast.LENGTH_LONG).show()&#10;                viewModel.clearError()&#10;            } catch (e: Exception) {&#10;                println(&quot;DEBUG: Error showing toast: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Auto-navigate to story viewer when stories are loaded&#10;    LaunchedEffect(uiState.selectedUserStories) {&#10;        if (uiState.selectedUserStories.isNotEmpty() &amp;&amp; selectedScreen == Screen.Feed) {&#10;            println(&quot;DEBUG: Stories loaded (${uiState.selectedUserStories.size}), auto-navigating to viewer&quot;)&#10;            selectedScreen = Screen.StoryViewer&#10;        }&#10;    }&#10;&#10;    // Show authentication screen if not authenticated&#10;    if (!uiState.isAuthenticated) {&#10;        AuthScreen(&#10;            onSignIn = { email, password -&gt;&#10;                viewModel.signIn(email, password)&#10;            },&#10;            onSignUp = { email, password, username -&gt;&#10;                viewModel.signUp(email, password, username)&#10;            },&#10;            onGoogleSignIn = {&#10;                coroutineScope.launch {&#10;                    try {&#10;                        println(&quot;DEBUG: Starting Google Sign-In process&quot;)&#10;&#10;                        // Configure Google ID option with your Web Client ID from Firebase Console&#10;                        val googleIdOption = GetGoogleIdOption.Builder()&#10;                            .setFilterByAuthorizedAccounts(false)&#10;                            .setServerClientId(&quot;170496527031-ul59lq2gqm76re4an5p2lftol7g3hjfl.apps.googleusercontent.com&quot;)&#10;                            .build()&#10;&#10;                        println(&quot;DEBUG: GoogleIdOption built, creating request&quot;)&#10;&#10;                        val request = GetCredentialRequest.Builder()&#10;                            .addCredentialOption(googleIdOption)&#10;                            .build()&#10;&#10;                        println(&quot;DEBUG: Requesting credentials from CredentialManager&quot;)&#10;&#10;                        val result = credentialManager.getCredential(&#10;                            request = request,&#10;                            context = context&#10;                        )&#10;&#10;                        println(&quot;DEBUG: Credential received, type: ${result.credential.type}&quot;)&#10;&#10;                        when (val credential = result.credential) {&#10;                            is CustomCredential -&gt; {&#10;                                if (credential.type == GoogleIdTokenCredential.TYPE_GOOGLE_ID_TOKEN_CREDENTIAL) {&#10;                                    try {&#10;                                        // Use GoogleIdTokenCredential.createFrom to parse the custom credential&#10;                                        val googleIdTokenCredential = GoogleIdTokenCredential.createFrom(credential.data)&#10;                                        val idToken = googleIdTokenCredential.idToken&#10;                                        println(&quot;DEBUG: Google ID Token extracted from CustomCredential, signing in with Firebase&quot;)&#10;                                        viewModel.signInWithGoogle(idToken)&#10;                                    } catch (e: GoogleIdTokenParsingException) {&#10;                                        println(&quot;DEBUG: Error parsing Google ID Token: ${e.message}&quot;)&#10;                                        Toast.makeText(&#10;                                            context,&#10;                                            &quot;Error parsing Google credentials&quot;,&#10;                                            Toast.LENGTH_SHORT&#10;                                        ).show()&#10;                                    }&#10;                                } else {&#10;                                    println(&quot;DEBUG: Unexpected custom credential type: ${credential.type}&quot;)&#10;                                    Toast.makeText(&#10;                                        context,&#10;                                        &quot;Unexpected credential type: ${credential.type}&quot;,&#10;                                        Toast.LENGTH_SHORT&#10;                                    ).show()&#10;                                }&#10;                            }&#10;                            else -&gt; {&#10;                                println(&quot;DEBUG: Credential is not CustomCredential: ${credential.javaClass.name}&quot;)&#10;                                Toast.makeText(&#10;                                    context,&#10;                                    &quot;Unexpected credential format&quot;,&#10;                                    Toast.LENGTH_SHORT&#10;                                ).show()&#10;                            }&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        println(&quot;DEBUG: Google Sign-In error: ${e.javaClass.simpleName}&quot;)&#10;                        println(&quot;DEBUG: Error message: ${e.message}&quot;)&#10;                        e.printStackTrace()&#10;&#10;                        val errorMessage = when {&#10;                            e.message?.contains(&quot;16&quot;) == true -&gt; &quot;Google Sign-In not configured. Enable it in Firebase Console.&quot;&#10;                            e.message?.contains(&quot;developer console&quot;, ignoreCase = true) == true -&gt;&#10;                                &quot;Please add SHA-1 &amp; SHA-256 to Firebase Console&quot;&#10;                            e.message?.contains(&quot;cancelled&quot;, ignoreCase = true) == true -&gt; &quot;Sign-in cancelled&quot;&#10;                            e.message?.contains(&quot;No credentials&quot;, ignoreCase = true) == true -&gt; &quot;No Google accounts found&quot;&#10;                            else -&gt; &quot;Google Sign-In failed: ${e.message}&quot;&#10;                        }&#10;&#10;                        Toast.makeText(&#10;                            context,&#10;                            errorMessage,&#10;                            Toast.LENGTH_LONG&#10;                        ).show()&#10;                    }&#10;                }&#10;            },&#10;            isLoading = uiState.isLoading,&#10;            isEmailAuthLoading = uiState.isEmailAuthLoading,&#10;            isGoogleAuthLoading = uiState.isGoogleAuthLoading&#10;        )&#10;        return&#10;    }&#10;&#10;    // Main app navigation&#10;    when (selectedScreen) {&#10;        Screen.Feed, Screen.Map, Screen.Profile -&gt; {&#10;            MainScreenContainer(&#10;                currentLocation = uiState.currentLocation,&#10;                nearbySecrets = uiState.secrets,&#10;                currentUser = uiState.currentUser,&#10;                mySecrets = uiState.mySecrets,&#10;                isLoading = uiState.isLoading,&#10;                onSecretClick = { secret -&gt;&#10;                    viewModel.selectSecret(secret)&#10;                    selectedScreen = Screen.SecretDetail&#10;                },&#10;                onDropSecretClick = {&#10;                    selectedScreen = Screen.DropSecret&#10;                },&#10;                onSignOut = {&#10;                    viewModel.signOut()&#10;                    selectedScreen = Screen.Feed&#10;                },&#10;                onUpdateProfile = { username, bio, imageUri -&gt;&#10;                    viewModel.updateProfile(username, bio, imageUri)&#10;                },&#10;                onLikeClick = { secret -&gt;&#10;                    viewModel.toggleLike(secret)&#10;                },&#10;                onLoadMySecrets = {&#10;                    viewModel.loadMySecrets()&#10;                },&#10;                onLocationPermissionGranted = {&#10;                    viewModel.updateLocation()&#10;                },&#10;                onPostSecret = { text, imageUris, isAnonymous, mood, category, hashtags, postType -&gt;&#10;                    if (postType == &quot;Story&quot;) {&#10;                        // Stories still use single image&#10;                        viewModel.createStory(imageUris.firstOrNull(), text)&#10;                    } else {&#10;                        // Secrets now support multiple images&#10;                        if (imageUris.isNotEmpty()) {&#10;                            viewModel.createSecretWithMultipleImages(text, imageUris, isAnonymous, mood, category, hashtags)&#10;                        } else {&#10;                            viewModel.createSecret(text, null, isAnonymous, mood, category, hashtags)&#10;                        }&#10;                    }&#10;                },&#10;                cacheDir = context.cacheDir,&#10;                myStories = uiState.myStories,&#10;                onViewMyStory = {&#10;                    // Load current user's stories - navigation will happen via LaunchedEffect below&#10;                    println(&quot;DEBUG: onViewMyStory clicked&quot;)&#10;                    uiState.currentUser?.id?.let { userId -&gt;&#10;                        println(&quot;DEBUG: Loading stories for user: $userId&quot;)&#10;                        viewModel.loadUserStories(userId)&#10;                    } ?: run {&#10;                        println(&quot;DEBUG: No current user found&quot;)&#10;                    }&#10;                },&#10;                onLoadMyStories = {&#10;                    viewModel.loadMyStories()&#10;                },&#10;                onUserProfileClick = { userId -&gt;&#10;                    viewModel.loadUserProfile(userId)&#10;                    selectedScreen = Screen.ProfileViewer&#10;                },&#10;                onCreateStory = { imageUri, text -&gt;&#10;                    viewModel.createStory(imageUri, text)&#10;                },&#10;                onImageClick = { imageUrls, initialPage -&gt;&#10;                    // Navigate to image viewer&#10;                    imageViewerUrls = imageUrls&#10;                    imageViewerInitialPage = initialPage&#10;                    selectedScreen = Screen.ImageViewer&#10;                },&#10;                feedScrollState = feedScrollState // Pass the feed scroll state down&#10;            )&#10;        }&#10;&#10;        Screen.DropSecret -&gt; {&#10;            // This case is now handled within MainScreenContainer&#10;            // Redirect to Feed&#10;            selectedScreen = Screen.Feed&#10;        }&#10;&#10;        Screen.MySecrets -&gt; {&#10;            MySecretsScreen(&#10;                secrets = uiState.mySecrets,&#10;                isLoading = uiState.isLoading,&#10;                onSecretClick = { secret -&gt;&#10;                    viewModel.selectSecret(secret)&#10;                    selectedScreen = Screen.SecretDetail&#10;                }&#10;            )&#10;        }&#10;&#10;        Screen.SecretDetail -&gt; {&#10;            uiState.selectedSecret?.let { secret -&gt;&#10;                SecretDetailScreen(&#10;                    secret = secret,&#10;                    comments = uiState.selectedSecretComments,&#10;                    likes = uiState.selectedSecretLikes,&#10;                    isLikedByCurrentUser = secret.isLikedByCurrentUser,&#10;                    onLikeClick = {&#10;                        viewModel.toggleLike(secret)&#10;                    },&#10;                    onCommentSubmit = { commentText -&gt;&#10;                        viewModel.addComment(secret.id, commentText)&#10;                    },&#10;                    onBack = {&#10;                        selectedScreen = Screen.Feed&#10;                    },&#10;                    isLoading = uiState.isLoading&#10;                )&#10;            }&#10;        }&#10;&#10;        Screen.StoryViewer -&gt; {&#10;            StoryViewerScreen(&#10;                stories = uiState.selectedUserStories,&#10;                currentIndex = uiState.currentStoryIndex,&#10;                onNextStory = {&#10;                    viewModel.nextStory()&#10;                },&#10;                onPreviousStory = {&#10;                    viewModel.previousStory()&#10;                },&#10;                onClose = {&#10;                    viewModel.clearSelectedStories()&#10;                    selectedScreen = Screen.Feed&#10;                }&#10;            )&#10;        }&#10;&#10;        Screen.ProfileViewer -&gt; {&#10;            ProfileViewerScreen(&#10;                user = uiState.selectedUser,&#10;                currentUserId = uiState.currentUser?.id,&#10;                userSecrets = uiState.selectedUserSecrets,&#10;                isFollowing = uiState.isFollowing,&#10;                isFriend = uiState.isFriend,&#10;                friendRequestSent = uiState.friendRequestSent,&#10;                onBack = {&#10;                    viewModel.clearSelectedUser()&#10;                    selectedScreen = Screen.Feed&#10;                },&#10;                onFollowClick = {&#10;                    viewModel.toggleFollow()&#10;                },&#10;                onSendFriendRequest = {&#10;                    viewModel.sendFriendRequest()&#10;                },&#10;                onLikeClick = { secret -&gt;&#10;                    viewModel.toggleLike(secret)&#10;                },&#10;                onCommentClick = { secret -&gt;&#10;                    viewModel.selectSecret(secret)&#10;                    selectedScreen = Screen.SecretDetail&#10;                },&#10;                onMapClick = { secret -&gt;&#10;                    // Navigate to map with selected secret&#10;                    viewModel.selectSecret(secret)&#10;                    selectedScreen = Screen.Map&#10;                },&#10;                onSecretClick = { secret -&gt;&#10;                    viewModel.selectSecret(secret)&#10;                    selectedScreen = Screen.SecretDetail&#10;                },&#10;                isLoading = uiState.isLoading&#10;            )&#10;        }&#10;&#10;        Screen.ImageViewer -&gt; {&#10;            ImageViewerScreen(&#10;                imageUrls = imageViewerUrls,&#10;                initialPage = imageViewerInitialPage,&#10;                onBack = {&#10;                    selectedScreen = Screen.Feed&#10;                }&#10;            )&#10;        }&#10;&#10;        Screen.Auth -&gt; {&#10;            // Should not reach here as we handle auth above&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.secretspaces32.android.ui.navigation&#13;&#10;&#13;&#10;import android.Manifest&#13;&#10;import android.widget.Toast&#13;&#10;import androidx.compose.foundation.lazy.LazyListState&#13;&#10;import androidx.compose.runtime.*&#13;&#10;import androidx.compose.runtime.saveable.rememberSaveable&#13;&#10;import androidx.compose.ui.platform.LocalContext&#13;&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#13;&#10;import com.secretspaces32.android.viewmodel.MainViewModel&#13;&#10;import com.secretspaces32.android.ui.screens.*&#13;&#10;import com.google.accompanist.permissions.ExperimentalPermissionsApi&#13;&#10;import com.google.accompanist.permissions.rememberMultiplePermissionsState&#13;&#10;import androidx.credentials.CredentialManager&#13;&#10;import androidx.credentials.GetCredentialRequest&#13;&#10;import androidx.credentials.CustomCredential&#13;&#10;import com.google.android.libraries.identity.googleid.GetGoogleIdOption&#13;&#10;import com.google.android.libraries.identity.googleid.GoogleIdTokenCredential&#13;&#10;import com.google.android.libraries.identity.googleid.GoogleIdTokenParsingException&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;&#13;&#10;enum class Screen {&#13;&#10;    Auth,&#13;&#10;    Feed,&#13;&#10;    Map,&#13;&#10;    DropSecret,&#13;&#10;    Profile,&#13;&#10;    MySecrets,&#13;&#10;    SecretDetail,&#13;&#10;    StoryViewer,&#13;&#10;    ProfileViewer,&#13;&#10;    ImageViewer&#13;&#10;}&#13;&#10;&#13;&#10;@OptIn(ExperimentalPermissionsApi::class)&#13;&#10;@Composable&#13;&#10;fun SecretSpacesApp() {&#13;&#10;    val context = LocalContext.current&#13;&#10;    val viewModel: MainViewModel = viewModel(&#13;&#10;        factory = object : androidx.lifecycle.ViewModelProvider.Factory {&#13;&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#13;&#10;            override fun &lt;T : androidx.lifecycle.ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#13;&#10;                return MainViewModel(context) as T&#13;&#10;            }&#13;&#10;        }&#13;&#10;    )&#13;&#10;&#13;&#10;    val uiState by viewModel.uiState.collectAsState()&#13;&#10;    var selectedScreen by rememberSaveable { mutableStateOf(Screen.Feed) }&#13;&#10;&#13;&#10;    // Hoist feed scroll state to top level so it survives navigation to SecretDetail and back&#13;&#10;    val feedScrollState = rememberSaveable(saver = LazyListState.Saver) {&#13;&#10;        LazyListState()&#13;&#10;    }&#13;&#10;&#13;&#10;    // Image viewer state&#13;&#10;    var imageViewerUrls by remember { mutableStateOf&lt;List&lt;String&gt;&gt;(emptyList()) }&#13;&#10;    var imageViewerInitialPage by remember { mutableStateOf(0) }&#13;&#10;&#13;&#10;    // Persist the sheet state at navigation level so it survives screen changes&#13;&#10;    var mapSheetState by rememberSaveable { mutableStateOf(&quot;COLLAPSED&quot;) }&#13;&#10;&#13;&#10;    val coroutineScope = rememberCoroutineScope()&#13;&#10;    val credentialManager = remember { CredentialManager.create(context) }&#13;&#10;&#13;&#10;    // If user had logged in before and auth isn't resolved yet, show a splash to avoid login flicker&#13;&#10;    if (uiState.hasLoggedIn &amp;&amp; !uiState.isAuthResolved) {&#13;&#10;        SplashScreen()&#13;&#10;        return&#13;&#10;    }&#13;&#10;&#13;&#10;    // Location permissions - removed automatic request&#13;&#10;    // Permissions will be requested from MapScreen when user navigates there&#13;&#10;&#13;&#10;    // Initialize with default location when authenticated&#13;&#10;    LaunchedEffect(uiState.isAuthenticated) {&#13;&#10;        if (uiState.isAuthenticated) {&#13;&#10;            try {&#13;&#10;                println(&quot;DEBUG: App authenticated, initializing with default location&quot;)&#13;&#10;                // Call updateLocation - it will use default location if no permission&#13;&#10;                viewModel.updateLocation()&#13;&#10;            } catch (e: Exception) {&#13;&#10;                println(&quot;DEBUG: Error in authentication flow: ${e.message}&quot;)&#13;&#10;                e.printStackTrace()&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Show error messages&#13;&#10;    LaunchedEffect(uiState.errorMessage) {&#13;&#10;        uiState.errorMessage?.let { message -&gt;&#13;&#10;            try {&#13;&#10;                Toast.makeText(context, message, Toast.LENGTH_LONG).show()&#13;&#10;                viewModel.clearError()&#13;&#10;            } catch (e: Exception) {&#13;&#10;                println(&quot;DEBUG: Error showing toast: ${e.message}&quot;)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Auto-navigate to story viewer when stories are loaded&#13;&#10;    LaunchedEffect(uiState.selectedUserStories) {&#13;&#10;        if (uiState.selectedUserStories.isNotEmpty() &amp;&amp; selectedScreen == Screen.Feed) {&#13;&#10;            println(&quot;DEBUG: Stories loaded (${uiState.selectedUserStories.size}), auto-navigating to viewer&quot;)&#13;&#10;            selectedScreen = Screen.StoryViewer&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Show authentication screen if not authenticated&#13;&#10;    if (!uiState.isAuthenticated) {&#13;&#10;        AuthScreen(&#13;&#10;            onSignIn = { email, password -&gt;&#13;&#10;                viewModel.signIn(email, password)&#13;&#10;            },&#13;&#10;            onSignUp = { email, password, username -&gt;&#13;&#10;                viewModel.signUp(email, password, username)&#13;&#10;            },&#13;&#10;            onGoogleSignIn = {&#13;&#10;                coroutineScope.launch {&#13;&#10;                    try {&#13;&#10;                        println(&quot;DEBUG: Starting Google Sign-In process&quot;)&#13;&#10;&#13;&#10;                        // Configure Google ID option with your Web Client ID from Firebase Console&#13;&#10;                        val googleIdOption = GetGoogleIdOption.Builder()&#13;&#10;                            .setFilterByAuthorizedAccounts(false)&#13;&#10;                            .setServerClientId(&quot;170496527031-ul59lq2gqm76re4an5p2lftol7g3hjfl.apps.googleusercontent.com&quot;)&#13;&#10;                            .build()&#13;&#10;&#13;&#10;                        println(&quot;DEBUG: GoogleIdOption built, creating request&quot;)&#13;&#10;&#13;&#10;                        val request = GetCredentialRequest.Builder()&#13;&#10;                            .addCredentialOption(googleIdOption)&#13;&#10;                            .build()&#13;&#10;&#13;&#10;                        println(&quot;DEBUG: Requesting credentials from CredentialManager&quot;)&#13;&#10;&#13;&#10;                        val result = credentialManager.getCredential(&#13;&#10;                            request = request,&#13;&#10;                            context = context&#13;&#10;                        )&#13;&#10;&#13;&#10;                        println(&quot;DEBUG: Credential received, type: ${result.credential.type}&quot;)&#13;&#10;&#13;&#10;                        when (val credential = result.credential) {&#13;&#10;                            is CustomCredential -&gt; {&#13;&#10;                                if (credential.type == GoogleIdTokenCredential.TYPE_GOOGLE_ID_TOKEN_CREDENTIAL) {&#13;&#10;                                    try {&#13;&#10;                                        // Use GoogleIdTokenCredential.createFrom to parse the custom credential&#13;&#10;                                        val googleIdTokenCredential = GoogleIdTokenCredential.createFrom(credential.data)&#13;&#10;                                        val idToken = googleIdTokenCredential.idToken&#13;&#10;                                        println(&quot;DEBUG: Google ID Token extracted from CustomCredential, signing in with Firebase&quot;)&#13;&#10;                                        viewModel.signInWithGoogle(idToken)&#13;&#10;                                    } catch (e: GoogleIdTokenParsingException) {&#13;&#10;                                        println(&quot;DEBUG: Error parsing Google ID Token: ${e.message}&quot;)&#13;&#10;                                        Toast.makeText(&#13;&#10;                                            context,&#13;&#10;                                            &quot;Error parsing Google credentials&quot;,&#13;&#10;                                            Toast.LENGTH_SHORT&#13;&#10;                                        ).show()&#13;&#10;                                    }&#13;&#10;                                } else {&#13;&#10;                                    println(&quot;DEBUG: Unexpected custom credential type: ${credential.type}&quot;)&#13;&#10;                                    Toast.makeText(&#13;&#10;                                        context,&#13;&#10;                                        &quot;Unexpected credential type: ${credential.type}&quot;,&#13;&#10;                                        Toast.LENGTH_SHORT&#13;&#10;                                    ).show()&#13;&#10;                                }&#13;&#10;                            }&#13;&#10;                            else -&gt; {&#13;&#10;                                println(&quot;DEBUG: Credential is not CustomCredential: ${credential.javaClass.name}&quot;)&#13;&#10;                                Toast.makeText(&#13;&#10;                                    context,&#13;&#10;                                    &quot;Unexpected credential format&quot;,&#13;&#10;                                    Toast.LENGTH_SHORT&#13;&#10;                                ).show()&#13;&#10;                            }&#13;&#10;                        }&#13;&#10;                    } catch (e: Exception) {&#13;&#10;                        println(&quot;DEBUG: Google Sign-In error: ${e.javaClass.simpleName}&quot;)&#13;&#10;                        println(&quot;DEBUG: Error message: ${e.message}&quot;)&#13;&#10;                        e.printStackTrace()&#13;&#10;&#13;&#10;                        val errorMessage = when {&#13;&#10;                            e.message?.contains(&quot;16&quot;) == true -&gt; &quot;Google Sign-In not configured. Enable it in Firebase Console.&quot;&#13;&#10;                            e.message?.contains(&quot;developer console&quot;, ignoreCase = true) == true -&gt;&#13;&#10;                                &quot;Please add SHA-1 &amp; SHA-256 to Firebase Console&quot;&#13;&#10;                            e.message?.contains(&quot;cancelled&quot;, ignoreCase = true) == true -&gt; &quot;Sign-in cancelled&quot;&#13;&#10;                            e.message?.contains(&quot;No credentials&quot;, ignoreCase = true) == true -&gt; &quot;No Google accounts found&quot;&#13;&#10;                            else -&gt; &quot;Google Sign-In failed: ${e.message}&quot;&#13;&#10;                        }&#13;&#10;&#13;&#10;                        Toast.makeText(&#13;&#10;                            context,&#13;&#10;                            errorMessage,&#13;&#10;                            Toast.LENGTH_LONG&#13;&#10;                        ).show()&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            },&#13;&#10;            isLoading = uiState.isLoading,&#13;&#10;            isEmailAuthLoading = uiState.isEmailAuthLoading,&#13;&#10;            isGoogleAuthLoading = uiState.isGoogleAuthLoading&#13;&#10;        )&#13;&#10;        return&#13;&#10;    }&#13;&#10;&#13;&#10;    // Main app navigation&#13;&#10;    when (selectedScreen) {&#13;&#10;        Screen.Feed, Screen.Map, Screen.Profile -&gt; {&#13;&#10;            MainScreenContainer(&#13;&#10;                currentLocation = uiState.currentLocation,&#13;&#10;                nearbySecrets = uiState.secrets,&#13;&#10;                currentUser = uiState.currentUser,&#13;&#10;                mySecrets = uiState.mySecrets,&#13;&#10;                isLoading = uiState.isLoading,&#13;&#10;                onSecretClick = { secret -&gt;&#13;&#10;                    viewModel.selectSecret(secret)&#13;&#10;                    selectedScreen = Screen.SecretDetail&#13;&#10;                },&#13;&#10;                onDropSecretClick = {&#13;&#10;                    selectedScreen = Screen.DropSecret&#13;&#10;                },&#13;&#10;                onSignOut = {&#13;&#10;                    viewModel.signOut()&#13;&#10;                    selectedScreen = Screen.Feed&#13;&#10;                },&#13;&#10;                onUpdateProfile = { username, bio, imageUri -&gt;&#13;&#10;                    viewModel.updateProfile(username, bio, imageUri)&#13;&#10;                },&#13;&#10;                onLikeClick = { secret -&gt;&#13;&#10;                    viewModel.toggleLike(secret)&#13;&#10;                },&#13;&#10;                onLoadMySecrets = {&#13;&#10;                    viewModel.loadMySecrets()&#13;&#10;                },&#13;&#10;                onLocationPermissionGranted = {&#13;&#10;                    viewModel.updateLocation()&#13;&#10;                },&#13;&#10;                onPostSecret = { text, imageUris, isAnonymous, mood, category, hashtags, postType -&gt;&#13;&#10;                    if (postType == &quot;Story&quot;) {&#13;&#10;                        // Stories still use single image&#13;&#10;                        viewModel.createStory(imageUris.firstOrNull(), text)&#13;&#10;                    } else {&#13;&#10;                        // Secrets now support multiple images&#13;&#10;                        if (imageUris.isNotEmpty()) {&#13;&#10;                            viewModel.createSecretWithMultipleImages(text, imageUris, isAnonymous, mood, category, hashtags)&#13;&#10;                        } else {&#13;&#10;                            viewModel.createSecret(text, null, isAnonymous, mood, category, hashtags)&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                },&#13;&#10;                cacheDir = context.cacheDir,&#13;&#10;                myStories = uiState.myStories,&#13;&#10;                onViewMyStory = {&#13;&#10;                    // Load current user's stories - navigation will happen via LaunchedEffect below&#13;&#10;                    println(&quot;DEBUG: onViewMyStory clicked&quot;)&#13;&#10;                    uiState.currentUser?.id?.let { userId -&gt;&#13;&#10;                        println(&quot;DEBUG: Loading stories for user: $userId&quot;)&#13;&#10;                        viewModel.loadUserStories(userId)&#13;&#10;                    } ?: run {&#13;&#10;                        println(&quot;DEBUG: No current user found&quot;)&#13;&#10;                    }&#13;&#10;                },&#13;&#10;                onLoadMyStories = {&#13;&#10;                    viewModel.loadMyStories()&#13;&#10;                },&#13;&#10;                onUserProfileClick = { userId -&gt;&#13;&#10;                    viewModel.loadUserProfile(userId)&#13;&#10;                    selectedScreen = Screen.ProfileViewer&#13;&#10;                },&#13;&#10;                onCreateStory = { imageUri, text -&gt;&#13;&#10;                    viewModel.createStory(imageUri, text)&#13;&#10;                },&#13;&#10;                onImageClick = { imageUrls, initialPage -&gt;&#13;&#10;                    // Navigate to image viewer&#13;&#10;                    imageViewerUrls = imageUrls&#13;&#10;                    imageViewerInitialPage = initialPage&#13;&#10;                    selectedScreen = Screen.ImageViewer&#13;&#10;                },&#13;&#10;                feedScrollState = feedScrollState // Pass the feed scroll state down&#13;&#10;            )&#13;&#10;        }&#13;&#10;&#13;&#10;        Screen.DropSecret -&gt; {&#13;&#10;            // This case is now handled within MainScreenContainer&#13;&#10;            // Redirect to Feed&#13;&#10;            selectedScreen = Screen.Feed&#13;&#10;        }&#13;&#10;&#13;&#10;        Screen.MySecrets -&gt; {&#13;&#10;            MySecretsScreen(&#13;&#10;                secrets = uiState.mySecrets,&#13;&#10;                isLoading = uiState.isLoading,&#13;&#10;                onSecretClick = { secret -&gt;&#13;&#10;                    viewModel.selectSecret(secret)&#13;&#10;                    selectedScreen = Screen.SecretDetail&#13;&#10;                }&#13;&#10;            )&#13;&#10;        }&#13;&#10;&#13;&#10;        Screen.SecretDetail -&gt; {&#13;&#10;            uiState.selectedSecret?.let { secret -&gt;&#13;&#10;                SecretDetailScreen(&#13;&#10;                    secret = secret,&#13;&#10;                    comments = uiState.selectedSecretComments,&#13;&#10;                    likes = uiState.selectedSecretLikes,&#13;&#10;                    isLikedByCurrentUser = secret.isLikedByCurrentUser,&#13;&#10;                    onLikeClick = {&#13;&#10;                        viewModel.toggleLike(secret)&#13;&#10;                    },&#13;&#10;                    onCommentSubmit = { commentText -&gt;&#13;&#10;                        viewModel.addComment(secret.id, commentText)&#13;&#10;                    },&#13;&#10;                    onBack = {&#13;&#10;                        selectedScreen = Screen.Feed&#13;&#10;                    },&#13;&#10;                    isLoading = uiState.isLoading&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        Screen.StoryViewer -&gt; {&#13;&#10;            StoryViewerScreen(&#13;&#10;                stories = uiState.selectedUserStories,&#13;&#10;                currentIndex = uiState.currentStoryIndex,&#13;&#10;                onNextStory = {&#13;&#10;                    viewModel.nextStory()&#13;&#10;                },&#13;&#10;                onPreviousStory = {&#13;&#10;                    viewModel.previousStory()&#13;&#10;                },&#13;&#10;                onClose = {&#13;&#10;                    viewModel.clearSelectedStories()&#13;&#10;                    selectedScreen = Screen.Feed&#13;&#10;                }&#13;&#10;            )&#13;&#10;        }&#13;&#10;&#13;&#10;        Screen.ProfileViewer -&gt; {&#13;&#10;            ProfileViewerScreen(&#13;&#10;                user = uiState.selectedUser,&#13;&#10;                currentUserId = uiState.currentUser?.id,&#13;&#10;                userSecrets = uiState.selectedUserSecrets,&#13;&#10;                isFollowing = uiState.isFollowing,&#13;&#10;                isFriend = uiState.isFriend,&#13;&#10;                friendRequestSent = uiState.friendRequestSent,&#13;&#10;                onBack = {&#13;&#10;                    viewModel.clearSelectedUser()&#13;&#10;                    selectedScreen = Screen.Feed&#13;&#10;                },&#13;&#10;                onFollowClick = {&#13;&#10;                    viewModel.toggleFollow()&#13;&#10;                },&#13;&#10;                onSendFriendRequest = {&#13;&#10;                    viewModel.sendFriendRequest()&#13;&#10;                },&#13;&#10;                onLikeClick = { secret -&gt;&#13;&#10;                    viewModel.toggleLike(secret)&#13;&#10;                },&#13;&#10;                onCommentClick = { secret -&gt;&#13;&#10;                    viewModel.selectSecret(secret)&#13;&#10;                    selectedScreen = Screen.SecretDetail&#13;&#10;                },&#13;&#10;                onMapClick = { secret -&gt;&#13;&#10;                    // Navigate to map with selected secret&#13;&#10;                    viewModel.selectSecret(secret)&#13;&#10;                    selectedScreen = Screen.Map&#13;&#10;                },&#13;&#10;                onSecretClick = { secret -&gt;&#13;&#10;                    viewModel.selectSecret(secret)&#13;&#10;                    selectedScreen = Screen.SecretDetail&#13;&#10;                },&#13;&#10;                isLoading = uiState.isLoading&#13;&#10;            )&#13;&#10;        }&#13;&#10;&#13;&#10;        Screen.ImageViewer -&gt; {&#13;&#10;            ImageViewerScreen(&#13;&#10;                imageUrls = imageViewerUrls,&#13;&#10;                initialPage = imageViewerInitialPage,&#13;&#10;                onBack = {&#13;&#10;                    selectedScreen = Screen.Feed&#13;&#10;                }&#13;&#10;            )&#13;&#10;        }&#13;&#10;&#13;&#10;        Screen.Auth -&gt; {&#13;&#10;            // Should not reach here as we handle auth above&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/secretspaces32/android/ui/screens/SplashScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/secretspaces32/android/ui/screens/SplashScreen.kt" />
              <option name="updatedContent" value="package com.secretspaces32.android.ui.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;&#10;@Composable&#10;fun SplashScreen() {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.Black),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        CircularProgressIndicator(color = Color.White)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/secretspaces32/android/viewmodel/MainViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/secretspaces32/android/viewmodel/MainViewModel.kt" />
              <option name="originalContent" value="package com.secretspaces32.android.viewmodel&#10;&#10;import android.content.Context&#10;import android.location.Location&#10;import android.net.Uri&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.secretspaces32.android.data.model.Comment&#10;import com.secretspaces32.android.data.model.Like&#10;import com.secretspaces32.android.data.model.Secret&#10;import com.secretspaces32.android.data.model.User&#10;import com.secretspaces32.android.data.model.UpdateUserRequest&#10;import com.secretspaces32.android.data.repository.AuthRepository&#10;import com.secretspaces32.android.data.repository.SecretRepository&#10;import com.secretspaces32.android.data.repository.StoryRepository&#10;import com.secretspaces32.android.data.repository.UserRepository&#10;import com.secretspaces32.android.utils.LocationHelper&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;data class AppUiState(&#10;    val isAuthenticated: Boolean = false,&#10;    val currentUser: User? = null,&#10;    val currentLocation: Location? = null,&#10;    val secrets: List&lt;Secret&gt; = emptyList(),&#10;    val mySecrets: List&lt;Secret&gt; = emptyList(),&#10;    val selectedSecret: Secret? = null,&#10;    val selectedSecretComments: List&lt;Comment&gt; = emptyList(),&#10;    val selectedSecretLikes: List&lt;Like&gt; = emptyList(),&#10;    val isLoading: Boolean = false,&#10;    val isEmailAuthLoading: Boolean = false,&#10;    val isGoogleAuthLoading: Boolean = false,&#10;    val errorMessage: String? = null,&#10;    val myStories: List&lt;com.secretspaces32.android.data.model.Story&gt; = emptyList(),&#10;    val selectedUserStories: List&lt;com.secretspaces32.android.data.model.Story&gt; = emptyList(),&#10;    val currentStoryIndex: Int = 0,&#10;    val selectedUser: User? = null,&#10;    val selectedUserSecrets: List&lt;Secret&gt; = emptyList(),&#10;    val isFollowing: Boolean = false,&#10;    val isFriend: Boolean = false,&#10;    val friendRequestSent: Boolean = false&#10;)&#10;&#10;class MainViewModel(&#10;    private val context: Context&#10;) : ViewModel() {&#10;&#10;    private val authRepository = AuthRepository()&#10;    private val userRepository = UserRepository(context)&#10;    private val secretRepository = SecretRepository(context)&#10;    private val storyRepository = StoryRepository(context)&#10;    private val locationHelper = LocationHelper(context)&#10;&#10;    private val _uiState = MutableStateFlow(AppUiState())&#10;    val uiState: StateFlow&lt;AppUiState&gt; = _uiState.asStateFlow()&#10;&#10;    init {&#10;        checkAuthState()&#10;    }&#10;&#10;    private fun checkAuthState() {&#10;        viewModelScope.launch {&#10;            authRepository.currentUser.collect { firebaseUser -&gt;&#10;                if (firebaseUser != null) {&#10;                    loadCurrentUser(firebaseUser.uid)&#10;                } else {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isAuthenticated = false,&#10;                        currentUser = null&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun loadCurrentUser(userId: String) {&#10;        val result = userRepository.getUser(userId)&#10;        result.onSuccess { user -&gt;&#10;            _uiState.value = _uiState.value.copy(&#10;                isAuthenticated = true,&#10;                currentUser = user&#10;            )&#10;        }.onFailure {&#10;            _uiState.value = _uiState.value.copy(&#10;                isAuthenticated = true,&#10;                currentUser = null,&#10;                errorMessage = &quot;Failed to load user profile&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    fun signUp(email: String, password: String, username: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isEmailAuthLoading = true)&#10;&#10;            val authResult = authRepository.signUp(email, password, username)&#10;            authResult.onSuccess { firebaseUser -&gt;&#10;                val userResult = userRepository.createUser(&#10;                    userId = firebaseUser.uid,&#10;                    email = email,&#10;                    username = username&#10;                )&#10;&#10;                userResult.onSuccess { user -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isAuthenticated = true,&#10;                        currentUser = user,&#10;                        isEmailAuthLoading = false&#10;                    )&#10;                }.onFailure { e -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isEmailAuthLoading = false,&#10;                        errorMessage = &quot;Failed to create user profile: ${e.message}&quot;&#10;                    )&#10;                }&#10;            }.onFailure { e -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isEmailAuthLoading = false,&#10;                    errorMessage = &quot;Sign up failed: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun signIn(email: String, password: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isEmailAuthLoading = true)&#10;&#10;            val result = authRepository.signIn(email, password)&#10;            result.onSuccess {&#10;                _uiState.value = _uiState.value.copy(isEmailAuthLoading = false)&#10;            }.onFailure { e -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isEmailAuthLoading = false,&#10;                    errorMessage = &quot;Sign in failed: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun signInWithGoogle(idToken: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isGoogleAuthLoading = true)&#10;&#10;            val authResult = authRepository.signInWithGoogle(idToken)&#10;            authResult.onSuccess { firebaseUser -&gt;&#10;                // Check if user exists in Firestore&#10;                val userResult = userRepository.getUser(firebaseUser.uid)&#10;&#10;                userResult.onSuccess { user -&gt;&#10;                    // User already exists&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isAuthenticated = true,&#10;                        currentUser = user,&#10;                        isGoogleAuthLoading = false&#10;                    )&#10;                }.onFailure {&#10;                    // Create new user profile&#10;                    val createResult = userRepository.createUser(&#10;                        userId = firebaseUser.uid,&#10;                        email = firebaseUser.email ?: &quot;&quot;,&#10;                        username = firebaseUser.displayName ?: &quot;User&quot;&#10;                    )&#10;&#10;                    createResult.onSuccess { user -&gt;&#10;                        _uiState.value = _uiState.value.copy(&#10;                            isAuthenticated = true,&#10;                            currentUser = user,&#10;                            isGoogleAuthLoading = false&#10;                        )&#10;                    }.onFailure { e -&gt;&#10;                        _uiState.value = _uiState.value.copy(&#10;                            isGoogleAuthLoading = false,&#10;                            errorMessage = &quot;Failed to create user profile: ${e.message}&quot;&#10;                        )&#10;                    }&#10;                }&#10;            }.onFailure { e -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isGoogleAuthLoading = false,&#10;                    errorMessage = &quot;Google sign in failed: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun signOut() {&#10;        authRepository.signOut()&#10;        _uiState.value = AppUiState()&#10;    }&#10;&#10;    fun updateProfile(username: String, bio: String, imageUri: Uri?) {&#10;        viewModelScope.launch {&#10;            val userId = _uiState.value.currentUser?.id ?: return@launch&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;            try {&#10;                var profilePictureUrl: String? = null&#10;&#10;                if (imageUri != null) {&#10;                    val uploadResult = userRepository.uploadProfilePicture(imageUri)&#10;                    uploadResult.onSuccess { url -&gt;&#10;                        profilePictureUrl = url&#10;                    }&#10;                }&#10;&#10;                val updateRequest = UpdateUserRequest(&#10;                    username = username,&#10;                    bio = bio,&#10;                    profilePictureUrl = profilePictureUrl&#10;                )&#10;&#10;                val result = userRepository.updateUser(userId, updateRequest)&#10;                result.onSuccess {&#10;                    // Update profile picture in all existing secrets and comments&#10;                    if (profilePictureUrl != null) {&#10;                        secretRepository.updateUserProfilePictureInPosts(userId, profilePictureUrl)&#10;                    }&#10;&#10;                    loadCurrentUser(userId)&#10;                    _uiState.value = _uiState.value.copy(isLoading = false)&#10;                }.onFailure { e -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Failed to update profile: ${e.message}&quot;&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Error: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateLocation() {&#10;        viewModelScope.launch {&#10;            try {&#10;                println(&quot;DEBUG: Starting location update...&quot;)&#10;&#10;                if (!locationHelper.hasLocationPermission()) {&#10;                    println(&quot;DEBUG: Location permission not granted - skipping location update&quot;)&#10;                    // Don't set any location - let the UI handle permission request&#10;                    return@launch&#10;                }&#10;&#10;                if (!locationHelper.isLocationEnabled()) {&#10;                    println(&quot;DEBUG: Location services not enabled - skipping location update&quot;)&#10;                    // Don't set any location - let the UI handle this&#10;                    return@launch&#10;                }&#10;&#10;                println(&quot;DEBUG: Fetching location...&quot;)&#10;                val location = locationHelper.getCurrentLocation()&#10;&#10;                if (location == null) {&#10;                    println(&quot;DEBUG: Location is null - could not fetch location&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                println(&quot;DEBUG: ✅ Location obtained - Lat: ${location.latitude}, Lng: ${location.longitude}&quot;)&#10;                _uiState.value = _uiState.value.copy(currentLocation = location)&#10;&#10;                // Fetch nearby secrets with the obtained location&#10;                fetchNearbySecrets(location.latitude, location.longitude)&#10;&#10;            } catch (e: Exception) {&#10;                println(&quot;DEBUG: ❌ Location error - ${e.message}&quot;)&#10;                e.printStackTrace()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun fetchNearbySecrets(latitude: Double, longitude: Double) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;            val result = secretRepository.getNearbySecrets(latitude, longitude)&#10;&#10;            result.onSuccess { secrets -&gt;&#10;                val secretsWithDistance = secrets.map { secret -&gt;&#10;                    val distance = LocationHelper.calculateDistance(&#10;                        latitude, longitude,&#10;                        secret.latitude, secret.longitude&#10;                    )&#10;                    secret.copy(distance = distance)&#10;                }&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    secrets = secretsWithDistance,&#10;                    isLoading = false&#10;                )&#10;            }.onFailure { e -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Failed to fetch secrets: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun createSecret(text: String, imageUri: Uri?, isAnonymous: Boolean, mood: String? = null, category: String? = null, hashtags: String? = null) {&#10;        viewModelScope.launch {&#10;            val location = _uiState.value.currentLocation&#10;            val user = _uiState.value.currentUser&#10;&#10;            if (location == null) {&#10;                _uiState.value = _uiState.value.copy(errorMessage = &quot;Location not available&quot;)&#10;                return@launch&#10;            }&#10;&#10;            if (user == null) {&#10;                _uiState.value = _uiState.value.copy(errorMessage = &quot;User not authenticated&quot;)&#10;                return@launch&#10;            }&#10;&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;            val result = secretRepository.createSecret(&#10;                text = text,&#10;                imageUri = imageUri,&#10;                latitude = location.latitude,&#10;                longitude = location.longitude,&#10;                username = user.username,&#10;                userProfilePicture = user.profilePictureUrl,&#10;                isAnonymous = isAnonymous,&#10;                mood = mood,&#10;                category = category,&#10;                hashtags = hashtags&#10;            )&#10;&#10;            result.onSuccess {&#10;                _uiState.value = _uiState.value.copy(isLoading = false)&#10;                fetchNearbySecrets(location.latitude, location.longitude)&#10;            }.onFailure { e -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Failed to post secret: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    // New function to create secret with multiple images&#10;    fun createSecretWithMultipleImages(&#10;        text: String,&#10;        imageUris: List&lt;Uri&gt;,&#10;        isAnonymous: Boolean,&#10;        mood: String? = null,&#10;        category: String? = null,&#10;        hashtags: String? = null&#10;    ) {&#10;        viewModelScope.launch {&#10;            val location = _uiState.value.currentLocation&#10;            val user = _uiState.value.currentUser&#10;&#10;            if (location == null) {&#10;                _uiState.value = _uiState.value.copy(errorMessage = &quot;Location not available&quot;)&#10;                return@launch&#10;            }&#10;&#10;            if (user == null) {&#10;                _uiState.value = _uiState.value.copy(errorMessage = &quot;User not authenticated&quot;)&#10;                return@launch&#10;            }&#10;&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;            val result = secretRepository.createSecretWithMultipleImages(&#10;                text = text,&#10;                imageUris = imageUris,&#10;                latitude = location.latitude,&#10;                longitude = location.longitude,&#10;                username = user.username,&#10;                userProfilePicture = user.profilePictureUrl,&#10;                isAnonymous = isAnonymous,&#10;                mood = mood,&#10;                category = category,&#10;                hashtags = hashtags&#10;            )&#10;&#10;            result.onSuccess {&#10;                _uiState.value = _uiState.value.copy(isLoading = false)&#10;                fetchNearbySecrets(location.latitude, location.longitude)&#10;            }.onFailure { e -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Failed to post secret: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun createStory(imageUri: Uri?, caption: String?) {&#10;        viewModelScope.launch {&#10;            val user = _uiState.value.currentUser&#10;&#10;            if (user == null) {&#10;                _uiState.value = _uiState.value.copy(errorMessage = &quot;User not authenticated&quot;)&#10;                return@launch&#10;            }&#10;&#10;            // Allow stories without images - text-only stories are now supported&#10;            if (imageUri == null &amp;&amp; caption.isNullOrBlank()) {&#10;                _uiState.value = _uiState.value.copy(errorMessage = &quot;Story requires either an image or text&quot;)&#10;                return@launch&#10;            }&#10;&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;            val result = storyRepository.createStory(&#10;                imageUri = imageUri,&#10;                caption = caption,&#10;                username = user.username,&#10;                userProfilePicture = user.profilePictureUrl&#10;            )&#10;&#10;            result.onSuccess {&#10;                _uiState.value = _uiState.value.copy(isLoading = false)&#10;                // Reload user's stories after creating a new one&#10;                loadMyStories()&#10;            }.onFailure { e -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Failed to post story: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun loadMyStories() {&#10;        viewModelScope.launch {&#10;            val userId = _uiState.value.currentUser?.id ?: return@launch&#10;&#10;            val result = storyRepository.getUserStories(userId)&#10;            result.onSuccess { stories -&gt;&#10;                _uiState.value = _uiState.value.copy(myStories = stories)&#10;            }.onFailure { e -&gt;&#10;                println(&quot;DEBUG: Failed to load stories: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun loadUserStories(userId: String) {&#10;        viewModelScope.launch {&#10;            println(&quot;DEBUG: loadUserStories called for userId: $userId&quot;)&#10;            val result = storyRepository.getUserStories(userId)&#10;            result.onSuccess { stories -&gt;&#10;                println(&quot;DEBUG: Successfully loaded ${stories.size} stories&quot;)&#10;                stories.forEach { story -&gt;&#10;                    println(&quot;DEBUG: Story - id: ${story.id}, imageUrl: ${story.imageUrl}&quot;)&#10;                }&#10;                _uiState.value = _uiState.value.copy(&#10;                    selectedUserStories = stories,&#10;                    currentStoryIndex = 0&#10;                )&#10;                println(&quot;DEBUG: UI state updated with stories&quot;)&#10;            }.onFailure { e -&gt;&#10;                println(&quot;DEBUG: Failed to load stories: ${e.message}&quot;)&#10;                e.printStackTrace()&#10;                _uiState.value = _uiState.value.copy(&#10;                    errorMessage = &quot;Failed to load stories: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun nextStory() {&#10;        val currentIndex = _uiState.value.currentStoryIndex&#10;        val storiesCount = _uiState.value.selectedUserStories.size&#10;        if (currentIndex &lt; storiesCount - 1) {&#10;            _uiState.value = _uiState.value.copy(currentStoryIndex = currentIndex + 1)&#10;        }&#10;    }&#10;&#10;    fun previousStory() {&#10;        val currentIndex = _uiState.value.currentStoryIndex&#10;        if (currentIndex &gt; 0) {&#10;            _uiState.value = _uiState.value.copy(currentStoryIndex = currentIndex - 1)&#10;        }&#10;    }&#10;&#10;    fun clearSelectedStories() {&#10;        _uiState.value = _uiState.value.copy(&#10;            selectedUserStories = emptyList(),&#10;            currentStoryIndex = 0&#10;        )&#10;    }&#10;&#10;    fun toggleLike(secret: Secret) {&#10;        viewModelScope.launch {&#10;            val user = _uiState.value.currentUser ?: return@launch&#10;&#10;            val result = secretRepository.toggleLike(secret.id, user.username)&#10;            result.onSuccess { isLiked -&gt;&#10;                // Update the secret in the list&#10;                val updatedSecrets = _uiState.value.secrets.map { s -&gt;&#10;                    if (s.id == secret.id) {&#10;                        s.copy(&#10;                            isLikedByCurrentUser = isLiked,&#10;                            likeCount = if (isLiked) s.likeCount + 1 else maxOf(0, s.likeCount - 1)&#10;                        )&#10;                    } else s&#10;                }&#10;                _uiState.value = _uiState.value.copy(secrets = updatedSecrets)&#10;&#10;                // Update selected secret if it's the same&#10;                if (_uiState.value.selectedSecret?.id == secret.id) {&#10;                    loadSecretDetails(secret.id)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun selectSecret(secret: Secret?) {&#10;        _uiState.value = _uiState.value.copy(selectedSecret = secret)&#10;        secret?.let { loadSecretDetails(it.id) }&#10;    }&#10;&#10;    fun loadSecretDetails(secretId: String) {&#10;        viewModelScope.launch {&#10;            val commentsResult = secretRepository.getComments(secretId)&#10;            val likesResult = secretRepository.getLikes(secretId)&#10;&#10;            commentsResult.onSuccess { comments -&gt;&#10;                _uiState.value = _uiState.value.copy(selectedSecretComments = comments)&#10;            }&#10;&#10;            likesResult.onSuccess { likes -&gt;&#10;                _uiState.value = _uiState.value.copy(selectedSecretLikes = likes)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun addComment(secretId: String, text: String) {&#10;        viewModelScope.launch {&#10;            val user = _uiState.value.currentUser ?: return@launch&#10;&#10;            println(&quot;DEBUG: Adding comment for secret $secretId&quot;)&#10;&#10;            val result = secretRepository.addComment(&#10;                secretId = secretId,&#10;                text = text,&#10;                username = user.username,&#10;                userProfilePicture = user.profilePictureUrl&#10;            )&#10;&#10;            result.onSuccess { newComment -&gt;&#10;                println(&quot;DEBUG: Comment added successfully: ${newComment.text}&quot;)&#10;&#10;                // Add small delay to ensure Firebase propagates the comment&#10;                kotlinx.coroutines.delay(800)&#10;&#10;                println(&quot;DEBUG: Reloading secret details...&quot;)&#10;                // Reload comments and likes&#10;                val commentsResult = secretRepository.getComments(secretId)&#10;                val likesResult = secretRepository.getLikes(secretId)&#10;&#10;                commentsResult.onSuccess { comments -&gt;&#10;                    println(&quot;DEBUG: Loaded ${comments.size} comments&quot;)&#10;                    _uiState.value = _uiState.value.copy(selectedSecretComments = comments)&#10;                }&#10;&#10;                likesResult.onSuccess { likes -&gt;&#10;                    _uiState.value = _uiState.value.copy(selectedSecretLikes = likes)&#10;                }&#10;&#10;                // Update comment count in the secrets list&#10;                val updatedSecrets = _uiState.value.secrets.map { s -&gt;&#10;                    if (s.id == secretId) {&#10;                        s.copy(commentCount = s.commentCount + 1)&#10;                    } else s&#10;                }&#10;&#10;                // Update the selected secret with new comment count&#10;                val updatedSelectedSecret = _uiState.value.selectedSecret?.let { secret -&gt;&#10;                    if (secret.id == secretId) {&#10;                        secret.copy(commentCount = secret.commentCount + 1)&#10;                    } else secret&#10;                }&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    secrets = updatedSecrets,&#10;                    selectedSecret = updatedSelectedSecret&#10;                )&#10;&#10;                println(&quot;DEBUG: UI state updated with ${_uiState.value.selectedSecretComments.size} comments&quot;)&#10;            }.onFailure { e -&gt;&#10;                println(&quot;DEBUG: Failed to add comment: ${e.message}&quot;)&#10;                _uiState.value = _uiState.value.copy(&#10;                    errorMessage = &quot;Failed to add comment: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun loadMySecrets() {&#10;        viewModelScope.launch {&#10;            val userId = _uiState.value.currentUser?.id ?: return@launch&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;            val result = secretRepository.getUserSecrets(userId)&#10;            result.onSuccess { secrets -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    mySecrets = secrets,&#10;                    isLoading = false&#10;                )&#10;            }.onFailure { e -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Failed to load your secrets: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearError() {&#10;        _uiState.value = _uiState.value.copy(errorMessage = null)&#10;    }&#10;&#10;    // Profile Viewer functions&#10;    fun loadUserProfile(userId: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;            // Load user profile&#10;            val userResult = userRepository.getUser(userId)&#10;            userResult.onSuccess { user -&gt;&#10;                _uiState.value = _uiState.value.copy(selectedUser = user)&#10;            }.onFailure { e -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    errorMessage = &quot;Failed to load user profile: ${e.message}&quot;&#10;                )&#10;            }&#10;&#10;            // Load user's secrets&#10;            val secretsResult = secretRepository.getUserSecrets(userId)&#10;            secretsResult.onSuccess { secrets -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    selectedUserSecrets = secrets,&#10;                    isLoading = false&#10;                )&#10;            }.onFailure { e -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Failed to load user posts: ${e.message}&quot;&#10;                )&#10;            }&#10;&#10;            // TODO: Load follow/friend status when backend supports it&#10;            // For now, set to default values&#10;            _uiState.value = _uiState.value.copy(&#10;                isFollowing = false,&#10;                isFriend = false,&#10;                friendRequestSent = false&#10;            )&#10;        }&#10;    }&#10;&#10;    fun clearSelectedUser() {&#10;        _uiState.value = _uiState.value.copy(&#10;            selectedUser = null,&#10;            selectedUserSecrets = emptyList(),&#10;            isFollowing = false,&#10;            isFriend = false,&#10;            friendRequestSent = false&#10;        )&#10;    }&#10;&#10;    fun toggleFollow() {&#10;        viewModelScope.launch {&#10;            // TODO: Implement follow/unfollow when backend supports it&#10;            val currentlyFollowing = _uiState.value.isFollowing&#10;            _uiState.value = _uiState.value.copy(isFollowing = !currentlyFollowing)&#10;&#10;            // Show feedback&#10;            _uiState.value = _uiState.value.copy(&#10;                errorMessage = if (!currentlyFollowing) &quot;Following user&quot; else &quot;Unfollowed user&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    fun sendFriendRequest() {&#10;        viewModelScope.launch {&#10;            // TODO: Implement friend request when backend supports it&#10;            _uiState.value = _uiState.value.copy(friendRequestSent = true)&#10;&#10;            // Show feedback&#10;            _uiState.value = _uiState.value.copy(&#10;                errorMessage = &quot;Friend request sent&quot;&#10;            )&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.secretspaces32.android.viewmodel&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import android.location.Location&#13;&#10;import android.net.Uri&#13;&#10;import androidx.lifecycle.ViewModel&#13;&#10;import androidx.lifecycle.viewModelScope&#13;&#10;import com.secretspaces32.android.data.model.Comment&#13;&#10;import com.secretspaces32.android.data.model.Like&#13;&#10;import com.secretspaces32.android.data.model.Secret&#13;&#10;import com.secretspaces32.android.data.model.User&#13;&#10;import com.secretspaces32.android.data.model.UpdateUserRequest&#13;&#10;import com.secretspaces32.android.data.repository.AuthRepository&#13;&#10;import com.secretspaces32.android.data.repository.SecretRepository&#13;&#10;import com.secretspaces32.android.data.repository.StoryRepository&#13;&#10;import com.secretspaces32.android.data.repository.UserRepository&#13;&#10;import com.secretspaces32.android.utils.LocationHelper&#13;&#10;import com.secretspaces32.android.data.prefs.AuthPrefs&#13;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#13;&#10;import kotlinx.coroutines.flow.StateFlow&#13;&#10;import kotlinx.coroutines.flow.asStateFlow&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;&#13;&#10;data class AppUiState(&#13;&#10;    val isAuthenticated: Boolean = false,&#13;&#10;    val currentUser: User? = null,&#13;&#10;    val currentLocation: Location? = null,&#13;&#10;    val secrets: List&lt;Secret&gt; = emptyList(),&#13;&#10;    val mySecrets: List&lt;Secret&gt; = emptyList(),&#13;&#10;    val selectedSecret: Secret? = null,&#13;&#10;    val selectedSecretComments: List&lt;Comment&gt; = emptyList(),&#13;&#10;    val selectedSecretLikes: List&lt;Like&gt; = emptyList(),&#13;&#10;    val isLoading: Boolean = false,&#13;&#10;    val isEmailAuthLoading: Boolean = false,&#13;&#10;    val isGoogleAuthLoading: Boolean = false,&#13;&#10;    val errorMessage: String? = null,&#13;&#10;    val myStories: List&lt;com.secretspaces32.android.data.model.Story&gt; = emptyList(),&#13;&#10;    val selectedUserStories: List&lt;com.secretspaces32.android.data.model.Story&gt; = emptyList(),&#13;&#10;    val currentStoryIndex: Int = 0,&#13;&#10;    val selectedUser: User? = null,&#13;&#10;    val selectedUserSecrets: List&lt;Secret&gt; = emptyList(),&#13;&#10;    val isFollowing: Boolean = false,&#13;&#10;    val isFriend: Boolean = false,&#13;&#10;    val friendRequestSent: Boolean = false,&#13;&#10;    // New flags for splash/auth gating&#13;&#10;    val hasLoggedIn: Boolean = false,&#13;&#10;    val isAuthResolved: Boolean = false&#13;&#10;)&#13;&#10;&#13;&#10;class MainViewModel(&#13;&#10;    private val context: Context&#13;&#10;) : ViewModel() {&#13;&#10;&#13;&#10;    private val authRepository = AuthRepository()&#13;&#10;    private val userRepository = UserRepository(context)&#13;&#10;    private val secretRepository = SecretRepository(context)&#13;&#10;    private val storyRepository = StoryRepository(context)&#13;&#10;    private val locationHelper = LocationHelper(context)&#13;&#10;&#13;&#10;    private val _uiState = MutableStateFlow(AppUiState())&#13;&#10;    val uiState: StateFlow&lt;AppUiState&gt; = _uiState.asStateFlow()&#13;&#10;&#13;&#10;    init {&#13;&#10;        // Initialize cached login flag and then observe auth&#13;&#10;        viewModelScope.launch {&#13;&#10;            val cached = try { AuthPrefs.hasLoggedInFlow(context).first() } catch (e: Exception) { false }&#13;&#10;            _uiState.value = _uiState.value.copy(hasLoggedIn = cached)&#13;&#10;            checkAuthState()&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun checkAuthState() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            authRepository.currentUser.collect { firebaseUser -&gt;&#13;&#10;                if (firebaseUser != null) {&#13;&#10;                    loadCurrentUser(firebaseUser.uid)&#13;&#10;                } else {&#13;&#10;                    _uiState.value = _uiState.value.copy(&#13;&#10;                        isAuthenticated = false,&#13;&#10;                        currentUser = null,&#13;&#10;                        isAuthResolved = true&#13;&#10;                    )&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private suspend fun loadCurrentUser(userId: String) {&#13;&#10;        val result = userRepository.getUser(userId)&#13;&#10;        result.onSuccess { user -&gt;&#13;&#10;            _uiState.value = _uiState.value.copy(&#13;&#10;                isAuthenticated = true,&#13;&#10;                currentUser = user,&#13;&#10;                isAuthResolved = true&#13;&#10;            )&#13;&#10;            // Persist flag so we can skip login splash on next launches&#13;&#10;            viewModelScope.launch { AuthPrefs.setHasLoggedIn(context, true) }&#13;&#10;        }.onFailure {&#13;&#10;            _uiState.value = _uiState.value.copy(&#13;&#10;                isAuthenticated = true,&#13;&#10;                currentUser = null,&#13;&#10;                errorMessage = &quot;Failed to load user profile&quot;,&#13;&#10;                isAuthResolved = true&#13;&#10;            )&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun signUp(email: String, password: String, username: String) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            _uiState.value = _uiState.value.copy(isEmailAuthLoading = true)&#13;&#10;&#13;&#10;            val authResult = authRepository.signUp(email, password, username)&#13;&#10;            authResult.onSuccess { firebaseUser -&gt;&#13;&#10;                val userResult = userRepository.createUser(&#13;&#10;                    userId = firebaseUser.uid,&#13;&#10;                    email = email,&#13;&#10;                    username = username&#13;&#10;                )&#13;&#10;&#13;&#10;                userResult.onSuccess { user -&gt;&#13;&#10;                    _uiState.value = _uiState.value.copy(&#13;&#10;                        isAuthenticated = true,&#13;&#10;                        currentUser = user,&#13;&#10;                        isEmailAuthLoading = false,&#13;&#10;                        isAuthResolved = true,&#13;&#10;                        hasLoggedIn = true&#13;&#10;                    )&#13;&#10;                    AuthPrefs.setHasLoggedIn(context, true)&#13;&#10;                }.onFailure { e -&gt;&#13;&#10;                    _uiState.value = _uiState.value.copy(&#13;&#10;                        isEmailAuthLoading = false,&#13;&#10;                        errorMessage = &quot;Failed to create user profile: ${e.message}&quot;,&#13;&#10;                        isAuthResolved = true&#13;&#10;                    )&#13;&#10;                }&#13;&#10;            }.onFailure { e -&gt;&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    isEmailAuthLoading = false,&#13;&#10;                    errorMessage = &quot;Sign up failed: ${e.message}&quot;,&#13;&#10;                    isAuthResolved = true&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun signIn(email: String, password: String) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            _uiState.value = _uiState.value.copy(isEmailAuthLoading = true)&#13;&#10;&#13;&#10;            val result = authRepository.signIn(email, password)&#13;&#10;            result.onSuccess {&#13;&#10;                _uiState.value = _uiState.value.copy(isEmailAuthLoading = false)&#13;&#10;                // Flag will be set once loadCurrentUser runs; set preemptively too&#13;&#10;                AuthPrefs.setHasLoggedIn(context, true)&#13;&#10;                _uiState.value = _uiState.value.copy(hasLoggedIn = true)&#13;&#10;            }.onFailure { e -&gt;&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    isEmailAuthLoading = false,&#13;&#10;                    errorMessage = &quot;Sign in failed: ${e.message}&quot;,&#13;&#10;                    isAuthResolved = true&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun signInWithGoogle(idToken: String) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            _uiState.value = _uiState.value.copy(isGoogleAuthLoading = true)&#13;&#10;&#13;&#10;            val authResult = authRepository.signInWithGoogle(idToken)&#13;&#10;            authResult.onSuccess { firebaseUser -&gt;&#13;&#10;                // Check if user exists in Firestore&#13;&#10;                val userResult = userRepository.getUser(firebaseUser.uid)&#13;&#10;&#13;&#10;                userResult.onSuccess { user -&gt;&#13;&#10;                    // User already exists&#13;&#10;                    _uiState.value = _uiState.value.copy(&#13;&#10;                        isAuthenticated = true,&#13;&#10;                        currentUser = user,&#13;&#10;                        isGoogleAuthLoading = false,&#13;&#10;                        isAuthResolved = true,&#13;&#10;                        hasLoggedIn = true&#13;&#10;                    )&#13;&#10;                    AuthPrefs.setHasLoggedIn(context, true)&#13;&#10;                }.onFailure {&#13;&#10;                    // Create new user profile&#13;&#10;                    val createResult = userRepository.createUser(&#13;&#10;                        userId = firebaseUser.uid,&#13;&#10;                        email = firebaseUser.email ?: &quot;&quot;,&#13;&#10;                        username = firebaseUser.displayName ?: &quot;User&quot;&#13;&#10;                    )&#13;&#10;&#13;&#10;                    createResult.onSuccess { user -&gt;&#13;&#10;                        _uiState.value = _uiState.value.copy(&#13;&#10;                            isAuthenticated = true,&#13;&#10;                            currentUser = user,&#13;&#10;                            isGoogleAuthLoading = false,&#13;&#10;                            isAuthResolved = true,&#13;&#10;                            hasLoggedIn = true&#13;&#10;                        )&#13;&#10;                        AuthPrefs.setHasLoggedIn(context, true)&#13;&#10;                    }.onFailure { e -&gt;&#13;&#10;                        _uiState.value = _uiState.value.copy(&#13;&#10;                            isGoogleAuthLoading = false,&#13;&#10;                            errorMessage = &quot;Failed to create user profile: ${e.message}&quot;,&#13;&#10;                            isAuthResolved = true&#13;&#10;                        )&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }.onFailure { e -&gt;&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    isGoogleAuthLoading = false,&#13;&#10;                    errorMessage = &quot;Google sign in failed: ${e.message}&quot;,&#13;&#10;                    isAuthResolved = true&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun signOut() {&#13;&#10;        authRepository.signOut()&#13;&#10;        viewModelScope.launch { AuthPrefs.setHasLoggedIn(context, false) }&#13;&#10;        _uiState.value = AppUiState()&#13;&#10;    }&#13;&#10;&#13;&#10;    fun updateProfile(username: String, bio: String, imageUri: Uri?) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            val userId = _uiState.value.currentUser?.id ?: return@launch&#13;&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#13;&#10;&#13;&#10;            try {&#13;&#10;                var profilePictureUrl: String? = null&#13;&#10;&#13;&#10;                if (imageUri != null) {&#13;&#10;                    val uploadResult = userRepository.uploadProfilePicture(imageUri)&#13;&#10;                    uploadResult.onSuccess { url -&gt;&#13;&#10;                        profilePictureUrl = url&#13;&#10;                    }&#13;&#10;                }&#13;&#10;&#13;&#10;                val updateRequest = UpdateUserRequest(&#13;&#10;                    username = username,&#13;&#10;                    bio = bio,&#13;&#10;                    profilePictureUrl = profilePictureUrl&#13;&#10;                )&#13;&#10;&#13;&#10;                val result = userRepository.updateUser(userId, updateRequest)&#13;&#10;                result.onSuccess {&#13;&#10;                    // Update profile picture in all existing secrets and comments&#13;&#10;                    if (profilePictureUrl != null) {&#13;&#10;                        secretRepository.updateUserProfilePictureInPosts(userId, profilePictureUrl)&#13;&#10;                    }&#13;&#10;&#13;&#10;                    loadCurrentUser(userId)&#13;&#10;                    _uiState.value = _uiState.value.copy(isLoading = false)&#13;&#10;                }.onFailure { e -&gt;&#13;&#10;                    _uiState.value = _uiState.value.copy(&#13;&#10;                        isLoading = false,&#13;&#10;                        errorMessage = &quot;Failed to update profile: ${e.message}&quot;&#13;&#10;                    )&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    isLoading = false,&#13;&#10;                    errorMessage = &quot;Error: ${e.message}&quot;&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun updateLocation() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                println(&quot;DEBUG: Starting location update...&quot;)&#13;&#10;&#13;&#10;                if (!locationHelper.hasLocationPermission()) {&#13;&#10;                    println(&quot;DEBUG: Location permission not granted - skipping location update&quot;)&#13;&#10;                    // Don't set any location - let the UI handle permission request&#13;&#10;                    return@launch&#13;&#10;                }&#13;&#10;&#13;&#10;                if (!locationHelper.isLocationEnabled()) {&#13;&#10;                    println(&quot;DEBUG: Location services not enabled - skipping location update&quot;)&#13;&#10;                    // Don't set any location - let the UI handle this&#13;&#10;                    return@launch&#13;&#10;                }&#13;&#10;&#13;&#10;                println(&quot;DEBUG: Fetching location...&quot;)&#13;&#10;                val location = locationHelper.getCurrentLocation()&#13;&#10;&#13;&#10;                if (location == null) {&#13;&#10;                    println(&quot;DEBUG: Location is null - could not fetch location&quot;)&#13;&#10;                    return@launch&#13;&#10;                }&#13;&#10;&#13;&#10;                println(&quot;DEBUG: ✅ Location obtained - Lat: ${location.latitude}, Lng: ${location.longitude}&quot;)&#13;&#10;                _uiState.value = _uiState.value.copy(currentLocation = location)&#13;&#10;&#13;&#10;                // Fetch nearby secrets with the obtained location&#13;&#10;                fetchNearbySecrets(location.latitude, location.longitude)&#13;&#10;&#13;&#10;            } catch (e: Exception) {&#13;&#10;                println(&quot;DEBUG: ❌ Location error - ${e.message}&quot;)&#13;&#10;                e.printStackTrace()&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun fetchNearbySecrets(latitude: Double, longitude: Double) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#13;&#10;&#13;&#10;            val result = secretRepository.getNearbySecrets(latitude, longitude)&#13;&#10;&#13;&#10;            result.onSuccess { secrets -&gt;&#13;&#10;                val secretsWithDistance = secrets.map { secret -&gt;&#13;&#10;                    val distance = LocationHelper.calculateDistance(&#13;&#10;                        latitude, longitude,&#13;&#10;                        secret.latitude, secret.longitude&#13;&#10;                    )&#13;&#10;                    secret.copy(distance = distance)&#13;&#10;                }&#13;&#10;&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    secrets = secretsWithDistance,&#13;&#10;                    isLoading = false&#13;&#10;                )&#13;&#10;            }.onFailure { e -&gt;&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    isLoading = false,&#13;&#10;                    errorMessage = &quot;Failed to fetch secrets: ${e.message}&quot;&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun createSecret(text: String, imageUri: Uri?, isAnonymous: Boolean, mood: String? = null, category: String? = null, hashtags: String? = null) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            val location = _uiState.value.currentLocation&#13;&#10;            val user = _uiState.value.currentUser&#13;&#10;&#13;&#10;            if (location == null) {&#13;&#10;                _uiState.value = _uiState.value.copy(errorMessage = &quot;Location not available&quot;)&#13;&#10;                return@launch&#13;&#10;            }&#13;&#10;&#13;&#10;            if (user == null) {&#13;&#10;                _uiState.value = _uiState.value.copy(errorMessage = &quot;User not authenticated&quot;)&#13;&#10;                return@launch&#13;&#10;            }&#13;&#10;&#13;&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#13;&#10;&#13;&#10;            val result = secretRepository.createSecret(&#13;&#10;                text = text,&#13;&#10;                imageUri = imageUri,&#13;&#10;                latitude = location.latitude,&#13;&#10;                longitude = location.longitude,&#13;&#10;                username = user.username,&#13;&#10;                userProfilePicture = user.profilePictureUrl,&#13;&#10;                isAnonymous = isAnonymous,&#13;&#10;                mood = mood,&#13;&#10;                category = category,&#13;&#10;                hashtags = hashtags&#13;&#10;            )&#13;&#10;&#13;&#10;            result.onSuccess {&#13;&#10;                _uiState.value = _uiState.value.copy(isLoading = false)&#13;&#10;                fetchNearbySecrets(location.latitude, location.longitude)&#13;&#10;            }.onFailure { e -&gt;&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    isLoading = false,&#13;&#10;                    errorMessage = &quot;Failed to post secret: ${e.message}&quot;&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // New function to create secret with multiple images&#13;&#10;    fun createSecretWithMultipleImages(&#13;&#10;        text: String,&#13;&#10;        imageUris: List&lt;Uri&gt;,&#13;&#10;        isAnonymous: Boolean,&#13;&#10;        mood: String? = null,&#13;&#10;        category: String? = null,&#13;&#10;        hashtags: String? = null&#13;&#10;    ) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            val location = _uiState.value.currentLocation&#13;&#10;            val user = _uiState.value.currentUser&#13;&#10;&#13;&#10;            if (location == null) {&#13;&#10;                _uiState.value = _uiState.value.copy(errorMessage = &quot;Location not available&quot;)&#13;&#10;                return@launch&#13;&#10;            }&#13;&#10;&#13;&#10;            if (user == null) {&#13;&#10;                _uiState.value = _uiState.value.copy(errorMessage = &quot;User not authenticated&quot;)&#13;&#10;                return@launch&#13;&#10;            }&#13;&#10;&#13;&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#13;&#10;&#13;&#10;            val result = secretRepository.createSecretWithMultipleImages(&#13;&#10;                text = text,&#13;&#10;                imageUris = imageUris,&#13;&#10;                latitude = location.latitude,&#13;&#10;                longitude = location.longitude,&#13;&#10;                username = user.username,&#13;&#10;                userProfilePicture = user.profilePictureUrl,&#13;&#10;                isAnonymous = isAnonymous,&#13;&#10;                mood = mood,&#13;&#10;                category = category,&#13;&#10;                hashtags = hashtags&#13;&#10;            )&#13;&#10;&#13;&#10;            result.onSuccess {&#13;&#10;                _uiState.value = _uiState.value.copy(isLoading = false)&#13;&#10;                fetchNearbySecrets(location.latitude, location.longitude)&#13;&#10;            }.onFailure { e -&gt;&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    isLoading = false,&#13;&#10;                    errorMessage = &quot;Failed to post secret: ${e.message}&quot;&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun createStory(imageUri: Uri?, caption: String?) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            val user = _uiState.value.currentUser&#13;&#10;&#13;&#10;            if (user == null) {&#13;&#10;                _uiState.value = _uiState.value.copy(errorMessage = &quot;User not authenticated&quot;)&#13;&#10;                return@launch&#13;&#10;            }&#13;&#10;&#13;&#10;            // Allow stories without images - text-only stories are now supported&#13;&#10;            if (imageUri == null &amp;&amp; caption.isNullOrBlank()) {&#13;&#10;                _uiState.value = _uiState.value.copy(errorMessage = &quot;Story requires either an image or text&quot;)&#13;&#10;                return@launch&#13;&#10;            }&#13;&#10;&#13;&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#13;&#10;&#13;&#10;            val result = storyRepository.createStory(&#13;&#10;                imageUri = imageUri,&#13;&#10;                caption = caption,&#13;&#10;                username = user.username,&#13;&#10;                userProfilePicture = user.profilePictureUrl&#13;&#10;            )&#13;&#10;&#13;&#10;            result.onSuccess {&#13;&#10;                _uiState.value = _uiState.value.copy(isLoading = false)&#13;&#10;                // Reload user's stories after creating a new one&#13;&#10;                loadMyStories()&#13;&#10;            }.onFailure { e -&gt;&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    isLoading = false,&#13;&#10;                    errorMessage = &quot;Failed to post story: ${e.message}&quot;&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun loadMyStories() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            val userId = _uiState.value.currentUser?.id ?: return@launch&#13;&#10;&#13;&#10;            val result = storyRepository.getUserStories(userId)&#13;&#10;            result.onSuccess { stories -&gt;&#13;&#10;                _uiState.value = _uiState.value.copy(myStories = stories)&#13;&#10;            }.onFailure { e -&gt;&#13;&#10;                println(&quot;DEBUG: Failed to load stories: ${e.message}&quot;)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun loadUserStories(userId: String) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            println(&quot;DEBUG: loadUserStories called for userId: $userId&quot;)&#13;&#10;            val result = storyRepository.getUserStories(userId)&#13;&#10;            result.onSuccess { stories -&gt;&#13;&#10;                println(&quot;DEBUG: Successfully loaded ${stories.size} stories&quot;)&#13;&#10;                stories.forEach { story -&gt;&#13;&#10;                    println(&quot;DEBUG: Story - id: ${story.id}, imageUrl: ${story.imageUrl}&quot;)&#13;&#10;                }&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    selectedUserStories = stories,&#13;&#10;                    currentStoryIndex = 0&#13;&#10;                )&#13;&#10;                println(&quot;DEBUG: UI state updated with stories&quot;)&#13;&#10;            }.onFailure { e -&gt;&#13;&#10;                println(&quot;DEBUG: Failed to load stories: ${e.message}&quot;)&#13;&#10;                e.printStackTrace()&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    errorMessage = &quot;Failed to load stories: ${e.message}&quot;&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun nextStory() {&#13;&#10;        val currentIndex = _uiState.value.currentStoryIndex&#13;&#10;        val storiesCount = _uiState.value.selectedUserStories.size&#13;&#10;        if (currentIndex &lt; storiesCount - 1) {&#13;&#10;            _uiState.value = _uiState.value.copy(currentStoryIndex = currentIndex + 1)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun previousStory() {&#13;&#10;        val currentIndex = _uiState.value.currentStoryIndex&#13;&#10;        if (currentIndex &gt; 0) {&#13;&#10;            _uiState.value = _uiState.value.copy(currentStoryIndex = currentIndex - 1)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun clearSelectedStories() {&#13;&#10;        _uiState.value = _uiState.value.copy(&#13;&#10;            selectedUserStories = emptyList(),&#13;&#10;            currentStoryIndex = 0&#13;&#10;        )&#13;&#10;    }&#13;&#10;&#13;&#10;    fun toggleLike(secret: Secret) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            val user = _uiState.value.currentUser ?: return@launch&#13;&#10;&#13;&#10;            val result = secretRepository.toggleLike(secret.id, user.username)&#13;&#10;            result.onSuccess { isLiked -&gt;&#13;&#10;                // Update the secret in the list&#13;&#10;                val updatedSecrets = _uiState.value.secrets.map { s -&gt;&#13;&#10;                    if (s.id == secret.id) {&#13;&#10;                        s.copy(&#13;&#10;                            isLikedByCurrentUser = isLiked,&#13;&#10;                            likeCount = if (isLiked) s.likeCount + 1 else maxOf(0, s.likeCount - 1)&#13;&#10;                        )&#13;&#10;                    } else s&#13;&#10;                }&#13;&#10;                _uiState.value = _uiState.value.copy(secrets = updatedSecrets)&#13;&#10;&#13;&#10;                // Update selected secret if it's the same&#13;&#10;                if (_uiState.value.selectedSecret?.id == secret.id) {&#13;&#10;                    loadSecretDetails(secret.id)&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun selectSecret(secret: Secret?) {&#13;&#10;        _uiState.value = _uiState.value.copy(selectedSecret = secret)&#13;&#10;        secret?.let { loadSecretDetails(it.id) }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun loadSecretDetails(secretId: String) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            val commentsResult = secretRepository.getComments(secretId)&#13;&#10;            val likesResult = secretRepository.getLikes(secretId)&#13;&#10;&#13;&#10;            commentsResult.onSuccess { comments -&gt;&#13;&#10;                _uiState.value = _uiState.value.copy(selectedSecretComments = comments)&#13;&#10;            }&#13;&#10;&#13;&#10;            likesResult.onSuccess { likes -&gt;&#13;&#10;                _uiState.value = _uiState.value.copy(selectedSecretLikes = likes)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun addComment(secretId: String, text: String) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            val user = _uiState.value.currentUser ?: return@launch&#13;&#10;&#13;&#10;            println(&quot;DEBUG: Adding comment for secret $secretId&quot;)&#13;&#10;&#13;&#10;            val result = secretRepository.addComment(&#13;&#10;                secretId = secretId,&#13;&#10;                text = text,&#13;&#10;                username = user.username,&#13;&#10;                userProfilePicture = user.profilePictureUrl&#13;&#10;            )&#13;&#10;&#13;&#10;            result.onSuccess { newComment -&gt;&#13;&#10;                println(&quot;DEBUG: Comment added successfully: ${newComment.text}&quot;)&#13;&#10;&#13;&#10;                // Add small delay to ensure Firebase propagates the comment&#13;&#10;                kotlinx.coroutines.delay(800)&#13;&#10;&#13;&#10;                println(&quot;DEBUG: Reloading secret details...&quot;)&#13;&#10;                // Reload comments and likes&#13;&#10;                val commentsResult = secretRepository.getComments(secretId)&#13;&#10;                val likesResult = secretRepository.getLikes(secretId)&#13;&#10;&#13;&#10;                commentsResult.onSuccess { comments -&gt;&#13;&#10;                    println(&quot;DEBUG: Loaded ${comments.size} comments&quot;)&#13;&#10;                    _uiState.value = _uiState.value.copy(selectedSecretComments = comments)&#13;&#10;                }&#13;&#10;&#13;&#10;                likesResult.onSuccess { likes -&gt;&#13;&#10;                    _uiState.value = _uiState.value.copy(selectedSecretLikes = likes)&#13;&#10;                }&#13;&#10;&#13;&#10;                // Update comment count in the secrets list&#13;&#10;                val updatedSecrets = _uiState.value.secrets.map { s -&gt;&#13;&#10;                    if (s.id == secretId) {&#13;&#10;                        s.copy(commentCount = s.commentCount + 1)&#13;&#10;                    } else s&#13;&#10;                }&#13;&#10;&#13;&#10;                // Update the selected secret with new comment count&#13;&#10;                val updatedSelectedSecret = _uiState.value.selectedSecret?.let { secret -&gt;&#13;&#10;                    if (secret.id == secretId) {&#13;&#10;                        secret.copy(commentCount = secret.commentCount + 1)&#13;&#10;                    } else secret&#13;&#10;                }&#13;&#10;&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    secrets = updatedSecrets,&#13;&#10;                    selectedSecret = updatedSelectedSecret&#13;&#10;                )&#13;&#10;&#13;&#10;                println(&quot;DEBUG: UI state updated with ${_uiState.value.selectedSecretComments.size} comments&quot;)&#13;&#10;            }.onFailure { e -&gt;&#13;&#10;                println(&quot;DEBUG: Failed to add comment: ${e.message}&quot;)&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    errorMessage = &quot;Failed to add comment: ${e.message}&quot;&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun loadMySecrets() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            val userId = _uiState.value.currentUser?.id ?: return@launch&#13;&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#13;&#10;&#13;&#10;            val result = secretRepository.getUserSecrets(userId)&#13;&#10;            result.onSuccess { secrets -&gt;&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    mySecrets = secrets,&#13;&#10;                    isLoading = false&#13;&#10;                )&#13;&#10;            }.onFailure { e -&gt;&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    isLoading = false,&#13;&#10;                    errorMessage = &quot;Failed to load your secrets: ${e.message}&quot;&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun clearError() {&#13;&#10;        _uiState.value = _uiState.value.copy(errorMessage = null)&#13;&#10;    }&#13;&#10;&#13;&#10;    // Profile Viewer functions&#13;&#10;    fun loadUserProfile(userId: String) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#13;&#10;&#13;&#10;            // Load user profile&#13;&#10;            val userResult = userRepository.getUser(userId)&#13;&#10;            userResult.onSuccess { user -&gt;&#13;&#10;                _uiState.value = _uiState.value.copy(selectedUser = user)&#13;&#10;            }.onFailure { e -&gt;&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    errorMessage = &quot;Failed to load user profile: ${e.message}&quot;&#13;&#10;                )&#13;&#10;            }&#13;&#10;&#13;&#10;            // Load user's secrets&#13;&#10;            val secretsResult = secretRepository.getUserSecrets(userId)&#13;&#10;            secretsResult.onSuccess { secrets -&gt;&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    selectedUserSecrets = secrets,&#13;&#10;                    isLoading = false&#13;&#10;                )&#13;&#10;            }.onFailure { e -&gt;&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    isLoading = false,&#13;&#10;                    errorMessage = &quot;Failed to load user posts: ${e.message}&quot;&#13;&#10;                )&#13;&#10;            }&#13;&#10;&#13;&#10;            // TODO: Load follow/friend status when backend supports it&#13;&#10;            // For now, set to default values&#13;&#10;            _uiState.value = _uiState.value.copy(&#13;&#10;                isFollowing = false,&#13;&#10;                isFriend = false,&#13;&#10;                friendRequestSent = false&#13;&#10;            )&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun clearSelectedUser() {&#13;&#10;        _uiState.value = _uiState.value.copy(&#13;&#10;            selectedUser = null,&#13;&#10;            selectedUserSecrets = emptyList(),&#13;&#10;            isFollowing = false,&#13;&#10;            isFriend = false,&#13;&#10;            friendRequestSent = false&#13;&#10;        )&#13;&#10;    }&#13;&#10;&#13;&#10;    fun toggleFollow() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            // TODO: Implement follow/unfollow when backend supports it&#13;&#10;            val currentlyFollowing = _uiState.value.isFollowing&#13;&#10;            _uiState.value = _uiState.value.copy(isFollowing = !currentlyFollowing)&#13;&#10;&#13;&#10;            // Show feedback&#13;&#10;            _uiState.value = _uiState.value.copy(&#13;&#10;                errorMessage = if (!currentlyFollowing) &quot;Following user&quot; else &quot;Unfollowed user&quot;&#13;&#10;            )&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun sendFriendRequest() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            // TODO: Implement friend request when backend supports it&#13;&#10;            _uiState.value = _uiState.value.copy(friendRequestSent = true)&#13;&#10;&#13;&#10;            // Show feedback&#13;&#10;            _uiState.value = _uiState.value.copy(&#13;&#10;                errorMessage = &quot;Friend request sent&quot;&#13;&#10;            )&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>