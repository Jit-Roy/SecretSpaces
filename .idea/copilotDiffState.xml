<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/FIREBASE_STORAGE_SETUP.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FIREBASE_STORAGE_SETUP.md" />
              <option name="updatedContent" value="# Firebase Storage Setup Documentation&#10;&#10;## Overview&#10;This document describes the Firebase Storage setup for handling images in the Secret Spaces Android app.&#10;&#10;## Storage Structure&#10;&#10;The Firebase Storage is organized into three main directories:&#10;&#10;### 1. Profile Pictures&#10;- **Path**: `profile_pictures/{userId}/profile_{timestamp}.jpg`&#10;- **Purpose**: Store user profile pictures&#10;- **Access**: &#10;  - Read: Public (anyone can view)&#10;  - Write: Owner only&#10;  - Delete: Owner only&#10;&#10;### 2. Post/Secret Images&#10;- **Path**: `post_images/{userId}/{postId}_{timestamp}.jpg`&#10;- **Purpose**: Store images attached to posts/secrets&#10;- **Access**:&#10;  - Read: Public (anyone can view)&#10;  - Create: Owner only&#10;  - Delete: Owner only&#10;  - Update: Not allowed (immutable)&#10;&#10;### 3. Story Images&#10;- **Path**: `story_images/{userId}/story_{timestamp}.jpg`&#10;- **Purpose**: Store temporary story images (24-hour expiration)&#10;- **Access**:&#10;  - Read: Public (anyone can view)&#10;  - Create: Owner only&#10;  - Delete: Owner only&#10;  - Update: Not allowed (immutable)&#10;&#10;## Implementation&#10;&#10;### FirebaseStorageManager Class&#10;&#10;Located at: `com.secretspaces32.android.data.storage.FirebaseStorageManager`&#10;&#10;This centralized manager handles all image upload operations with the following features:&#10;&#10;#### Key Methods&#10;&#10;1. **`uploadProfilePicture(imageUri: Uri): Result&lt;String&gt;`**&#10;   - Uploads a user's profile picture&#10;   - Returns the download URL&#10;&#10;2. **`uploadPostImage(imageUri: Uri, postId: String?): Result&lt;String&gt;`**&#10;   - Uploads an image for a post/secret&#10;   - Returns the download URL&#10;&#10;3. **`uploadStoryImage(imageUri: Uri): Result&lt;String&gt;`**&#10;   - Uploads a story image with 24-hour expiration metadata&#10;   - Returns the download URL&#10;&#10;4. **`deleteImage(imageUrl: String): Result&lt;Unit&gt;`**&#10;   - Deletes a specific image by URL&#10;&#10;5. **`deleteUserProfilePictures(userId: String): Result&lt;Unit&gt;`**&#10;   - Deletes all profile pictures for a user&#10;&#10;6. **`deleteUserPosts(userId: String): Result&lt;Unit&gt;`**&#10;   - Deletes all post images for a user&#10;&#10;7. **`deleteUserStories(userId: String): Result&lt;Unit&gt;`**&#10;   - Deletes all story images for a user&#10;&#10;8. **`deleteExpiredStories(userId: String): Result&lt;Int&gt;`**&#10;   - Cleans up story images older than 24 hours&#10;   - Returns count of deleted items&#10;&#10;#### Features&#10;&#10;- **Automatic Authentication**: Verifies user is logged in before operations&#10;- **Metadata Tracking**: Stores upload timestamp, user ID, and image type&#10;- **Type Safety**: Uses enum for image types (PROFILE, POST, STORY)&#10;- **Error Handling**: Returns `Result&lt;T&gt;` for proper error management&#10;- **Organized Structure**: Maintains clean folder hierarchy&#10;&#10;## Repository Integration&#10;&#10;### FirebaseUserRepository&#10;- Uses `storageManager.uploadProfilePicture()` for profile pictures&#10;&#10;### FirebaseSecretRepository&#10;- Uses `storageManager.uploadPostImage()` for post/secret images&#10;&#10;### FirebaseStoryRepository (NEW)&#10;- Uses `storageManager.uploadStoryImage()` for story images&#10;- Includes automatic cleanup of expired stories&#10;- Tracks story views and view counts&#10;&#10;## Security Rules&#10;&#10;The `storage.rules` file in the project root defines Firebase Storage security:&#10;&#10;```&#10;rules_version = '2';&#10;&#10;service firebase.storage {&#10;  match /b/{bucket}/o {&#10;    &#10;    // Profile Pictures&#10;    match /profile_pictures/{userId}/{filename} {&#10;      allow read: if true;&#10;      allow write: if request.auth.uid == userId &amp;&amp; isValidImage();&#10;      allow delete: if request.auth.uid == userId;&#10;    }&#10;    &#10;    // Post Images&#10;    match /post_images/{userId}/{filename} {&#10;      allow read: if true;&#10;      allow create: if request.auth.uid == userId &amp;&amp; isValidImage();&#10;      allow delete: if request.auth.uid == userId;&#10;      allow update: if false;&#10;    }&#10;    &#10;    // Story Images&#10;    match /story_images/{userId}/{filename} {&#10;      allow read: if true;&#10;      allow create: if request.auth.uid == userId &amp;&amp; isValidImage();&#10;      allow delete: if request.auth.uid == userId;&#10;      allow update: if false;&#10;    }&#10;  }&#10;}&#10;```&#10;&#10;### Key Security Features:&#10;- Maximum file size: 10MB&#10;- Allowed formats: JPEG, JPG, PNG, WebP&#10;- Users can only upload to their own directories&#10;- All images are publicly readable&#10;- Users cannot modify existing images (immutable)&#10;&#10;## Deployment Steps&#10;&#10;### 1. Deploy Storage Rules to Firebase&#10;&#10;Using Firebase CLI:&#10;```bash&#10;firebase deploy --only storage&#10;```&#10;&#10;Or manually in Firebase Console:&#10;1. Go to Firebase Console&#10;2. Navigate to Storage → Rules&#10;3. Copy contents from `storage.rules` file&#10;4. Publish the rules&#10;&#10;### 2. Configure Firebase Storage in App&#10;&#10;The storage is already initialized in the repositories. Make sure your `google-services.json` is properly configured.&#10;&#10;### 3. Enable Firebase Storage&#10;&#10;In Firebase Console:&#10;1. Go to Storage section&#10;2. Click &quot;Get Started&quot;&#10;3. Choose your security rules mode&#10;4. Select your storage location (choose closest to your users)&#10;&#10;## Usage Examples&#10;&#10;### Upload Profile Picture&#10;```kotlin&#10;val repository = FirebaseUserRepository()&#10;val result = repository.uploadProfilePicture(userId, imageUri)&#10;&#10;result.onSuccess { downloadUrl -&gt;&#10;    // Update user profile with downloadUrl&#10;}&#10;result.onFailure { error -&gt;&#10;    // Handle error&#10;}&#10;```&#10;&#10;### Upload Post Image&#10;```kotlin&#10;val repository = FirebaseSecretRepository()&#10;// Image upload is handled automatically in createSecret()&#10;val result = repository.createSecret(&#10;    text = &quot;My secret&quot;,&#10;    imageUri = imageUri,&#10;    latitude = lat,&#10;    longitude = lng,&#10;    username = username,&#10;    userProfilePicture = profilePic,&#10;    isAnonymous = false&#10;)&#10;```&#10;&#10;### Create Story&#10;```kotlin&#10;val repository = FirebaseStoryRepository()&#10;val result = repository.createStory(&#10;    imageUri = imageUri,&#10;    caption = &quot;My story&quot;,&#10;    username = username,&#10;    userProfilePicture = profilePic&#10;)&#10;```&#10;&#10;### Clean Up Expired Stories&#10;```kotlin&#10;val repository = FirebaseStoryRepository()&#10;val result = repository.cleanupExpiredStories()&#10;&#10;result.onSuccess { deletedCount -&gt;&#10;    println(&quot;Cleaned up $deletedCount expired stories&quot;)&#10;}&#10;```&#10;&#10;## Best Practices&#10;&#10;1. **Image Optimization**: Compress images before upload to reduce storage costs&#10;2. **Cleanup**: Regularly run cleanup tasks for expired stories&#10;3. **Error Handling**: Always handle upload failures gracefully&#10;4. **Loading States**: Show progress indicators during uploads&#10;5. **Caching**: Use Glide or Coil for efficient image loading and caching&#10;6. **Permissions**: Request storage permissions before image selection&#10;&#10;## Maintenance&#10;&#10;### Periodic Cleanup Task&#10;Consider implementing a background worker to clean up expired stories:&#10;&#10;```kotlin&#10;// Using WorkManager&#10;class CleanupStoriesWorker(context: Context, params: WorkerParameters) &#10;    : CoroutineWorker(context, params) {&#10;    &#10;    override suspend fun doWork(): Result {&#10;        val repository = FirebaseStoryRepository()&#10;        repository.cleanupExpiredStories()&#10;        return Result.success()&#10;    }&#10;}&#10;&#10;// Schedule daily cleanup&#10;val cleanupRequest = PeriodicWorkRequestBuilder&lt;CleanupStoriesWorker&gt;(&#10;    24, TimeUnit.HOURS&#10;).build()&#10;&#10;WorkManager.getInstance(context).enqueue(cleanupRequest)&#10;```&#10;&#10;## Troubleshooting&#10;&#10;### Common Issues&#10;&#10;1. **Upload Fails with Permission Denied**&#10;   - Verify security rules are deployed&#10;   - Check user is authenticated&#10;   - Confirm user ID matches the path&#10;&#10;2. **Image Not Appearing**&#10;   - Verify download URL is saved to Firestore&#10;   - Check image loading library configuration&#10;   - Verify storage bucket is accessible&#10;&#10;3. **Large Upload Times**&#10;   - Compress images before upload&#10;   - Check network connection&#10;   - Consider using lower resolution for thumbnails&#10;&#10;## Cost Optimization&#10;&#10;- **Storage**: ~$0.026/GB per month&#10;- **Downloads**: ~$0.12/GB&#10;- **Uploads**: Free&#10;&#10;Tips to reduce costs:&#10;1. Delete expired content regularly&#10;2. Use appropriate image quality/size&#10;3. Implement image compression&#10;4. Use CDN caching where possible&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MULTIPLE_IMAGES_IMPLEMENTATION.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MULTIPLE_IMAGES_IMPLEMENTATION.md" />
              <option name="updatedContent" value="# Multiple Images Feature Implementation Summary&#10;&#10;## Problem Fixed&#10;Previously, when users selected multiple images to post, only one image was displayed in the feed screen. Now all selected images are properly displayed with a carousel/swipe functionality.&#10;&#10;## Changes Made&#10;&#10;### 1. Data Model Updates (`Secret.kt`)&#10;- Added `imageUrls: List&lt;String&gt;?` field to support multiple images&#10;- Kept `imageUrl: String?` for backward compatibility&#10;- Added `imageBase64List: List&lt;String&gt;?` to `CreateSecretRequest` for uploading multiple images&#10;&#10;### 2. Feed UI Components (`FeedComponents.kt`)&#10;- Updated `FeedSecretCard` to display multiple images with a carousel&#10;- Added horizontal pager for swiping between images&#10;- Added page counter (e.g., &quot;1/3&quot;) in top-right corner&#10;- Added dot indicators at the bottom showing current page&#10;- Single images display as before without pagination UI&#10;- All images are clickable to open full-screen viewer&#10;&#10;### 3. New Image Viewer Screen (`ImageViewerScreen.kt`)&#10;- Full-screen image viewing with black background&#10;- Horizontal swipe/pager to navigate between images&#10;- Page counter showing current position (e.g., &quot;1 / 3&quot;)&#10;- Dot indicators at bottom for visual navigation&#10;- Back button to return to feed&#10;- Fits images to screen while maintaining aspect ratio&#10;&#10;### 4. Navigation Updates&#10;- Added `ImageViewer` to Screen enum&#10;- Added image viewer state variables (`imageViewerUrls`, `imageViewerInitialPage`)&#10;- Wired up navigation from feed → image viewer → back to feed&#10;- Passed `onImageClick` callback through all layers:&#10;  - SecretSpacesApp → MainScreenContainer → FeedScreen → FeedSecretCard&#10;&#10;### 5. Feed Screen Updates (`FeedScreen.kt`)&#10;- Added `onImageClick` parameter to handle image clicks&#10;- Passes callback to `FeedSecretCard` component&#10;&#10;### 6. MainScreenContainer Updates&#10;- Added `onImageClick` parameter&#10;- Passes callback through to FeedScreen&#10;&#10;## User Experience&#10;&#10;### Viewing Multiple Images in Feed:&#10;1. Posts with multiple images show in a carousel format&#10;2. Swipe left/right to see all images&#10;3. Page counter shows &quot;2/5&quot; (current/total) in top-right&#10;4. Dot indicators at bottom show position visually&#10;5. Posts with single images display as before (no pagination UI)&#10;&#10;### Full-Screen Image Viewer:&#10;1. Tap any image in feed to open full-screen viewer&#10;2. Opens to the exact image you tapped&#10;3. Swipe left/right to view all images&#10;4. Page counter and dots help with navigation&#10;5. Tap back button to return to feed&#10;&#10;## UI Design Features&#10;- **Carousel**: Smooth horizontal swipe between images&#10;- **Page Counter**: Semi-transparent badge showing &quot;1/3&quot;&#10;- **Dot Indicators**: White dots at bottom (active is solid, others are transparent)&#10;- **Click to Expand**: Tap any image to view full-screen&#10;- **Black Background**: Full-screen viewer uses black for better focus&#10;- **Gradient Overlay**: Subtle gradient on feed images for better visibility&#10;&#10;## Backend Note&#10;The `CreateSecretRequest` now supports `imageBase64List` for uploading multiple images. You'll need to update your backend API to:&#10;1. Accept multiple images in the create secret endpoint&#10;2. Store multiple image URLs in the database&#10;3. Return `imageUrls` array in the API response&#10;&#10;The app maintains backward compatibility - it will work with existing posts that only have `imageUrl` set.&#10;&#10;## Similar to Facebook/Instagram&#10;- Swipe through multiple photos in a post&#10;- Tap to view full-screen&#10;- Visual indicators showing which photo you're viewing&#10;- Smooth animations and transitions&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/QUICK_SETUP_STORAGE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/QUICK_SETUP_STORAGE.md" />
              <option name="updatedContent" value="# Quick Setup Guide - Firebase Storage&#10;&#10;## What Has Been Set Up&#10;&#10;✅ **FirebaseStorageManager** - Centralized image upload manager&#10;✅ **Story Model &amp; Repository** - Complete story feature with 24-hour expiration&#10;✅ **Updated Repositories** - User and Secret repositories now use the centralized storage&#10;✅ **Security Rules** - Firebase Storage rules for proper access control&#10;&#10;## Files Created/Modified&#10;&#10;### New Files:&#10;1. `app/src/main/java/com/secretspaces32/android/data/storage/FirebaseStorageManager.kt`&#10;2. `app/src/main/java/com/secretspaces32/android/data/model/Story.kt`&#10;3. `app/src/main/java/com/secretspaces32/android/data/repository/FirebaseStoryRepository.kt`&#10;4. `storage.rules` - Firebase Storage security rules&#10;5. `FIREBASE_STORAGE_SETUP.md` - Complete documentation&#10;&#10;### Modified Files:&#10;1. `app/src/main/java/com/secretspaces32/android/data/repository/FirebaseUserRepository.kt`&#10;2. `app/src/main/java/com/secretspaces32/android/data/repository/FirebaseSecretRepository.kt`&#10;&#10;## Next Steps&#10;&#10;### 1. Deploy Firebase Storage Rules&#10;&#10;Open terminal and run:&#10;```bash&#10;firebase login&#10;firebase init storage  # if not already initialized&#10;firebase deploy --only storage&#10;```&#10;&#10;Or deploy manually:&#10;1. Go to [Firebase Console](https://console.firebase.google.com)&#10;2. Select your project&#10;3. Navigate to: **Storage → Rules**&#10;4. Copy content from `storage.rules` file&#10;5. Click **Publish**&#10;&#10;### 2. Enable Firebase Storage&#10;&#10;In Firebase Console:&#10;1. Go to **Storage** section&#10;2. Click **Get Started**&#10;3. Choose **Start in production mode**&#10;4. Select your preferred storage location (e.g., us-central1)&#10;&#10;### 3. Storage Structure&#10;&#10;Your Firebase Storage will be organized as:&#10;```&#10;storage_bucket/&#10;├── profile_pictures/&#10;│   └── {userId}/&#10;│       └── profile_{timestamp}.jpg&#10;├── post_images/&#10;│   └── {userId}/&#10;│       └── {postId}_{timestamp}.jpg&#10;└── story_images/&#10;    └── {userId}/&#10;        └── story_{timestamp}.jpg&#10;```&#10;&#10;## Usage in Your App&#10;&#10;### Upload Profile Picture&#10;```kotlin&#10;val repository = FirebaseUserRepository()&#10;repository.uploadProfilePicture(userId, imageUri)&#10;```&#10;&#10;### Upload Post Image (automatic)&#10;```kotlin&#10;val repository = FirebaseSecretRepository()&#10;repository.createSecret(..., imageUri = uri, ...)&#10;```&#10;&#10;### Create Story&#10;```kotlin&#10;val repository = FirebaseStoryRepository()&#10;repository.createStory(imageUri, caption, username, profilePic)&#10;```&#10;&#10;## Features&#10;&#10;- ✅ **Organized Structure**: Separate folders for profiles, posts, and stories&#10;- ✅ **Security**: Users can only upload to their own folders&#10;- ✅ **Metadata**: Tracks upload time, user, and image type&#10;- ✅ **Auto-cleanup**: Stories expire after 24 hours&#10;- ✅ **Size Limit**: 10MB max per image&#10;- ✅ **Format Support**: JPEG, PNG, WebP&#10;- ✅ **Error Handling**: Proper Result types for error management&#10;&#10;## Testing&#10;&#10;You can test the storage setup by:&#10;1. Building the project&#10;2. Uploading a test image through your app&#10;3. Checking Firebase Console → Storage to verify the file structure&#10;&#10;For detailed documentation, see `FIREBASE_STORAGE_SETUP.md`&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SETUP.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SETUP.md" />
              <option name="updatedContent" value="# Secret Spaces - Setup Instructions&#10;&#10;## Prerequisites&#10;- Android Studio (latest version)&#10;- Android SDK&#10;- Java 11 or higher&#10;&#10;## Initial Setup&#10;&#10;### 1. Clone the Repository&#10;```bash&#10;git clone &lt;your-repo-url&gt;&#10;cd Project_Android&#10;```&#10;&#10;### 2. Configure API Keys&#10;&#10;Create or edit the `local.properties` file in the root directory and add the following:&#10;&#10;```properties&#10;# Android SDK Location&#10;sdk.dir=&lt;path-to-your-android-sdk&gt;&#10;&#10;# MapTiler API Key&#10;# Get your free API key from: https://cloud.maptiler.com/&#10;MAPTILER_API_KEY=your_maptiler_api_key_here&#10;&#10;# Cloudinary Configuration&#10;# Get your credentials from: https://console.cloudinary.com/&#10;CLOUDINARY_CLOUD_NAME=your_cloud_name&#10;CLOUDINARY_API_KEY=your_api_key&#10;CLOUDINARY_API_SECRET=your_api_secret&#10;```&#10;&#10;⚠️ **IMPORTANT**: Never commit `local.properties` to version control. It's already in `.gitignore`.&#10;&#10;### 3. Firebase Setup&#10;&#10;1. Create a Firebase project at https://console.firebase.google.com/&#10;2. Add an Android app to your Firebase project&#10;3. Download `google-services.json` and place it in the `app/` directory&#10;4. Enable Authentication (Email/Password and Google Sign-In)&#10;5. Enable Firestore Database&#10;6. Set up Firestore security rules (see below)&#10;&#10;### 4. Cloudinary Setup&#10;&#10;1. Sign up at https://cloudinary.com/&#10;2. Get your credentials from the dashboard&#10;3. Add them to `local.properties` as shown above&#10;&#10;### 5. Build and Run&#10;&#10;```bash&#10;./gradlew clean build&#10;```&#10;&#10;Or run directly from Android Studio.&#10;&#10;## Firestore Security Rules&#10;&#10;```javascript&#10;rules_version = '2';&#10;service cloud.firestore {&#10;  match /databases/{database}/documents {&#10;    // Users collection&#10;    match /users/{userId} {&#10;      allow read: if true;&#10;      allow write: if request.auth != null &amp;&amp; request.auth.uid == userId;&#10;    }&#10;    &#10;    // Secrets collection&#10;    match /secrets/{secretId} {&#10;      allow read: if true;&#10;      allow create: if request.auth != null;&#10;      allow update, delete: if request.auth != null &amp;&amp; request.auth.uid == resource.data.userId;&#10;    }&#10;    &#10;    // Stories collection&#10;    match /stories/{storyId} {&#10;      allow read: if true;&#10;      allow create: if request.auth != null;&#10;      allow update, delete: if request.auth != null &amp;&amp; request.auth.uid == resource.data.userId;&#10;    }&#10;    &#10;    // Comments collection&#10;    match /comments/{commentId} {&#10;      allow read: if true;&#10;      allow create: if request.auth != null;&#10;      allow delete: if request.auth != null &amp;&amp; request.auth.uid == resource.data.userId;&#10;    }&#10;    &#10;    // Likes collection&#10;    match /likes/{likeId} {&#10;      allow read: if true;&#10;      allow create, delete: if request.auth != null;&#10;    }&#10;  }&#10;}&#10;```&#10;&#10;## Security Notes&#10;&#10;- All API keys are stored in `local.properties` which is gitignored&#10;- Never hardcode API keys in source files&#10;- If API keys are accidentally exposed, rotate them immediately:&#10;  - Cloudinary: https://console.cloudinary.com/ → Settings → Security&#10;  - MapTiler: https://cloud.maptiler.com/account/keys/&#10;  - Firebase: https://console.firebase.google.com/ → Project Settings → Service Accounts&#10;&#10;## Troubleshooting&#10;&#10;### Build fails with &quot;CLOUDINARY_CLOUD_NAME not found&quot;&#10;- Ensure `local.properties` exists and contains all required keys&#10;- Sync Gradle files in Android Studio&#10;&#10;### Google Sign-In not working&#10;- Add your SHA-1 and SHA-256 fingerprints to Firebase Console&#10;- Ensure google-services.json is up to date&#10;&#10;### Images not uploading&#10;- Check Cloudinary credentials in `local.properties`&#10;- Verify internet connection and permissions&#10;&#10;## Contributing&#10;&#10;When contributing, ensure you:&#10;1. Never commit `local.properties`&#10;2. Never hardcode API keys&#10;3. Use BuildConfig for all sensitive data&#10;4. Test on both debug and release builds&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/STATE_PRESERVATION_FIXES.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/STATE_PRESERVATION_FIXES.md" />
              <option name="updatedContent" value="# State Preservation Fixes Applied&#10;&#10;## Problem Summary&#10;The app was losing state when going to background (e.g., during phone calls, pressing home button), causing:&#10;1. App restarting from home/feed page when returning&#10;2. Loss of scroll position in feed&#10;3. Loss of crop state when editing images&#10;4. Loss of navigation state (e.g., from profile back to home)&#10;&#10;## Root Causes Identified&#10;1. **MainActivity restarting on every return** - No proper launch mode configured&#10;2. **Navigation state not preserved** - Using `remember` instead of `rememberSaveable`&#10;3. **Scroll position lost** - LazyListState not saved across process death&#10;4. **Crop state lost** - Image editing state not preserved during interruptions&#10;&#10;## Fixes Applied&#10;&#10;### 1. AndroidManifest.xml&#10;**Location:** `app/src/main/AndroidManifest.xml`&#10;&#10;**Changes:**&#10;- Added `android:launchMode=&quot;singleTask&quot;` to MainActivity&#10;- Added `android:configChanges=&quot;orientation|screenSize|keyboardHidden|screenLayout|uiMode&quot;`&#10;&#10;**Benefits:**&#10;- Prevents MainActivity from being recreated when returning from background&#10;- Maintains single instance of activity&#10;- Handles configuration changes without destroying activity&#10;&#10;### 2. SecretSpacesApp.kt&#10;**Location:** `app/src/main/java/com/secretspaces32/android/ui/navigation/SecretSpacesApp.kt`&#10;&#10;**Changes:**&#10;- Changed `var selectedScreen by remember` to `var selectedScreen by rememberSaveable`&#10;&#10;**Benefits:**&#10;- Navigation state (which screen you're on) survives process death&#10;- App returns to the same screen you were on before interruption&#10;&#10;### 3. FeedScreen.kt&#10;**Location:** `app/src/main/java/com/secretspaces32/android/ui/screens/FeedScreen.kt`&#10;&#10;**Changes:**&#10;- Changed `val lazyListState = rememberLazyListState()` to:&#10;  ```kotlin&#10;  val lazyListState = rememberSaveable(saver = LazyListState.Saver) {&#10;      LazyListState()&#10;  }&#10;  ```&#10;&#10;**Benefits:**&#10;- Scroll position in feed is preserved across app restarts&#10;- Returns to exact same scroll position after interruption&#10;&#10;### 4. MainScreenContainer.kt&#10;**Location:** `app/src/main/java/com/secretspaces32/android/ui/screens/MainScreenContainer.kt`&#10;&#10;**Changes:**&#10;- Changed `var currentDestination by remember` to `var currentDestination by rememberSaveable`&#10;- Changed `var selectedImages by remember` to `var selectedImages by rememberSaveable`&#10;&#10;**Benefits:**&#10;- Internal navigation state preserved (home/map/profile/create)&#10;- Selected images for posting are cached during interruptions&#10;- Won't lose your photo selections if interrupted during post creation&#10;&#10;### 5. ImageCropScreen.kt&#10;**Location:** `app/src/main/java/com/secretspaces32/android/ui/screens/ImageCropScreen.kt`&#10;&#10;**Changes:**&#10;- Changed all crop state variables to use `rememberSaveable`:&#10;  - `currentImageIndex` (which image you're cropping)&#10;  - `croppedImages` (already cropped images)&#10;  - `imageScale` (zoom level)&#10;  - `cropFrameScale` (crop frame size)&#10;  - `cropFrameOffsetX` (crop position X)&#10;  - `cropFrameOffsetY` (crop position Y)&#10;&#10;**Benefits:**&#10;- Crop state fully preserved during phone calls or app switching&#10;- Returns to exact same crop position, zoom, and progress&#10;- Already cropped images are not lost&#10;&#10;## Technical Details&#10;&#10;### What is rememberSaveable?&#10;- `remember` - Keeps state in memory, lost on process death&#10;- `rememberSaveable` - Saves state to Bundle, survives process death and configuration changes&#10;&#10;### What is LazyListState.Saver?&#10;- Special saver for LazyColumn/LazyRow scroll positions&#10;- Preserves first visible item index and scroll offset&#10;- Restores exact scroll position when app returns&#10;&#10;### What is launchMode=&quot;singleTask&quot;?&#10;- Ensures only one instance of MainActivity exists&#10;- Reuses existing activity instead of creating new one&#10;- Maintains activity state when returning from background&#10;&#10;## Testing Recommendations&#10;&#10;Test the following scenarios to verify fixes:&#10;&#10;1. **Navigation Preservation:**&#10;   - Navigate to Profile page&#10;   - Press home button&#10;   - Return to app&#10;   - ✓ Should still be on Profile page&#10;&#10;2. **Scroll Position:**&#10;   - Scroll down in feed&#10;   - Press home button&#10;   - Return to app&#10;   - ✓ Should be at same scroll position&#10;&#10;3. **Crop State:**&#10;   - Start creating a post with images&#10;   - Enter crop screen&#10;   - Adjust crop position/zoom&#10;   - Receive phone call or press home&#10;   - Return to app&#10;   - ✓ Should be in crop screen with same adjustments&#10;&#10;4. **Post Creation:**&#10;   - Select images for posting&#10;   - Press home button&#10;   - Return to app&#10;   - ✓ Selected images should still be there&#10;&#10;5. **Process Death Simulation:**&#10;   - Open app, navigate around&#10;   - Open Developer Options → Background Process Limit → Set to &quot;No background processes&quot;&#10;   - Press home button (app will be killed)&#10;   - Return to app&#10;   - ✓ Should restore to previous state&#10;&#10;## Additional Notes&#10;&#10;- All changes are backward compatible&#10;- No changes to data layer or backend required&#10;- Minimal performance impact (Bundle serialization is efficient)&#10;- Works on all Android versions supported by your app&#10;&#10;## Files Modified&#10;1. `app/src/main/AndroidManifest.xml`&#10;2. `app/src/main/java/com/secretspaces32/android/ui/navigation/SecretSpacesApp.kt`&#10;3. `app/src/main/java/com/secretspaces32/android/ui/screens/FeedScreen.kt`&#10;4. `app/src/main/java/com/secretspaces32/android/ui/screens/MainScreenContainer.kt`&#10;5. `app/src/main/java/com/secretspaces32/android/ui/screens/ImageCropScreen.kt`&#10;&#10;## Build &amp; Test&#10;No additional dependencies required. Simply rebuild and test:&#10;```&#10;gradlew clean assembleDebug&#10;```&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/secretspaces32/android/ui/screens/ImageEditor.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/secretspaces32/android/ui/screens/ImageEditor.kt" />
              <option name="originalContent" value="package com.secretspaces32.android.ui.screens&#10;&#10;import android.graphics.Bitmap&#10;import android.graphics.BitmapFactory&#10;import android.graphics.ColorMatrix&#10;import android.graphics.ColorMatrixColorFilter&#10;import android.graphics.Matrix&#10;import android.net.Uri&#10;import android.content.Context&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.gestures.detectTransformGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.automirrored.filled.RotateLeft&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.*&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.rememberAsyncImagePainter&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import java.io.File&#10;import java.io.FileOutputStream&#10;&#10;// uCrop&#10;import com.yalantis.ucrop.view.UCropView&#10;import com.yalantis.ucrop.callback.BitmapCropCallback&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;&#10;enum class EditMode {&#10;    CROP, FILTER, ADJUST, STICKER, MORE&#10;}&#10;&#10;data class ImageEditState(&#10;    val rotation: Float = 0f,&#10;    val scale: Float = 1f,&#10;    val offsetX: Float = 0f,&#10;    val offsetY: Float = 0f,&#10;    val brightness: Float = 0f,&#10;    val contrast: Float = 1f,&#10;    val saturation: Float = 1f,&#10;    val flipHorizontal: Boolean = false,&#10;    val flipVertical: Boolean = false,&#10;    val showGrid: Boolean = true,&#10;    val cropScale: Float = 1f,&#10;    val cropOffsetX: Float = 0f,&#10;    val cropOffsetY: Float = 0f&#10;)&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ImageEditor(&#10;    selectedImages: List&lt;Uri&gt;,&#10;    onImagesCropped: (List&lt;Uri&gt;) -&gt; Unit,&#10;    onBack: () -&gt; Unit = {}&#10;) {&#10;    val context = LocalContext.current&#10;    val scope = rememberCoroutineScope()&#10;    var currentImageIndex by remember { mutableIntStateOf(0) }&#10;    var editedImages by remember { mutableStateOf&lt;List&lt;Uri&gt;&gt;(emptyList()) }&#10;    var editMode by remember { mutableStateOf(EditMode.CROP) }&#10;    var editState by remember { mutableStateOf(ImageEditState()) }&#10;    var isProcessing by remember { mutableStateOf(false) }&#10;&#10;    // Keep per-image cropped source produced by uCrop (embedded)&#10;    var croppedImageUris by remember { mutableStateOf&lt;Map&lt;Int, Uri&gt;&gt;(emptyMap()) }&#10;&#10;    // UCrop view reference for current screen&#10;    var uCropViewRef by remember { mutableStateOf&lt;UCropView?&gt;(null) }&#10;&#10;    // Use cropped uri if available for current index&#10;    val currentImageUri: Uri? = run {&#10;        val original = selectedImages.getOrNull(currentImageIndex)&#10;        croppedImageUris[currentImageIndex] ?: original&#10;    }&#10;&#10;    // Flip current image by writing a mirrored temporary file and return its Uri&#10;    suspend fun flipCurrentImageHorizontal(source: Uri): Uri? = withContext(Dispatchers.IO) {&#10;        try {&#10;            context.contentResolver.openInputStream(source)?.use { input -&gt;&#10;                val original = BitmapFactory.decodeStream(input)&#10;                val m = Matrix().apply { postScale(-1f, 1f, original.width / 2f, original.height / 2f) }&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                val flipped = Bitmap.createBitmap(original, 0, 0, original.width, original.height, m, true)&#10;                val outFile = File(context.cacheDir, &quot;flipped_${System.currentTimeMillis()}_${currentImageIndex}.jpg&quot;)&#10;                FileOutputStream(outFile).use { flipped.compress(Bitmap.CompressFormat.JPEG, 95, it) }&#10;                Uri.fromFile(outFile)&#10;            }&#10;        } catch (t: Throwable) {&#10;            t.printStackTrace()&#10;            null&#10;        }&#10;    }&#10;&#10;    fun configureUCropView(view: UCropView, imageUri: Uri) {&#10;        val crop = view.cropImageView&#10;        val overlay = view.overlayView&#10;        crop.isScaleEnabled = true&#10;        crop.isRotateEnabled = true&#10;        crop.setMaxResultImageSizeX(4096)&#10;        crop.setMaxResultImageSizeY(4096)&#10;        crop.setImageToWrapCropBounds(true)&#10;        // Lock aspect ratio to 16:9 - crop box is resizable but maintains the ratio&#10;        overlay.setShowCropGrid(true)&#10;        overlay.setShowCropFrame(true)&#10;        // DON'T set freestyleCropMode at all - this allows resizing with locked aspect ratio&#10;        // Setting DISABLE would lock the frame completely&#10;        // Setting ENABLE would allow free aspect ratio changes&#10;        // Not setting it allows resize while maintaining the target aspect ratio&#10;        overlay.setDimmedColor(Color.Black.copy(alpha = 0.6f).toArgb())&#10;        // Set target aspect ratio to 16:9 - this locks the ratio during resize&#10;        crop.targetAspectRatio = 16f / 9f&#10;&#10;        // Prepare output destination per load&#10;        val out = File(view.context.cacheDir, &quot;ucrop_embed_${System.currentTimeMillis()}.jpg&quot;)&#10;        val outUri = Uri.fromFile(out)&#10;        try {&#10;            crop.setImageUri(imageUri, outUri)&#10;        } catch (t: Throwable) {&#10;            t.printStackTrace()&#10;        }&#10;    }&#10;&#10;    suspend fun cropWithUCropViewIfPresent(currentImageUri: Uri?): Uri? = withContext(Dispatchers.Main) {&#10;        val view = uCropViewRef ?: return@withContext null&#10;        val cropView = view.cropImageView&#10;        val out = File(view.context.cacheDir, &quot;ucrop_inplace_${System.currentTimeMillis()}_${currentImageIndex}.jpg&quot;)&#10;        val outUri = Uri.fromFile(out)&#10;        // Ensure output uri is set (input same as current)&#10;        try {&#10;            if (currentImageUri != null) cropView.setImageUri(currentImageUri, outUri)&#10;        } catch (t: Throwable) {&#10;            t.printStackTrace()&#10;        }&#10;        @Suppress(&quot;DEPRECATION&quot;)&#10;        kotlinx.coroutines.suspendCancellableCoroutine { cont -&gt;&#10;            cropView.cropAndSaveImage(&#10;                Bitmap.CompressFormat.JPEG,&#10;                90,&#10;                object : BitmapCropCallback {&#10;                    override fun onBitmapCropped(resultUri: Uri, offsetX: Int, offsetY: Int, imageWidth: Int, imageHeight: Int) {&#10;                        cont.resume(resultUri) { }&#10;                    }&#10;                    override fun onCropFailure(t: Throwable) {&#10;                        t.printStackTrace()&#10;                        cont.resume(null) { }&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;&#10;    suspend fun saveEditedImage(): Uri? {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                // First, perform crop using embedded UCropView if available&#10;                val croppedFirstUri = cropWithUCropViewIfPresent(currentImageUri) ?: currentImageUri&#10;                val inputStream = context.contentResolver.openInputStream(croppedFirstUri!!)&#10;                var bitmap = BitmapFactory.decodeStream(inputStream)&#10;                inputStream?.close()&#10;&#10;                // Apply transformations (flip + color); rotation is handled by UCrop&#10;                val matrix = Matrix().apply {&#10;                    if (editState.flipHorizontal) {&#10;                        postScale(-1f, 1f, bitmap.width / 2f, bitmap.height / 2f)&#10;                    }&#10;                    if (editState.flipVertical) {&#10;                        postScale(1f, -1f, bitmap.width / 2f, bitmap.height / 2f)&#10;                    }&#10;                    // Do not apply editState.rotation here to avoid double-rotation&#10;                }&#10;&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                bitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.width, bitmap.height, matrix, true)&#10;&#10;                val colorMatrix = ColorMatrix().apply {&#10;                    val brightness = editState.brightness * 255&#10;                    postConcat(ColorMatrix(floatArrayOf(&#10;                        1f, 0f, 0f, 0f, brightness,&#10;                        0f, 1f, 0f, 0f, brightness,&#10;                        0f, 0f, 1f, 0f, brightness,&#10;                        0f, 0f, 0f, 1f, 0f&#10;                    )))&#10;                    postConcat(ColorMatrix().apply { setSaturation(editState.saturation) })&#10;                    val c = editState.contrast&#10;                    postConcat(ColorMatrix(floatArrayOf(&#10;                        c, 0f, 0f, 0f, 128 * (1 - c),&#10;                        0f, c, 0f, 0f, 128 * (1 - c),&#10;                        0f, 0f, c, 0f, 128 * (1 - c),&#10;                        0f, 0f, 0f, 1f, 0f&#10;                    )))&#10;                }&#10;&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                val paint = android.graphics.Paint().apply { colorFilter = ColorMatrixColorFilter(colorMatrix) }&#10;                val resultBitmap = androidx.core.graphics.createBitmap(bitmap.width, bitmap.height, bitmap.config ?: Bitmap.Config.ARGB_8888)&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                val canvas = android.graphics.Canvas(resultBitmap)&#10;                canvas.drawBitmap(bitmap, 0f, 0f, paint)&#10;&#10;                val file = File(context.cacheDir, &quot;edited_${System.currentTimeMillis()}_$currentImageIndex.jpg&quot;)&#10;                FileOutputStream(file).use { out -&gt;&#10;                    resultBitmap.compress(Bitmap.CompressFormat.JPEG, 90, out)&#10;                }&#10;&#10;                Uri.fromFile(file)&#10;            } catch (e: Exception) {&#10;                e.printStackTrace()&#10;                null&#10;            }&#10;        }&#10;    }&#10;&#10;    fun handleNext() {&#10;        scope.launch {&#10;            isProcessing = true&#10;            // Trigger a crop to persist current crop box before saving adjustments&#10;            val maybeCropped = cropWithUCropViewIfPresent(currentImageUri)&#10;            if (maybeCropped != null) {&#10;                croppedImageUris = croppedImageUris + (currentImageIndex to maybeCropped)&#10;            }&#10;            val editedUri = saveEditedImage()&#10;            if (editedUri != null) {&#10;                editedImages = editedImages + editedUri&#10;                if (currentImageIndex &lt; selectedImages.size - 1) {&#10;                    currentImageIndex++&#10;                    editState = ImageEditState()&#10;                } else {&#10;                    onImagesCropped(editedImages)&#10;                }&#10;            }&#10;            isProcessing = false&#10;        }&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.Black)&#10;    ) {&#10;        Column(modifier = Modifier.fillMaxSize()) {&#10;            // Top Bar&#10;            Surface(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                color = Color.Black.copy(alpha = 0.8f)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .statusBarsPadding()&#10;                        .padding(horizontal = 8.dp, vertical = 12.dp),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    IconButton(onClick = onBack) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Back&quot;,&#10;                            tint = Color.White&#10;                        )&#10;                    }&#10;&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#10;                        // Page indicator&#10;                        if (selectedImages.size &gt; 1) {&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .background(Color.White.copy(alpha = 0.2f), RoundedCornerShape(12.dp))&#10;                                    .padding(horizontal = 12.dp, vertical = 6.dp)&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;${currentImageIndex + 1}/${selectedImages.size}&quot;,&#10;                                    color = Color.White,&#10;                                    fontSize = 14.sp&#10;                                )&#10;                            }&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                        }&#10;&#10;                        TextButton(&#10;                            onClick = { handleNext() },&#10;                            enabled = !isProcessing&#10;                        ) {&#10;                            if (isProcessing) {&#10;                                CircularProgressIndicator(&#10;                                    modifier = Modifier.size(20.dp),&#10;                                    color = Color.White,&#10;                                    strokeWidth = 2.dp&#10;                                )&#10;                            } else {&#10;                                Text(&#10;                                    text = if (currentImageIndex &lt; selectedImages.size - 1) &quot;Next&quot; else &quot;Done&quot;,&#10;                                    color = Color.Red,&#10;                                    fontWeight = FontWeight.Bold,&#10;                                    fontSize = 16.sp&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Image Editor Area&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .weight(1f)&#10;                    .background(Color.Black),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                if (currentImageUri != null) {&#10;                    if (editMode == EditMode.CROP) {&#10;                        AndroidView(&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            factory = { ctx: Context -&gt;&#10;                                UCropView(ctx, null).also { view -&gt;&#10;                                    uCropViewRef = view&#10;                                    configureUCropView(view, currentImageUri)&#10;                                }&#10;                            },&#10;                            update = { view: UCropView -&gt;&#10;                                configureUCropView(view, currentImageUri)&#10;                            }&#10;                        )&#10;                    } else {&#10;                        ImageEditCanvas(&#10;                            imageUri = currentImageUri,&#10;                            editState = editState,&#10;                            onEditStateChange = { editState = it }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Edit Mode Selector with controls&#10;            EditModeSelector(&#10;                selectedMode = editMode,&#10;                onModeSelected = { editMode = it },&#10;                editState = editState,&#10;                onEditStateChange = { editState = it },&#10;                onRotate = {&#10;                    uCropViewRef?.cropImageView?.postRotate(-90f)&#10;                    uCropViewRef?.cropImageView?.setImageToWrapCropBounds(true)&#10;                },&#10;                onRotateFine = { degrees -&gt;&#10;                    uCropViewRef?.cropImageView?.postRotate(degrees)&#10;                    uCropViewRef?.cropImageView?.setImageToWrapCropBounds(true)&#10;                },&#10;                onFlipH = {&#10;                    val src = currentImageUri ?: return@EditModeSelector&#10;                    scope.launch {&#10;                        val flippedUri = flipCurrentImageHorizontal(src)&#10;                        flippedUri?.let { uri -&gt;&#10;                            val updated = croppedImageUris.toMutableMap()&#10;                            updated[currentImageIndex] = uri&#10;                            croppedImageUris = updated.toMap()&#10;                            uCropViewRef?.let { configureUCropView(it, uri) }&#10;                        }&#10;                    }&#10;                }&#10;            )&#10;&#10;            // Controls (only for non-crop modes)&#10;            when (editMode) {&#10;                EditMode.CROP -&gt; { /* Controls now integrated in EditModeSelector */ }&#10;                EditMode.FILTER -&gt; FilterControls(editState, onEditStateChange = { editState = it })&#10;                EditMode.ADJUST -&gt; AdjustControls(editState, onEditStateChange = { editState = it })&#10;                EditMode.STICKER -&gt; StickerControls()&#10;                EditMode.MORE -&gt; MoreControls()&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ImageEditCanvas(&#10;    imageUri: Uri,&#10;    editState: ImageEditState,&#10;    onEditStateChange: (ImageEditState) -&gt; Unit&#10;) {&#10;    var scale by remember { mutableFloatStateOf(editState.scale) }&#10;    var offsetX by remember { mutableFloatStateOf(editState.offsetX) }&#10;    var offsetY by remember { mutableFloatStateOf(editState.offsetY) }&#10;    var rotation by remember { mutableFloatStateOf(editState.rotation) }&#10;&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        // Image layer with transform gestures&#10;        Image(&#10;            painter = rememberAsyncImagePainter(imageUri),&#10;            contentDescription = null,&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .pointerInput(Unit) {&#10;                    detectTransformGestures { _, pan, zoom, rotationDelta -&gt;&#10;                        scale = (scale * zoom).coerceIn(0.3f, 4f)&#10;                        offsetX += pan.x&#10;                        offsetY += pan.y&#10;                        rotation += rotationDelta&#10;&#10;                        onEditStateChange(&#10;                            editState.copy(&#10;                                scale = scale,&#10;                                offsetX = offsetX,&#10;                                offsetY = offsetY,&#10;                                rotation = rotation&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;                .graphicsLayer(&#10;                    scaleX = scale * if (editState.flipHorizontal) -1f else 1f,&#10;                    scaleY = scale * if (editState.flipVertical) -1f else 1f,&#10;                    rotationZ = rotation,&#10;                    translationX = offsetX,&#10;                    translationY = offsetY&#10;                ),&#10;            contentScale = ContentScale.Fit,&#10;            colorFilter = ColorFilter.colorMatrix(&#10;                androidx.compose.ui.graphics.ColorMatrix().apply {&#10;                    val brightness = editState.brightness * 255&#10;                    val contrastMatrix = androidx.compose.ui.graphics.ColorMatrix(floatArrayOf(&#10;                        editState.contrast, 0f, 0f, 0f, brightness,&#10;                        0f, editState.contrast, 0f, 0f, brightness,&#10;                        0f, 0f, editState.contrast, 0f, brightness,&#10;                        0f, 0f, 0f, 1f, 0f&#10;                    ))&#10;                    val saturationMatrix = androidx.compose.ui.graphics.ColorMatrix().apply {&#10;                        setToSaturation(editState.saturation)&#10;                    }&#10;                    this.timesAssign(contrastMatrix)&#10;                    this.timesAssign(saturationMatrix)&#10;                }&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EditModeSelector(&#10;    selectedMode: EditMode,&#10;    onModeSelected: (EditMode) -&gt; Unit,&#10;    editState: ImageEditState,&#10;    onEditStateChange: (ImageEditState) -&gt; Unit,&#10;    onRotate: () -&gt; Unit = {},&#10;    onRotateFine: (Float) -&gt; Unit = {},&#10;    onFlipH: () -&gt; Unit = {}&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .background(Color.Black.copy(alpha = 0.9f))&#10;            .navigationBarsPadding()&#10;    ) {&#10;        // TOP: Rotation and Flip buttons (only show in CROP mode)&#10;        if (selectedMode == EditMode.CROP) {&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(top = 12.dp, bottom = 8.dp),&#10;                horizontalArrangement = Arrangement.SpaceEvenly,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                IconButton(&#10;                    onClick = onRotate,&#10;                    modifier = Modifier.size(48.dp).background(Color.White.copy(alpha = 0.15f), CircleShape)&#10;                ) {&#10;                    Icon(imageVector = Icons.AutoMirrored.Filled.RotateLeft, contentDescription = &quot;Rotate -90&quot;, tint = Color.White)&#10;                }&#10;                IconButton(&#10;                    onClick = onFlipH,&#10;                    modifier = Modifier.size(48.dp).background(Color.White.copy(alpha = 0.15f), CircleShape)&#10;                ) {&#10;                    Icon(imageVector = Icons.Default.Flip, contentDescription = &quot;Flip H&quot;, tint = Color.White)&#10;                }&#10;            }&#10;&#10;            // MIDDLE: Horizontal scrollbar for fine-tuning rotation&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp, vertical = 8.dp)&#10;            ) {&#10;                RotationSliderWithLines(&#10;                    value = editState.rotation,&#10;                    onValueChange = { newValue -&gt;&#10;                        val delta = newValue - editState.rotation&#10;                        onRotateFine(delta)&#10;                        onEditStateChange(editState.copy(rotation = newValue))&#10;                    }&#10;                )&#10;            }&#10;        }&#10;&#10;        // BOTTOM: Mode selector buttons&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 12.dp),&#10;            horizontalArrangement = Arrangement.SpaceEvenly&#10;        ) {&#10;            EditModeButton(&#10;                icon = Icons.Default.CropRotate,&#10;                label = &quot;Crop&quot;,&#10;                isSelected = selectedMode == EditMode.CROP,&#10;                onClick = { onModeSelected(EditMode.CROP) }&#10;            )&#10;            EditModeButton(&#10;                icon = Icons.Default.FilterList,&#10;                label = &quot;Filter&quot;,&#10;                isSelected = selectedMode == EditMode.FILTER,&#10;                onClick = { onModeSelected(EditMode.FILTER) }&#10;            )&#10;            EditModeButton(&#10;                icon = Icons.Default.Tune,&#10;                label = &quot;Adjust&quot;,&#10;                isSelected = selectedMode == EditMode.ADJUST,&#10;                onClick = { onModeSelected(EditMode.ADJUST) }&#10;            )&#10;            EditModeButton(&#10;                icon = Icons.Default.EmojiEmotions,&#10;                label = &quot;Sticker&quot;,&#10;                isSelected = selectedMode == EditMode.STICKER,&#10;                onClick = { onModeSelected(EditMode.STICKER) }&#10;            )&#10;            EditModeButton(&#10;                icon = Icons.Default.MoreHoriz,&#10;                label = &quot;More&quot;,&#10;                isSelected = selectedMode == EditMode.MORE,&#10;                onClick = { onModeSelected(EditMode.MORE) }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EditModeButton(&#10;    icon: androidx.compose.ui.graphics.vector.ImageVector,&#10;    label: String,&#10;    isSelected: Boolean,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        modifier = Modifier&#10;            .clickable(onClick = onClick)&#10;            .padding(horizontal = 8.dp)&#10;    ) {&#10;        Icon(&#10;            imageVector = icon,&#10;            contentDescription = label,&#10;            tint = if (isSelected) Color(0xFFFFD700) else Color.White.copy(alpha = 0.6f),&#10;            modifier = Modifier.size(24.dp)&#10;        )&#10;        Spacer(modifier = Modifier.height(4.dp))&#10;        Text(&#10;            text = label,&#10;            color = if (isSelected) Color(0xFFFFD700) else Color.White.copy(alpha = 0.6f),&#10;            fontSize = 11.sp&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun RotationSliderWithLines(&#10;    value: Float,&#10;    onValueChange: (Float) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    var dragOffset by remember { mutableFloatStateOf(0f) }&#10;    val lineSpacing = 4.dp&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .height(60.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        // Scrollable lines background&#10;        Canvas(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(50.dp)&#10;                .pointerInput(Unit) {&#10;                    detectTransformGestures { _, pan, _, _ -&gt;&#10;                        dragOffset += pan.x&#10;                        // Map drag to rotation value (-180 to 180)&#10;                        val sensitivity = 0.5f&#10;                        val newValue = (value - pan.x * sensitivity).coerceIn(-180f, 180f)&#10;                        onValueChange(newValue)&#10;                    }&#10;                }&#10;        ) {&#10;            val centerX = size.width / 2f&#10;            val lineSpacingPx = lineSpacing.toPx()&#10;&#10;            // Calculate offset based on rotation value&#10;            val pixelsPerDegree = lineSpacingPx&#10;            val scrollOffset = value * pixelsPerDegree&#10;&#10;            // Draw vertical lines&#10;            for (i in -200..200) {&#10;                val xPos = centerX + (i * lineSpacingPx) - scrollOffset&#10;&#10;                if (xPos &gt;= 0 &amp;&amp; xPos &lt;= size.width) {&#10;                    val degree = i&#10;&#10;                    // Determine line height based on position&#10;                    val lineHeight = when {&#10;                        degree % 45 == 0 -&gt; size.height * 0.7f // Major marks&#10;                        degree % 15 == 0 -&gt; size.height * 0.5f // Medium marks&#10;                        degree % 5 == 0 -&gt; size.height * 0.35f // Minor marks&#10;                        else -&gt; size.height * 0.25f // Smallest marks&#10;                    }&#10;&#10;                    // Determine color - center line is highlighted&#10;                    val distanceFromCenter = kotlin.math.abs(xPos - centerX)&#10;                    val alpha = if (distanceFromCenter &lt; 3f) 1f else 0.4f&#10;                    val color = if (distanceFromCenter &lt; 3f) {&#10;                        Color(0xFFFFD700) // Gold for center&#10;                    } else {&#10;                        Color.White.copy(alpha = alpha)&#10;                    }&#10;&#10;                    val yStart = (size.height - lineHeight) / 2f&#10;                    val yEnd = yStart + lineHeight&#10;&#10;                    drawLine(&#10;                        color = color,&#10;                        start = Offset(xPos, yStart),&#10;                        end = Offset(xPos, yEnd),&#10;                        strokeWidth = if (distanceFromCenter &lt; 3f) 3f else 1.5f&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Draw center indicator line (fixed position)&#10;            drawLine(&#10;                color = Color(0xFFFFD700),&#10;                start = Offset(centerX, 0f),&#10;                end = Offset(centerX, size.height),&#10;                strokeWidth = 3f&#10;            )&#10;        }&#10;&#10;        // Degree value display&#10;        Text(&#10;            text = &quot;${value.toInt()}°&quot;,&#10;            color = Color.White,&#10;            fontSize = 12.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            modifier = Modifier&#10;                .align(Alignment.BottomCenter)&#10;                .padding(bottom = 4.dp)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun FilterControls(&#10;    editState: ImageEditState,&#10;    onEditStateChange: (ImageEditState) -&gt; Unit&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .background(Color.Black.copy(alpha = 0.9f))&#10;            .padding(16.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Filters&quot;,&#10;            color = Color.White,&#10;            fontSize = 14.sp,&#10;            modifier = Modifier.padding(bottom = 12.dp)&#10;        )&#10;&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceEvenly&#10;        ) {&#10;            FilterPreset(&quot;Original&quot;, onClick = {&#10;                onEditStateChange(editState.copy(brightness = 0f, contrast = 1f, saturation = 1f))&#10;            })&#10;            FilterPreset(&quot;Bright&quot;, onClick = {&#10;                onEditStateChange(editState.copy(brightness = 0.2f, contrast = 1.1f, saturation = 1.2f))&#10;            })&#10;            FilterPreset(&quot;Dark&quot;, onClick = {&#10;                onEditStateChange(editState.copy(brightness = -0.2f, contrast = 1.2f, saturation = 0.8f))&#10;            })&#10;            FilterPreset(&quot;B&amp;W&quot;, onClick = {&#10;                onEditStateChange(editState.copy(saturation = 0f, contrast = 1.3f))&#10;            })&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun FilterPreset(label: String, onClick: () -&gt; Unit) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        modifier = Modifier.clickable(onClick = onClick)&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .size(60.dp)&#10;                .background(Color.Gray, RoundedCornerShape(8.dp))&#10;                .border(1.dp, Color.White.copy(alpha = 0.3f), RoundedCornerShape(8.dp))&#10;        )&#10;        Spacer(modifier = Modifier.height(4.dp))&#10;        Text(&#10;            text = label,&#10;            color = Color.White,&#10;            fontSize = 11.sp&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun AdjustControls(&#10;    editState: ImageEditState,&#10;    onEditStateChange: (ImageEditState) -&gt; Unit&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .background(Color.Black.copy(alpha = 0.9f))&#10;            .navigationBarsPadding()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Brightness&#10;        Text(&#10;            text = &quot;Brightness&quot;,&#10;            color = Color.White,&#10;            fontSize = 14.sp&#10;        )&#10;        Slider(&#10;            value = editState.brightness,&#10;            onValueChange = { onEditStateChange(editState.copy(brightness = it)) },&#10;            valueRange = -0.5f..0.5f,&#10;            colors = SliderDefaults.colors(&#10;                thumbColor = Color(0xFFFFD700),&#10;                activeTrackColor = Color(0xFFFFD700)&#10;            )&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Contrast&#10;        Text(&#10;            text = &quot;Contrast&quot;,&#10;            color = Color.White,&#10;            fontSize = 14.sp&#10;        )&#10;        Slider(&#10;            value = editState.contrast,&#10;            onValueChange = { onEditStateChange(editState.copy(contrast = it)) },&#10;            valueRange = 0.5f..2f,&#10;            colors = SliderDefaults.colors(&#10;                thumbColor = Color(0xFFFFD700),&#10;                activeTrackColor = Color(0xFFFFD700)&#10;            )&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Saturation&#10;        Text(&#10;            text = &quot;Saturation&quot;,&#10;            color = Color.White,&#10;            fontSize = 14.sp&#10;        )&#10;        Slider(&#10;            value = editState.saturation,&#10;            onValueChange = { onEditStateChange(editState.copy(saturation = it)) },&#10;            valueRange = 0f..2f,&#10;            colors = SliderDefaults.colors(&#10;                thumbColor = Color(0xFFFFD700),&#10;                activeTrackColor = Color(0xFFFFD700)&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun StickerControls() {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .background(Color.Black.copy(alpha = 0.9f))&#10;            .navigationBarsPadding()&#10;            .padding(16.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;Stickers coming soon...&quot;,&#10;            color = Color.White.copy(alpha = 0.5f),&#10;            fontSize = 14.sp&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MoreControls() {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .background(Color.Black.copy(alpha = 0.9f))&#10;            .navigationBarsPadding()&#10;            .padding(16.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;More options coming soon...&quot;,&#10;            color = Color.White.copy(alpha = 0.5f),&#10;            fontSize = 14.sp&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.secretspaces32.android.ui.screens&#10;&#10;import android.graphics.Bitmap&#10;import android.graphics.BitmapFactory&#10;import android.graphics.ColorMatrix&#10;import android.graphics.ColorMatrixColorFilter&#10;import android.graphics.Matrix&#10;import android.net.Uri&#10;import android.content.Context&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.gestures.detectTransformGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.automirrored.filled.RotateLeft&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.*&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.rememberAsyncImagePainter&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import java.io.File&#10;import java.io.FileOutputStream&#10;&#10;// uCrop&#10;import com.yalantis.ucrop.view.UCropView&#10;import com.yalantis.ucrop.callback.BitmapCropCallback&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;&#10;enum class EditMode {&#10;    CROP, FILTER, ADJUST, STICKER, MORE&#10;}&#10;&#10;data class ImageEditState(&#10;    val rotation: Float = 0f,&#10;    val scale: Float = 1f,&#10;    val offsetX: Float = 0f,&#10;    val offsetY: Float = 0f,&#10;    val brightness: Float = 0f,&#10;    val contrast: Float = 1f,&#10;    val saturation: Float = 1f,&#10;    val flipHorizontal: Boolean = false,&#10;    val flipVertical: Boolean = false,&#10;    val showGrid: Boolean = true,&#10;    val cropScale: Float = 1f,&#10;    val cropOffsetX: Float = 0f,&#10;    val cropOffsetY: Float = 0f&#10;)&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ImageEditor(&#10;    selectedImages: List&lt;Uri&gt;,&#10;    onImagesCropped: (List&lt;Uri&gt;) -&gt; Unit,&#10;    onBack: () -&gt; Unit = {}&#10;) {&#10;    val context = LocalContext.current&#10;    val scope = rememberCoroutineScope()&#10;    var currentImageIndex by remember { mutableIntStateOf(0) }&#10;    var editedImages by remember { mutableStateOf&lt;List&lt;Uri&gt;&gt;(emptyList()) }&#10;    var editMode by remember { mutableStateOf(EditMode.CROP) }&#10;    var editState by remember { mutableStateOf(ImageEditState()) }&#10;    var isProcessing by remember { mutableStateOf(false) }&#10;&#10;    // Keep per-image cropped source produced by uCrop (embedded)&#10;    var croppedImageUris by remember { mutableStateOf&lt;Map&lt;Int, Uri&gt;&gt;(emptyMap()) }&#10;&#10;    // UCrop view reference for current screen&#10;    var uCropViewRef by remember { mutableStateOf&lt;UCropView?&gt;(null) }&#10;&#10;    // Use cropped uri if available for current index&#10;    val currentImageUri: Uri? = run {&#10;        val original = selectedImages.getOrNull(currentImageIndex)&#10;        croppedImageUris[currentImageIndex] ?: original&#10;    }&#10;&#10;    // Flip current image by writing a mirrored temporary file and return its Uri&#10;    suspend fun flipCurrentImageHorizontal(source: Uri): Uri? = withContext(Dispatchers.IO) {&#10;        try {&#10;            context.contentResolver.openInputStream(source)?.use { input -&gt;&#10;                val original = BitmapFactory.decodeStream(input)&#10;                val m = Matrix().apply { postScale(-1f, 1f, original.width / 2f, original.height / 2f) }&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                val flipped = Bitmap.createBitmap(original, 0, 0, original.width, original.height, m, true)&#10;                val outFile = File(context.cacheDir, &quot;flipped_${System.currentTimeMillis()}_${currentImageIndex}.jpg&quot;)&#10;                FileOutputStream(outFile).use { flipped.compress(Bitmap.CompressFormat.JPEG, 95, it) }&#10;                Uri.fromFile(outFile)&#10;            }&#10;        } catch (t: Throwable) {&#10;            t.printStackTrace()&#10;            null&#10;        }&#10;    }&#10;&#10;    fun configureUCropView(view: UCropView, imageUri: Uri) {&#10;        val crop = view.cropImageView&#10;        val overlay = view.overlayView&#10;        crop.isScaleEnabled = true&#10;        crop.isRotateEnabled = true&#10;        crop.setMaxResultImageSizeX(4096)&#10;        crop.setMaxResultImageSizeY(4096)&#10;        crop.setImageToWrapCropBounds(true)&#10;        // Lock aspect ratio to 16:9 - crop box is resizable but maintains the ratio&#10;        overlay.setShowCropGrid(true)&#10;        overlay.setShowCropFrame(true)&#10;        // DON'T set freestyleCropMode at all - this allows resizing with locked aspect ratio&#10;        // Setting DISABLE would lock the frame completely&#10;        // Setting ENABLE would allow free aspect ratio changes&#10;        // Not setting it allows resize while maintaining the target aspect ratio&#10;        overlay.setDimmedColor(Color.Black.copy(alpha = 0.6f).toArgb())&#10;        // Set target aspect ratio to 16:9 - this locks the ratio during resize&#10;        crop.targetAspectRatio = 16f / 9f&#10;&#10;        // Prepare output destination per load&#10;        val out = File(view.context.cacheDir, &quot;ucrop_embed_${System.currentTimeMillis()}.jpg&quot;)&#10;        val outUri = Uri.fromFile(out)&#10;        try {&#10;            crop.setImageUri(imageUri, outUri)&#10;        } catch (t: Throwable) {&#10;            t.printStackTrace()&#10;        }&#10;    }&#10;&#10;    suspend fun cropWithUCropViewIfPresent(currentImageUri: Uri?): Uri? = withContext(Dispatchers.Main) {&#10;        val view = uCropViewRef ?: return@withContext null&#10;        val cropView = view.cropImageView&#10;        val out = File(view.context.cacheDir, &quot;ucrop_inplace_${System.currentTimeMillis()}_${currentImageIndex}.jpg&quot;)&#10;        val outUri = Uri.fromFile(out)&#10;        // Ensure output uri is set (input same as current)&#10;        try {&#10;            if (currentImageUri != null) cropView.setImageUri(currentImageUri, outUri)&#10;        } catch (t: Throwable) {&#10;            t.printStackTrace()&#10;        }&#10;        @Suppress(&quot;DEPRECATION&quot;)&#10;        kotlinx.coroutines.suspendCancellableCoroutine { cont -&gt;&#10;            cropView.cropAndSaveImage(&#10;                Bitmap.CompressFormat.JPEG,&#10;                90,&#10;                object : BitmapCropCallback {&#10;                    override fun onBitmapCropped(resultUri: Uri, offsetX: Int, offsetY: Int, imageWidth: Int, imageHeight: Int) {&#10;                        cont.resume(resultUri) { }&#10;                    }&#10;                    override fun onCropFailure(t: Throwable) {&#10;                        t.printStackTrace()&#10;                        cont.resume(null) { }&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;&#10;    suspend fun saveEditedImage(): Uri? {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                // First, perform crop using embedded UCropView if available&#10;                val croppedFirstUri = cropWithUCropViewIfPresent(currentImageUri) ?: currentImageUri&#10;                val inputStream = context.contentResolver.openInputStream(croppedFirstUri!!)&#10;                var bitmap = BitmapFactory.decodeStream(inputStream)&#10;                inputStream?.close()&#10;&#10;                // Apply transformations (flip + color); rotation is handled by UCrop&#10;                val matrix = Matrix().apply {&#10;                    if (editState.flipHorizontal) {&#10;                        postScale(-1f, 1f, bitmap.width / 2f, bitmap.height / 2f)&#10;                    }&#10;                    if (editState.flipVertical) {&#10;                        postScale(1f, -1f, bitmap.width / 2f, bitmap.height / 2f)&#10;                    }&#10;                    // Do not apply editState.rotation here to avoid double-rotation&#10;                }&#10;&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                bitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.width, bitmap.height, matrix, true)&#10;&#10;                val colorMatrix = ColorMatrix().apply {&#10;                    val brightness = editState.brightness * 255&#10;                    postConcat(ColorMatrix(floatArrayOf(&#10;                        1f, 0f, 0f, 0f, brightness,&#10;                        0f, 1f, 0f, 0f, brightness,&#10;                        0f, 0f, 1f, 0f, brightness,&#10;                        0f, 0f, 0f, 1f, 0f&#10;                    )))&#10;                    postConcat(ColorMatrix().apply { setSaturation(editState.saturation) })&#10;                    val c = editState.contrast&#10;                    postConcat(ColorMatrix(floatArrayOf(&#10;                        c, 0f, 0f, 0f, 128 * (1 - c),&#10;                        0f, c, 0f, 0f, 128 * (1 - c),&#10;                        0f, 0f, c, 0f, 128 * (1 - c),&#10;                        0f, 0f, 0f, 1f, 0f&#10;                    )))&#10;                }&#10;&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                val paint = android.graphics.Paint().apply { colorFilter = ColorMatrixColorFilter(colorMatrix) }&#10;                val resultBitmap = androidx.core.graphics.createBitmap(bitmap.width, bitmap.height, bitmap.config ?: Bitmap.Config.ARGB_8888)&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                val canvas = android.graphics.Canvas(resultBitmap)&#10;                canvas.drawBitmap(bitmap, 0f, 0f, paint)&#10;&#10;                val file = File(context.cacheDir, &quot;edited_${System.currentTimeMillis()}_$currentImageIndex.jpg&quot;)&#10;                FileOutputStream(file).use { out -&gt;&#10;                    resultBitmap.compress(Bitmap.CompressFormat.JPEG, 90, out)&#10;                }&#10;&#10;                Uri.fromFile(file)&#10;            } catch (e: Exception) {&#10;                e.printStackTrace()&#10;                null&#10;            }&#10;        }&#10;    }&#10;&#10;    fun handleNext() {&#10;        scope.launch {&#10;            isProcessing = true&#10;            // Trigger a crop to persist current crop box before saving adjustments&#10;            val maybeCropped = cropWithUCropViewIfPresent(currentImageUri)&#10;            if (maybeCropped != null) {&#10;                croppedImageUris = croppedImageUris + (currentImageIndex to maybeCropped)&#10;            }&#10;            val editedUri = saveEditedImage()&#10;            if (editedUri != null) {&#10;                editedImages = editedImages + editedUri&#10;                if (currentImageIndex &lt; selectedImages.size - 1) {&#10;                    currentImageIndex++&#10;                    editState = ImageEditState()&#10;                } else {&#10;                    onImagesCropped(editedImages)&#10;                }&#10;            }&#10;            isProcessing = false&#10;        }&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.Black)&#10;    ) {&#10;        Column(modifier = Modifier.fillMaxSize()) {&#10;            // Top Bar&#10;            Surface(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                color = Color.Black.copy(alpha = 0.8f)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .statusBarsPadding()&#10;                        .padding(horizontal = 8.dp, vertical = 12.dp),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    IconButton(onClick = onBack) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Back&quot;,&#10;                            tint = Color.White&#10;                        )&#10;                    }&#10;&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#10;                        // Page indicator&#10;                        if (selectedImages.size &gt; 1) {&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .background(Color.White.copy(alpha = 0.2f), RoundedCornerShape(12.dp))&#10;                                    .padding(horizontal = 12.dp, vertical = 6.dp)&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;${currentImageIndex + 1}/${selectedImages.size}&quot;,&#10;                                    color = Color.White,&#10;                                    fontSize = 14.sp&#10;                                )&#10;                            }&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                        }&#10;&#10;                        TextButton(&#10;                            onClick = { handleNext() },&#10;                            enabled = !isProcessing&#10;                        ) {&#10;                            if (isProcessing) {&#10;                                CircularProgressIndicator(&#10;                                    modifier = Modifier.size(20.dp),&#10;                                    color = Color.White,&#10;                                    strokeWidth = 2.dp&#10;                                )&#10;                            } else {&#10;                                Text(&#10;                                    text = if (currentImageIndex &lt; selectedImages.size - 1) &quot;Next&quot; else &quot;Done&quot;,&#10;                                    color = Color.Red,&#10;                                    fontWeight = FontWeight.Bold,&#10;                                    fontSize = 16.sp&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Image Editor Area&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .weight(1f)&#10;                    .background(Color.Black),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                if (currentImageUri != null) {&#10;                    if (editMode == EditMode.CROP) {&#10;                        AndroidView(&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            factory = { ctx: Context -&gt;&#10;                                UCropView(ctx, null).also { view -&gt;&#10;                                    uCropViewRef = view&#10;                                    configureUCropView(view, currentImageUri)&#10;                                }&#10;                            },&#10;                            update = { view: UCropView -&gt;&#10;                                configureUCropView(view, currentImageUri)&#10;                            }&#10;                        )&#10;                    } else {&#10;                        ImageEditCanvas(&#10;                            imageUri = currentImageUri,&#10;                            editState = editState,&#10;                            onEditStateChange = { editState = it }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Edit Mode Selector with controls&#10;            EditModeSelector(&#10;                selectedMode = editMode,&#10;                onModeSelected = { editMode = it },&#10;                editState = editState,&#10;                onEditStateChange = { editState = it },&#10;                onRotate = {&#10;                    uCropViewRef?.cropImageView?.postRotate(-90f)&#10;                    uCropViewRef?.cropImageView?.setImageToWrapCropBounds(true)&#10;                },&#10;                onRotateFine = { degrees -&gt;&#10;                    uCropViewRef?.cropImageView?.postRotate(degrees)&#10;                    uCropViewRef?.cropImageView?.setImageToWrapCropBounds(true)&#10;                },&#10;                onFlipH = {&#10;                    val src = currentImageUri ?: return@EditModeSelector&#10;                    scope.launch {&#10;                        val flippedUri = flipCurrentImageHorizontal(src)&#10;                        flippedUri?.let { uri -&gt;&#10;                            val updated = croppedImageUris.toMutableMap()&#10;                            updated[currentImageIndex] = uri&#10;                            croppedImageUris = updated.toMap()&#10;                            uCropViewRef?.let { configureUCropView(it, uri) }&#10;                        }&#10;                    }&#10;                }&#10;            )&#10;&#10;            // Controls (only for non-crop modes)&#10;            when (editMode) {&#10;                EditMode.CROP -&gt; { /* Controls now integrated in EditModeSelector */ }&#10;                EditMode.FILTER -&gt; FilterControls(editState, onEditStateChange = { editState = it })&#10;                EditMode.ADJUST -&gt; AdjustControls(editState, onEditStateChange = { editState = it })&#10;                EditMode.STICKER -&gt; StickerControls()&#10;                EditMode.MORE -&gt; MoreControls()&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ImageEditCanvas(&#10;    imageUri: Uri,&#10;    editState: ImageEditState,&#10;    onEditStateChange: (ImageEditState) -&gt; Unit&#10;) {&#10;    var scale by remember { mutableFloatStateOf(editState.scale) }&#10;    var offsetX by remember { mutableFloatStateOf(editState.offsetX) }&#10;    var offsetY by remember { mutableFloatStateOf(editState.offsetY) }&#10;    var rotation by remember { mutableFloatStateOf(editState.rotation) }&#10;&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        // Image layer with transform gestures&#10;        Image(&#10;            painter = rememberAsyncImagePainter(imageUri),&#10;            contentDescription = null,&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .pointerInput(Unit) {&#10;                    detectTransformGestures { _, pan, zoom, rotationDelta -&gt;&#10;                        scale = (scale * zoom).coerceIn(0.3f, 4f)&#10;                        offsetX += pan.x&#10;                        offsetY += pan.y&#10;                        rotation += rotationDelta&#10;&#10;                        onEditStateChange(&#10;                            editState.copy(&#10;                                scale = scale,&#10;                                offsetX = offsetX,&#10;                                offsetY = offsetY,&#10;                                rotation = rotation&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;                .graphicsLayer(&#10;                    scaleX = scale * if (editState.flipHorizontal) -1f else 1f,&#10;                    scaleY = scale * if (editState.flipVertical) -1f else 1f,&#10;                    rotationZ = rotation,&#10;                    translationX = offsetX,&#10;                    translationY = offsetY&#10;                ),&#10;            contentScale = ContentScale.Fit,&#10;            colorFilter = ColorFilter.colorMatrix(&#10;                androidx.compose.ui.graphics.ColorMatrix().apply {&#10;                    val brightness = editState.brightness * 255&#10;                    val contrastMatrix = androidx.compose.ui.graphics.ColorMatrix(floatArrayOf(&#10;                        editState.contrast, 0f, 0f, 0f, brightness,&#10;                        0f, editState.contrast, 0f, 0f, brightness,&#10;                        0f, 0f, editState.contrast, 0f, brightness,&#10;                        0f, 0f, 0f, 1f, 0f&#10;                    ))&#10;                    val saturationMatrix = androidx.compose.ui.graphics.ColorMatrix().apply {&#10;                        setToSaturation(editState.saturation)&#10;                    }&#10;                    this.timesAssign(contrastMatrix)&#10;                    this.timesAssign(saturationMatrix)&#10;                }&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EditModeSelector(&#10;    selectedMode: EditMode,&#10;    onModeSelected: (EditMode) -&gt; Unit,&#10;    editState: ImageEditState,&#10;    onEditStateChange: (ImageEditState) -&gt; Unit,&#10;    onRotate: () -&gt; Unit = {},&#10;    onRotateFine: (Float) -&gt; Unit = {},&#10;    onFlipH: () -&gt; Unit = {}&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .background(Color.Black.copy(alpha = 0.9f))&#10;            .navigationBarsPadding()&#10;    ) {&#10;        // TOP: Rotation and Flip buttons + slider section (fixed height to keep bottom buttons stable)&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(if (selectedMode == EditMode.CROP) 140.dp else 0.dp)&#10;        ) {&#10;            if (selectedMode == EditMode.CROP) {&#10;                Column(&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    // Rotation and Flip buttons&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(top = 12.dp, bottom = 8.dp),&#10;                        horizontalArrangement = Arrangement.SpaceEvenly,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        IconButton(&#10;                            onClick = onRotate,&#10;                            modifier = Modifier.size(48.dp).background(Color.White.copy(alpha = 0.15f), CircleShape)&#10;                        ) {&#10;                            Icon(imageVector = Icons.AutoMirrored.Filled.RotateLeft, contentDescription = &quot;Rotate -90&quot;, tint = Color.White)&#10;                        }&#10;                        IconButton(&#10;                            onClick = onFlipH,&#10;                            modifier = Modifier.size(48.dp).background(Color.White.copy(alpha = 0.15f), CircleShape)&#10;                        ) {&#10;                            Icon(imageVector = Icons.Default.Flip, contentDescription = &quot;Flip H&quot;, tint = Color.White)&#10;                        }&#10;                    }&#10;&#10;                    // MIDDLE: Horizontal scrollbar for fine-tuning rotation&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(horizontal = 16.dp, vertical = 8.dp)&#10;                    ) {&#10;                        RotationSliderWithLines(&#10;                            value = editState.rotation,&#10;                            onValueChange = { newValue -&gt;&#10;                                val delta = newValue - editState.rotation&#10;                                onRotateFine(delta)&#10;                                onEditStateChange(editState.copy(rotation = newValue))&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // BOTTOM: Mode selector buttons (always at the same position)&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 12.dp),&#10;            horizontalArrangement = Arrangement.SpaceEvenly&#10;        ) {&#10;            EditModeButton(&#10;                icon = Icons.Default.CropRotate,&#10;                label = &quot;Crop&quot;,&#10;                isSelected = selectedMode == EditMode.CROP,&#10;                onClick = { onModeSelected(EditMode.CROP) }&#10;            )&#10;            EditModeButton(&#10;                icon = Icons.Default.FilterList,&#10;                label = &quot;Filter&quot;,&#10;                isSelected = selectedMode == EditMode.FILTER,&#10;                onClick = { onModeSelected(EditMode.FILTER) }&#10;            )&#10;            EditModeButton(&#10;                icon = Icons.Default.Tune,&#10;                label = &quot;Adjust&quot;,&#10;                isSelected = selectedMode == EditMode.ADJUST,&#10;                onClick = { onModeSelected(EditMode.ADJUST) }&#10;            )&#10;            EditModeButton(&#10;                icon = Icons.Default.EmojiEmotions,&#10;                label = &quot;Sticker&quot;,&#10;                isSelected = selectedMode == EditMode.STICKER,&#10;                onClick = { onModeSelected(EditMode.STICKER) }&#10;            )&#10;            EditModeButton(&#10;                icon = Icons.Default.MoreHoriz,&#10;                label = &quot;More&quot;,&#10;                isSelected = selectedMode == EditMode.MORE,&#10;                onClick = { onModeSelected(EditMode.MORE) }&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EditModeButton(&#10;    icon: androidx.compose.ui.graphics.vector.ImageVector,&#10;    label: String,&#10;    isSelected: Boolean,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        modifier = Modifier&#10;            .clickable(onClick = onClick)&#10;            .padding(horizontal = 8.dp)&#10;    ) {&#10;        Icon(&#10;            imageVector = icon,&#10;            contentDescription = label,&#10;            tint = if (isSelected) Color(0xFFFFD700) else Color.White.copy(alpha = 0.6f),&#10;            modifier = Modifier.size(24.dp)&#10;        )&#10;        Spacer(modifier = Modifier.height(4.dp))&#10;        Text(&#10;            text = label,&#10;            color = if (isSelected) Color(0xFFFFD700) else Color.White.copy(alpha = 0.6f),&#10;            fontSize = 11.sp&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun RotationSliderWithLines(&#10;    value: Float,&#10;    onValueChange: (Float) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    var dragOffset by remember { mutableFloatStateOf(0f) }&#10;    val lineSpacing = 4.dp&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .height(60.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        // Scrollable lines background&#10;        Canvas(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(50.dp)&#10;                .pointerInput(Unit) {&#10;                    detectTransformGestures { _, pan, _, _ -&gt;&#10;                        dragOffset += pan.x&#10;                        // Map drag to rotation value (-180 to 180)&#10;                        val sensitivity = 0.5f&#10;                        val newValue = (value - pan.x * sensitivity).coerceIn(-180f, 180f)&#10;                        onValueChange(newValue)&#10;                    }&#10;                }&#10;        ) {&#10;            val centerX = size.width / 2f&#10;            val lineSpacingPx = lineSpacing.toPx()&#10;&#10;            // Calculate offset based on rotation value&#10;            val pixelsPerDegree = lineSpacingPx&#10;            val scrollOffset = value * pixelsPerDegree&#10;&#10;            // Draw vertical lines&#10;            for (i in -200..200) {&#10;                val xPos = centerX + (i * lineSpacingPx) - scrollOffset&#10;&#10;                if (xPos &gt;= 0 &amp;&amp; xPos &lt;= size.width) {&#10;                    val degree = i&#10;&#10;                    // Determine line height based on position&#10;                    val lineHeight = when {&#10;                        degree % 45 == 0 -&gt; size.height * 0.7f // Major marks&#10;                        degree % 15 == 0 -&gt; size.height * 0.5f // Medium marks&#10;                        degree % 5 == 0 -&gt; size.height * 0.35f // Minor marks&#10;                        else -&gt; size.height * 0.25f // Smallest marks&#10;                    }&#10;&#10;                    // Determine color - center line is highlighted&#10;                    val distanceFromCenter = kotlin.math.abs(xPos - centerX)&#10;                    val alpha = if (distanceFromCenter &lt; 3f) 1f else 0.4f&#10;                    val color = if (distanceFromCenter &lt; 3f) {&#10;                        Color(0xFFFFD700) // Gold for center&#10;                    } else {&#10;                        Color.White.copy(alpha = alpha)&#10;                    }&#10;&#10;                    val yStart = (size.height - lineHeight) / 2f&#10;                    val yEnd = yStart + lineHeight&#10;&#10;                    drawLine(&#10;                        color = color,&#10;                        start = Offset(xPos, yStart),&#10;                        end = Offset(xPos, yEnd),&#10;                        strokeWidth = if (distanceFromCenter &lt; 3f) 3f else 1.5f&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Draw center indicator line (fixed position)&#10;            drawLine(&#10;                color = Color(0xFFFFD700),&#10;                start = Offset(centerX, 0f),&#10;                end = Offset(centerX, size.height),&#10;                strokeWidth = 3f&#10;            )&#10;        }&#10;&#10;        // Degree value display&#10;        Text(&#10;            text = &quot;${value.toInt()}°&quot;,&#10;            color = Color.White,&#10;            fontSize = 12.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            modifier = Modifier&#10;                .align(Alignment.BottomCenter)&#10;                .padding(bottom = 4.dp)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun FilterControls(&#10;    editState: ImageEditState,&#10;    onEditStateChange: (ImageEditState) -&gt; Unit&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .background(Color.Black.copy(alpha = 0.9f))&#10;            .padding(16.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Filters&quot;,&#10;            color = Color.White,&#10;            fontSize = 14.sp,&#10;            modifier = Modifier.padding(bottom = 12.dp)&#10;        )&#10;&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceEvenly&#10;        ) {&#10;            FilterPreset(&quot;Original&quot;, onClick = {&#10;                onEditStateChange(editState.copy(brightness = 0f, contrast = 1f, saturation = 1f))&#10;            })&#10;            FilterPreset(&quot;Bright&quot;, onClick = {&#10;                onEditStateChange(editState.copy(brightness = 0.2f, contrast = 1.1f, saturation = 1.2f))&#10;            })&#10;            FilterPreset(&quot;Dark&quot;, onClick = {&#10;                onEditStateChange(editState.copy(brightness = -0.2f, contrast = 1.2f, saturation = 0.8f))&#10;            })&#10;            FilterPreset(&quot;B&amp;W&quot;, onClick = {&#10;                onEditStateChange(editState.copy(saturation = 0f, contrast = 1.3f))&#10;            })&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun FilterPreset(label: String, onClick: () -&gt; Unit) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        modifier = Modifier.clickable(onClick = onClick)&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .size(60.dp)&#10;                .background(Color.Gray, RoundedCornerShape(8.dp))&#10;                .border(1.dp, Color.White.copy(alpha = 0.3f), RoundedCornerShape(8.dp))&#10;        )&#10;        Spacer(modifier = Modifier.height(4.dp))&#10;        Text(&#10;            text = label,&#10;            color = Color.White,&#10;            fontSize = 11.sp&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun AdjustControls(&#10;    editState: ImageEditState,&#10;    onEditStateChange: (ImageEditState) -&gt; Unit&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .background(Color.Black.copy(alpha = 0.9f))&#10;            .navigationBarsPadding()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Brightness&#10;        Text(&#10;            text = &quot;Brightness&quot;,&#10;            color = Color.White,&#10;            fontSize = 14.sp&#10;        )&#10;        Slider(&#10;            value = editState.brightness,&#10;            onValueChange = { onEditStateChange(editState.copy(brightness = it)) },&#10;            valueRange = -0.5f..0.5f,&#10;            colors = SliderDefaults.colors(&#10;                thumbColor = Color(0xFFFFD700),&#10;                activeTrackColor = Color(0xFFFFD700)&#10;            )&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Contrast&#10;        Text(&#10;            text = &quot;Contrast&quot;,&#10;            color = Color.White,&#10;            fontSize = 14.sp&#10;        )&#10;        Slider(&#10;            value = editState.contrast,&#10;            onValueChange = { onEditStateChange(editState.copy(contrast = it)) },&#10;            valueRange = 0.5f..2f,&#10;            colors = SliderDefaults.colors(&#10;                thumbColor = Color(0xFFFFD700),&#10;                activeTrackColor = Color(0xFFFFD700)&#10;            )&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // Saturation&#10;        Text(&#10;            text = &quot;Saturation&quot;,&#10;            color = Color.White,&#10;            fontSize = 14.sp&#10;        )&#10;        Slider(&#10;            value = editState.saturation,&#10;            onValueChange = { onEditStateChange(editState.copy(saturation = it)) },&#10;            valueRange = 0f..2f,&#10;            colors = SliderDefaults.colors(&#10;                thumbColor = Color(0xFFFFD700),&#10;                activeTrackColor = Color(0xFFFFD700)&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun StickerControls() {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .background(Color.Black.copy(alpha = 0.9f))&#10;            .navigationBarsPadding()&#10;            .padding(16.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;Stickers coming soon...&quot;,&#10;            color = Color.White.copy(alpha = 0.5f),&#10;            fontSize = 14.sp&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MoreControls() {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .background(Color.Black.copy(alpha = 0.9f))&#10;            .navigationBarsPadding()&#10;            .padding(16.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;More options coming soon...&quot;,&#10;            color = Color.White.copy(alpha = 0.5f),&#10;            fontSize = 14.sp&#10;        )&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>