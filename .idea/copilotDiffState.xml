<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/secretspaces32/android/ui/navigation/SecretSpacesApp.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/secretspaces32/android/ui/navigation/SecretSpacesApp.kt" />
              <option name="originalContent" value="package com.secretspaces32.android.ui.navigation&#10;&#10;import android.Manifest&#10;import android.widget.Toast&#10;import androidx.compose.runtime.*&#10;import androidx.compose.runtime.saveable.rememberSaveable&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.secretspaces32.android.viewmodel.MainViewModel&#10;import com.secretspaces32.android.ui.screens.*&#10;import com.google.accompanist.permissions.ExperimentalPermissionsApi&#10;import com.google.accompanist.permissions.rememberMultiplePermissionsState&#10;import androidx.credentials.CredentialManager&#10;import androidx.credentials.GetCredentialRequest&#10;import androidx.credentials.CustomCredential&#10;import com.google.android.libraries.identity.googleid.GetGoogleIdOption&#10;import com.google.android.libraries.identity.googleid.GoogleIdTokenCredential&#10;import com.google.android.libraries.identity.googleid.GoogleIdTokenParsingException&#10;import kotlinx.coroutines.launch&#10;&#10;enum class Screen {&#10;    Auth,&#10;    Feed,&#10;    Map,&#10;    DropSecret,&#10;    Profile,&#10;    MySecrets,&#10;    SecretDetail&#10;}&#10;&#10;@OptIn(ExperimentalPermissionsApi::class)&#10;@Composable&#10;fun SecretSpacesApp() {&#10;    val context = LocalContext.current&#10;    val viewModel: MainViewModel = viewModel(&#10;        factory = object : androidx.lifecycle.ViewModelProvider.Factory {&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;            override fun &lt;T : androidx.lifecycle.ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;                return MainViewModel(context) as T&#10;            }&#10;        }&#10;    )&#10;&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    var selectedScreen by remember { mutableStateOf(Screen.Feed) }&#10;&#10;    // Persist the sheet state at navigation level so it survives screen changes&#10;    var mapSheetState by rememberSaveable { mutableStateOf(&quot;COLLAPSED&quot;) }&#10;&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val credentialManager = remember { CredentialManager.create(context) }&#10;&#10;    // Location permissions&#10;    val locationPermissions = rememberMultiplePermissionsState(&#10;        permissions = listOf(&#10;            Manifest.permission.ACCESS_FINE_LOCATION,&#10;            Manifest.permission.ACCESS_COARSE_LOCATION&#10;        )&#10;    )&#10;&#10;    // Initialize location immediately when authenticated&#10;    LaunchedEffect(uiState.isAuthenticated) {&#10;        if (uiState.isAuthenticated) {&#10;            try {&#10;                println(&quot;DEBUG: App authenticated, calling updateLocation&quot;)&#10;                // Call updateLocation immediately - it will use default location if no permission&#10;                viewModel.updateLocation()&#10;&#10;                // Then request permissions for better accuracy&#10;                if (!locationPermissions.allPermissionsGranted) {&#10;                    println(&quot;DEBUG: Launching permission request&quot;)&#10;                    kotlinx.coroutines.delay(500) // Small delay to let UI settle&#10;                    locationPermissions.launchMultiplePermissionRequest()&#10;                }&#10;            } catch (e: Exception) {&#10;                println(&quot;DEBUG: Error in authentication flow: ${e.message}&quot;)&#10;                e.printStackTrace()&#10;            }&#10;        }&#10;    }&#10;&#10;    // Update location when permissions are granted&#10;    LaunchedEffect(locationPermissions.allPermissionsGranted) {&#10;        if (locationPermissions.allPermissionsGranted &amp;&amp; uiState.isAuthenticated) {&#10;            try {&#10;                println(&quot;DEBUG: Permissions granted, updating to real location&quot;)&#10;                kotlinx.coroutines.delay(300) // Small delay after permission grant&#10;                viewModel.updateLocation()&#10;            } catch (e: Exception) {&#10;                println(&quot;DEBUG: Error updating location: ${e.message}&quot;)&#10;                e.printStackTrace()&#10;            }&#10;        }&#10;    }&#10;&#10;    // Show error messages&#10;    LaunchedEffect(uiState.errorMessage) {&#10;        uiState.errorMessage?.let { message -&gt;&#10;            try {&#10;                Toast.makeText(context, message, Toast.LENGTH_LONG).show()&#10;                viewModel.clearError()&#10;            } catch (e: Exception) {&#10;                println(&quot;DEBUG: Error showing toast: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Show authentication screen if not authenticated&#10;    if (!uiState.isAuthenticated) {&#10;        AuthScreen(&#10;            onSignIn = { email, password -&gt;&#10;                viewModel.signIn(email, password)&#10;            },&#10;            onSignUp = { email, password, username -&gt;&#10;                viewModel.signUp(email, password, username)&#10;            },&#10;            onGoogleSignIn = {&#10;                coroutineScope.launch {&#10;                    try {&#10;                        println(&quot;DEBUG: Starting Google Sign-In process&quot;)&#10;&#10;                        // Configure Google ID option with your Web Client ID from Firebase Console&#10;                        val googleIdOption = GetGoogleIdOption.Builder()&#10;                            .setFilterByAuthorizedAccounts(false)&#10;                            .setServerClientId(&quot;170496527031-ul59lq2gqm76re4an5p2lftol7g3hjfl.apps.googleusercontent.com&quot;)&#10;                            .build()&#10;&#10;                        println(&quot;DEBUG: GoogleIdOption built, creating request&quot;)&#10;&#10;                        val request = GetCredentialRequest.Builder()&#10;                            .addCredentialOption(googleIdOption)&#10;                            .build()&#10;&#10;                        println(&quot;DEBUG: Requesting credentials from CredentialManager&quot;)&#10;&#10;                        val result = credentialManager.getCredential(&#10;                            request = request,&#10;                            context = context&#10;                        )&#10;&#10;                        println(&quot;DEBUG: Credential received, type: ${result.credential.type}&quot;)&#10;&#10;                        when (val credential = result.credential) {&#10;                            is CustomCredential -&gt; {&#10;                                if (credential.type == GoogleIdTokenCredential.TYPE_GOOGLE_ID_TOKEN_CREDENTIAL) {&#10;                                    try {&#10;                                        // Use GoogleIdTokenCredential.createFrom to parse the custom credential&#10;                                        val googleIdTokenCredential = GoogleIdTokenCredential.createFrom(credential.data)&#10;                                        val idToken = googleIdTokenCredential.idToken&#10;                                        println(&quot;DEBUG: Google ID Token extracted from CustomCredential, signing in with Firebase&quot;)&#10;                                        viewModel.signInWithGoogle(idToken)&#10;                                    } catch (e: GoogleIdTokenParsingException) {&#10;                                        println(&quot;DEBUG: Error parsing Google ID Token: ${e.message}&quot;)&#10;                                        Toast.makeText(&#10;                                            context,&#10;                                            &quot;Error parsing Google credentials&quot;,&#10;                                            Toast.LENGTH_SHORT&#10;                                        ).show()&#10;                                    }&#10;                                } else {&#10;                                    println(&quot;DEBUG: Unexpected custom credential type: ${credential.type}&quot;)&#10;                                    Toast.makeText(&#10;                                        context,&#10;                                        &quot;Unexpected credential type: ${credential.type}&quot;,&#10;                                        Toast.LENGTH_SHORT&#10;                                    ).show()&#10;                                }&#10;                            }&#10;                            else -&gt; {&#10;                                println(&quot;DEBUG: Credential is not CustomCredential: ${credential.javaClass.name}&quot;)&#10;                                Toast.makeText(&#10;                                    context,&#10;                                    &quot;Unexpected credential format&quot;,&#10;                                    Toast.LENGTH_SHORT&#10;                                ).show()&#10;                            }&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        println(&quot;DEBUG: Google Sign-In error: ${e.javaClass.simpleName}&quot;)&#10;                        println(&quot;DEBUG: Error message: ${e.message}&quot;)&#10;                        e.printStackTrace()&#10;&#10;                        val errorMessage = when {&#10;                            e.message?.contains(&quot;16&quot;) == true -&gt; &quot;Google Sign-In not configured. Enable it in Firebase Console.&quot;&#10;                            e.message?.contains(&quot;developer console&quot;, ignoreCase = true) == true -&gt;&#10;                                &quot;Please add SHA-1 &amp; SHA-256 to Firebase Console&quot;&#10;                            e.message?.contains(&quot;cancelled&quot;, ignoreCase = true) == true -&gt; &quot;Sign-in cancelled&quot;&#10;                            e.message?.contains(&quot;No credentials&quot;, ignoreCase = true) == true -&gt; &quot;No Google accounts found&quot;&#10;                            else -&gt; &quot;Google Sign-In failed: ${e.message}&quot;&#10;                        }&#10;&#10;                        Toast.makeText(&#10;                            context,&#10;                            errorMessage,&#10;                            Toast.LENGTH_LONG&#10;                        ).show()&#10;                    }&#10;                }&#10;            },&#10;            isLoading = uiState.isLoading,&#10;            isEmailAuthLoading = uiState.isEmailAuthLoading,&#10;            isGoogleAuthLoading = uiState.isGoogleAuthLoading&#10;        )&#10;        return&#10;    }&#10;&#10;    // Main app navigation&#10;    when (selectedScreen) {&#10;        Screen.Feed, Screen.Map, Screen.Profile -&gt; {&#10;            MainScreenContainer(&#10;                currentLocation = uiState.currentLocation,&#10;                nearbySecrets = uiState.secrets,&#10;                currentUser = uiState.currentUser,&#10;                mySecrets = uiState.mySecrets,&#10;                isLoading = uiState.isLoading,&#10;                onSecretClick = { secret -&gt;&#10;                    viewModel.selectSecret(secret)&#10;                    selectedScreen = Screen.SecretDetail&#10;                },&#10;                onDropSecretClick = {&#10;                    selectedScreen = Screen.DropSecret&#10;                },&#10;                onSignOut = {&#10;                    viewModel.signOut()&#10;                    selectedScreen = Screen.Feed&#10;                },&#10;                onUpdateProfile = { username, bio, imageUri -&gt;&#10;                    viewModel.updateProfile(username, bio, imageUri)&#10;                },&#10;                onLikeClick = { secret -&gt;&#10;                    viewModel.toggleLike(secret)&#10;                },&#10;                onLoadMySecrets = {&#10;                    viewModel.loadMySecrets()&#10;                }&#10;            )&#10;        }&#10;&#10;        Screen.DropSecret -&gt; {&#10;            DropSecretScreen(&#10;                isLoading = uiState.isLoading,&#10;                onPostSecret = { text, imageUri, isAnonymous, mood, category, hashtags -&gt;&#10;                    viewModel.createSecret(text, imageUri, isAnonymous, mood, category, hashtags)&#10;                    selectedScreen = Screen.Feed&#10;                },&#10;                onBack = {&#10;                    selectedScreen = Screen.Feed&#10;                },&#10;                cacheDir = context.cacheDir&#10;            )&#10;        }&#10;&#10;        Screen.Profile -&gt; {&#10;            // Load user's secrets when Profile screen is opened&#10;            LaunchedEffect(Unit) {&#10;                viewModel.loadMySecrets()&#10;            }&#10;&#10;            ProfileScreen(&#10;                user = uiState.currentUser,&#10;                mySecrets = uiState.mySecrets,&#10;                onSignOut = {&#10;                    viewModel.signOut()&#10;                    selectedScreen = Screen.Feed&#10;                },&#10;                onUpdateProfile = { username, bio, imageUri -&gt;&#10;                    viewModel.updateProfile(username, bio, imageUri)&#10;                },&#10;                onMySecretsClick = {&#10;                    selectedScreen = Screen.MySecrets&#10;                },&#10;                onBackClick = {&#10;                    selectedScreen = Screen.Feed&#10;                },&#10;                isLoading = uiState.isLoading&#10;            )&#10;        }&#10;&#10;        Screen.MySecrets -&gt; {&#10;            MySecretsScreen(&#10;                secrets = uiState.mySecrets,&#10;                isLoading = uiState.isLoading,&#10;                onSecretClick = { secret -&gt;&#10;                    viewModel.selectSecret(secret)&#10;                    selectedScreen = Screen.SecretDetail&#10;                }&#10;            )&#10;        }&#10;&#10;        Screen.SecretDetail -&gt; {&#10;            uiState.selectedSecret?.let { secret -&gt;&#10;                SecretDetailScreen(&#10;                    secret = secret,&#10;                    comments = uiState.selectedSecretComments,&#10;                    likes = uiState.selectedSecretLikes,&#10;                    isLikedByCurrentUser = secret.isLikedByCurrentUser,&#10;                    onLikeClick = {&#10;                        viewModel.toggleLike(secret)&#10;                    },&#10;                    onCommentSubmit = { commentText -&gt;&#10;                        viewModel.addComment(secret.id, commentText)&#10;                    },&#10;                    onBack = {&#10;                        selectedScreen = Screen.Feed&#10;                    },&#10;                    isLoading = uiState.isLoading&#10;                )&#10;            }&#10;        }&#10;        Screen.Auth -&gt; {&#10;            // Should not reach here as we handle auth above&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.secretspaces32.android.ui.navigation&#10;&#10;import android.Manifest&#10;import android.widget.Toast&#10;import androidx.compose.runtime.*&#10;import androidx.compose.runtime.saveable.rememberSaveable&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.secretspaces32.android.viewmodel.MainViewModel&#10;import com.secretspaces32.android.ui.screens.*&#10;import com.google.accompanist.permissions.ExperimentalPermissionsApi&#10;import com.google.accompanist.permissions.rememberMultiplePermissionsState&#10;import androidx.credentials.CredentialManager&#10;import androidx.credentials.GetCredentialRequest&#10;import androidx.credentials.CustomCredential&#10;import com.google.android.libraries.identity.googleid.GetGoogleIdOption&#10;import com.google.android.libraries.identity.googleid.GoogleIdTokenCredential&#10;import com.google.android.libraries.identity.googleid.GoogleIdTokenParsingException&#10;import kotlinx.coroutines.launch&#10;&#10;enum class Screen {&#10;    Auth,&#10;    Feed,&#10;    Map,&#10;    DropSecret,&#10;    Profile,&#10;    MySecrets,&#10;    SecretDetail&#10;}&#10;&#10;@OptIn(ExperimentalPermissionsApi::class)&#10;@Composable&#10;fun SecretSpacesApp() {&#10;    val context = LocalContext.current&#10;    val viewModel: MainViewModel = viewModel(&#10;        factory = object : androidx.lifecycle.ViewModelProvider.Factory {&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;            override fun &lt;T : androidx.lifecycle.ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;                return MainViewModel(context) as T&#10;            }&#10;        }&#10;    )&#10;&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    var selectedScreen by remember { mutableStateOf(Screen.Feed) }&#10;&#10;    // Persist the sheet state at navigation level so it survives screen changes&#10;    var mapSheetState by rememberSaveable { mutableStateOf(&quot;COLLAPSED&quot;) }&#10;&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val credentialManager = remember { CredentialManager.create(context) }&#10;&#10;    // Location permissions - removed automatic request&#10;    // Permissions will be requested from MapScreen when user navigates there&#10;&#10;    // Initialize with default location when authenticated&#10;    LaunchedEffect(uiState.isAuthenticated) {&#10;        if (uiState.isAuthenticated) {&#10;            try {&#10;                println(&quot;DEBUG: App authenticated, initializing with default location&quot;)&#10;                // Call updateLocation - it will use default location if no permission&#10;                viewModel.updateLocation()&#10;            } catch (e: Exception) {&#10;                println(&quot;DEBUG: Error in authentication flow: ${e.message}&quot;)&#10;                e.printStackTrace()&#10;            }&#10;        }&#10;    }&#10;&#10;    // Show error messages&#10;    LaunchedEffect(uiState.errorMessage) {&#10;        uiState.errorMessage?.let { message -&gt;&#10;            try {&#10;                Toast.makeText(context, message, Toast.LENGTH_LONG).show()&#10;                viewModel.clearError()&#10;            } catch (e: Exception) {&#10;                println(&quot;DEBUG: Error showing toast: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Show authentication screen if not authenticated&#10;    if (!uiState.isAuthenticated) {&#10;        AuthScreen(&#10;            onSignIn = { email, password -&gt;&#10;                viewModel.signIn(email, password)&#10;            },&#10;            onSignUp = { email, password, username -&gt;&#10;                viewModel.signUp(email, password, username)&#10;            },&#10;            onGoogleSignIn = {&#10;                coroutineScope.launch {&#10;                    try {&#10;                        println(&quot;DEBUG: Starting Google Sign-In process&quot;)&#10;&#10;                        // Configure Google ID option with your Web Client ID from Firebase Console&#10;                        val googleIdOption = GetGoogleIdOption.Builder()&#10;                            .setFilterByAuthorizedAccounts(false)&#10;                            .setServerClientId(&quot;170496527031-ul59lq2gqm76re4an5p2lftol7g3hjfl.apps.googleusercontent.com&quot;)&#10;                            .build()&#10;&#10;                        println(&quot;DEBUG: GoogleIdOption built, creating request&quot;)&#10;&#10;                        val request = GetCredentialRequest.Builder()&#10;                            .addCredentialOption(googleIdOption)&#10;                            .build()&#10;&#10;                        println(&quot;DEBUG: Requesting credentials from CredentialManager&quot;)&#10;&#10;                        val result = credentialManager.getCredential(&#10;                            request = request,&#10;                            context = context&#10;                        )&#10;&#10;                        println(&quot;DEBUG: Credential received, type: ${result.credential.type}&quot;)&#10;&#10;                        when (val credential = result.credential) {&#10;                            is CustomCredential -&gt; {&#10;                                if (credential.type == GoogleIdTokenCredential.TYPE_GOOGLE_ID_TOKEN_CREDENTIAL) {&#10;                                    try {&#10;                                        // Use GoogleIdTokenCredential.createFrom to parse the custom credential&#10;                                        val googleIdTokenCredential = GoogleIdTokenCredential.createFrom(credential.data)&#10;                                        val idToken = googleIdTokenCredential.idToken&#10;                                        println(&quot;DEBUG: Google ID Token extracted from CustomCredential, signing in with Firebase&quot;)&#10;                                        viewModel.signInWithGoogle(idToken)&#10;                                    } catch (e: GoogleIdTokenParsingException) {&#10;                                        println(&quot;DEBUG: Error parsing Google ID Token: ${e.message}&quot;)&#10;                                        Toast.makeText(&#10;                                            context,&#10;                                            &quot;Error parsing Google credentials&quot;,&#10;                                            Toast.LENGTH_SHORT&#10;                                        ).show()&#10;                                    }&#10;                                } else {&#10;                                    println(&quot;DEBUG: Unexpected custom credential type: ${credential.type}&quot;)&#10;                                    Toast.makeText(&#10;                                        context,&#10;                                        &quot;Unexpected credential type: ${credential.type}&quot;,&#10;                                        Toast.LENGTH_SHORT&#10;                                    ).show()&#10;                                }&#10;                            }&#10;                            else -&gt; {&#10;                                println(&quot;DEBUG: Credential is not CustomCredential: ${credential.javaClass.name}&quot;)&#10;                                Toast.makeText(&#10;                                    context,&#10;                                    &quot;Unexpected credential format&quot;,&#10;                                    Toast.LENGTH_SHORT&#10;                                ).show()&#10;                            }&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        println(&quot;DEBUG: Google Sign-In error: ${e.javaClass.simpleName}&quot;)&#10;                        println(&quot;DEBUG: Error message: ${e.message}&quot;)&#10;                        e.printStackTrace()&#10;&#10;                        val errorMessage = when {&#10;                            e.message?.contains(&quot;16&quot;) == true -&gt; &quot;Google Sign-In not configured. Enable it in Firebase Console.&quot;&#10;                            e.message?.contains(&quot;developer console&quot;, ignoreCase = true) == true -&gt;&#10;                                &quot;Please add SHA-1 &amp; SHA-256 to Firebase Console&quot;&#10;                            e.message?.contains(&quot;cancelled&quot;, ignoreCase = true) == true -&gt; &quot;Sign-in cancelled&quot;&#10;                            e.message?.contains(&quot;No credentials&quot;, ignoreCase = true) == true -&gt; &quot;No Google accounts found&quot;&#10;                            else -&gt; &quot;Google Sign-In failed: ${e.message}&quot;&#10;                        }&#10;&#10;                        Toast.makeText(&#10;                            context,&#10;                            errorMessage,&#10;                            Toast.LENGTH_LONG&#10;                        ).show()&#10;                    }&#10;                }&#10;            },&#10;            isLoading = uiState.isLoading,&#10;            isEmailAuthLoading = uiState.isEmailAuthLoading,&#10;            isGoogleAuthLoading = uiState.isGoogleAuthLoading&#10;        )&#10;        return&#10;    }&#10;&#10;    // Main app navigation&#10;    when (selectedScreen) {&#10;        Screen.Feed, Screen.Map, Screen.Profile -&gt; {&#10;            MainScreenContainer(&#10;                currentLocation = uiState.currentLocation,&#10;                nearbySecrets = uiState.secrets,&#10;                currentUser = uiState.currentUser,&#10;                mySecrets = uiState.mySecrets,&#10;                isLoading = uiState.isLoading,&#10;                onSecretClick = { secret -&gt;&#10;                    viewModel.selectSecret(secret)&#10;                    selectedScreen = Screen.SecretDetail&#10;                },&#10;                onDropSecretClick = {&#10;                    selectedScreen = Screen.DropSecret&#10;                },&#10;                onSignOut = {&#10;                    viewModel.signOut()&#10;                    selectedScreen = Screen.Feed&#10;                },&#10;                onUpdateProfile = { username, bio, imageUri -&gt;&#10;                    viewModel.updateProfile(username, bio, imageUri)&#10;                },&#10;                onLikeClick = { secret -&gt;&#10;                    viewModel.toggleLike(secret)&#10;                },&#10;                onLoadMySecrets = {&#10;                    viewModel.loadMySecrets()&#10;                },&#10;                onLocationPermissionGranted = {&#10;                    viewModel.updateLocation()&#10;                }&#10;            )&#10;        }&#10;&#10;        Screen.DropSecret -&gt; {&#10;            DropSecretScreen(&#10;                isLoading = uiState.isLoading,&#10;                onPostSecret = { text, imageUri, isAnonymous, mood, category, hashtags -&gt;&#10;                    viewModel.createSecret(text, imageUri, isAnonymous, mood, category, hashtags)&#10;                    selectedScreen = Screen.Feed&#10;                },&#10;                onBack = {&#10;                    selectedScreen = Screen.Feed&#10;                },&#10;                cacheDir = context.cacheDir&#10;            )&#10;        }&#10;&#10;        Screen.Profile -&gt; {&#10;            // Load user's secrets when Profile screen is opened&#10;            LaunchedEffect(Unit) {&#10;                viewModel.loadMySecrets()&#10;            }&#10;&#10;            ProfileScreen(&#10;                user = uiState.currentUser,&#10;                mySecrets = uiState.mySecrets,&#10;                onSignOut = {&#10;                    viewModel.signOut()&#10;                    selectedScreen = Screen.Feed&#10;                },&#10;                onUpdateProfile = { username, bio, imageUri -&gt;&#10;                    viewModel.updateProfile(username, bio, imageUri)&#10;                },&#10;                onMySecretsClick = {&#10;                    selectedScreen = Screen.MySecrets&#10;                },&#10;                onBackClick = {&#10;                    selectedScreen = Screen.Feed&#10;                },&#10;                isLoading = uiState.isLoading&#10;            )&#10;        }&#10;&#10;        Screen.MySecrets -&gt; {&#10;            MySecretsScreen(&#10;                secrets = uiState.mySecrets,&#10;                isLoading = uiState.isLoading,&#10;                onSecretClick = { secret -&gt;&#10;                    viewModel.selectSecret(secret)&#10;                    selectedScreen = Screen.SecretDetail&#10;                }&#10;            )&#10;        }&#10;&#10;        Screen.SecretDetail -&gt; {&#10;            uiState.selectedSecret?.let { secret -&gt;&#10;                SecretDetailScreen(&#10;                    secret = secret,&#10;                    comments = uiState.selectedSecretComments,&#10;                    likes = uiState.selectedSecretLikes,&#10;                    isLikedByCurrentUser = secret.isLikedByCurrentUser,&#10;                    onLikeClick = {&#10;                        viewModel.toggleLike(secret)&#10;                    },&#10;                    onCommentSubmit = { commentText -&gt;&#10;                        viewModel.addComment(secret.id, commentText)&#10;                    },&#10;                    onBack = {&#10;                        selectedScreen = Screen.Feed&#10;                    },&#10;                    isLoading = uiState.isLoading&#10;                )&#10;            }&#10;        }&#10;        Screen.Auth -&gt; {&#10;            // Should not reach here as we handle auth above&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/secretspaces32/android/ui/screens/MainScreenContainer.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/secretspaces32/android/ui/screens/MainScreenContainer.kt" />
              <option name="originalContent" value="package com.secretspaces32.android.ui.screens&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import com.secretspaces32.android.data.model.Secret&#10;import com.secretspaces32.android.data.model.User&#10;import com.secretspaces32.android.ui.components.*&#10;import android.location.Location&#10;&#10;@Composable&#10;fun MainScreenContainer(&#10;    currentLocation: Location?,&#10;    nearbySecrets: List&lt;Secret&gt;,&#10;    currentUser: User?,&#10;    mySecrets: List&lt;Secret&gt;,&#10;    isLoading: Boolean,&#10;    onSecretClick: (Secret) -&gt; Unit,&#10;    onDropSecretClick: () -&gt; Unit,&#10;    onSignOut: () -&gt; Unit,&#10;    onUpdateProfile: (String, String, android.net.Uri?) -&gt; Unit,&#10;    onLikeClick: (Secret) -&gt; Unit = {},&#10;    onLoadMySecrets: () -&gt; Unit = {}&#10;    var currentDestination by remember { mutableStateOf(NavDestination.HOME) }&#10;    var focusedSecret by remember { mutableStateOf&lt;Secret?&gt;(null) }&#10;&#10;    // Load user secrets when profile is accessed&#10;    LaunchedEffect(currentDestination) {&#10;        if (currentDestination == NavDestination.PROFILE) {&#10;            onLoadMySecrets()&#10;        }&#10;    }&#10;&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Content based on current destination&#10;        when (currentDestination) {&#10;            NavDestination.HOME -&gt; {&#10;                FeedScreen(&#10;                    nearbySecrets = nearbySecrets,&#10;                    isLoading = isLoading,&#10;                    currentUser = currentUser,&#10;                    onSecretClick = onSecretClick,&#10;                    onDropSecretClick = onDropSecretClick,&#10;                    onProfileClick = { currentDestination = NavDestination.PROFILE },&#10;                    onLikeClick = onLikeClick,&#10;                    onMapClick = { secret -&gt;&#10;                        focusedSecret = secret&#10;                        currentDestination = NavDestination.MAP&#10;                    }&#10;                )&#10;            }&#10;&#10;            NavDestination.MAP -&gt; {&#10;                MapScreen(&#10;                    currentLocation = currentLocation,&#10;                    nearbySecrets = nearbySecrets,&#10;                    isLoading = isLoading,&#10;                    onSecretClick = onSecretClick,&#10;                    onDropSecretClick = onDropSecretClick,&#10;                    onProfileClick = { currentDestination = NavDestination.PROFILE },&#10;                    onLikeClick = onLikeClick&#10;                    onLikeClick = onLikeClick&#10;&#10;            NavDestination.CREATE -&gt; {&#10;                // This is handled by navigation to DropSecretScreen&#10;                // So this case should never be reached as we navigate away&#10;            }&#10;&#10;            NavDestination.TRENDS -&gt; {&#10;                TrendsScreen(&#10;                    onProfileClick = { currentDestination = NavDestination.PROFILE }&#10;                )&#10;            }&#10;&#10;            NavDestination.PROFILE -&gt; {&#10;                ProfileScreen(&#10;                    user = currentUser,&#10;                    mySecrets = mySecrets,&#10;                    onSignOut = onSignOut,&#10;                    onUpdateProfile = onUpdateProfile,&#10;                    onMySecretsClick = {&#10;                        // TODO: Navigate to MySecrets if needed&#10;                    },&#10;                    onBackClick = {&#10;                        currentDestination = NavDestination.HOME&#10;                    },&#10;                    isLoading = isLoading&#10;                )&#10;            }&#10;        }&#10;&#10;        // Bottom Navigation Bar - Always visible&#10;        BottomNavigationBar(&#10;            currentDestination = currentDestination,&#10;            onNavigate = { destination -&gt;&#10;                when (destination) {&#10;                    NavDestination.HOME -&gt; {&#10;                        currentDestination = NavDestination.HOME&#10;                    }&#10;                    NavDestination.MAP -&gt; {&#10;                        currentDestination = NavDestination.MAP&#10;                    }&#10;                    NavDestination.CREATE -&gt; {&#10;                        onDropSecretClick()&#10;                    }&#10;                    NavDestination.TRENDS -&gt; {&#10;                        currentDestination = NavDestination.TRENDS&#10;                    }&#10;                    NavDestination.PROFILE -&gt; {&#10;                        currentDestination = NavDestination.PROFILE&#10;                    }&#10;                }&#10;            },&#10;            modifier = Modifier.align(Alignment.BottomCenter)&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.secretspaces32.android.ui.screens&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import com.secretspaces32.android.data.model.Secret&#10;import com.secretspaces32.android.data.model.User&#10;import com.secretspaces32.android.ui.components.*&#10;import android.location.Location&#10;&#10;@Composable&#10;fun MainScreenContainer(&#10;    currentLocation: Location?,&#10;    nearbySecrets: List&lt;Secret&gt;,&#10;    currentUser: User?,&#10;    mySecrets: List&lt;Secret&gt;,&#10;    isLoading: Boolean,&#10;    onSecretClick: (Secret) -&gt; Unit,&#10;    onDropSecretClick: () -&gt; Unit,&#10;    onSignOut: () -&gt; Unit,&#10;    onUpdateProfile: (String, String, android.net.Uri?) -&gt; Unit,&#10;    onLikeClick: (Secret) -&gt; Unit = {},&#10;    onLoadMySecrets: () -&gt; Unit = {},&#10;    onLocationPermissionGranted: () -&gt; Unit = {}&#10;) {&#10;    var currentDestination by remember { mutableStateOf(NavDestination.HOME) }&#10;    var focusedSecret by remember { mutableStateOf&lt;Secret?&gt;(null) }&#10;&#10;    // Load user secrets when profile is accessed&#10;    LaunchedEffect(currentDestination) {&#10;        if (currentDestination == NavDestination.PROFILE) {&#10;            onLoadMySecrets()&#10;        }&#10;    }&#10;&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Content based on current destination&#10;        when (currentDestination) {&#10;            NavDestination.HOME -&gt; {&#10;                FeedScreen(&#10;                    nearbySecrets = nearbySecrets,&#10;                    isLoading = isLoading,&#10;                    currentUser = currentUser,&#10;                    onSecretClick = onSecretClick,&#10;                    onDropSecretClick = onDropSecretClick,&#10;                    onProfileClick = { currentDestination = NavDestination.PROFILE },&#10;                    onLikeClick = onLikeClick,&#10;                    onMapClick = { secret -&gt;&#10;                        focusedSecret = secret&#10;                        currentDestination = NavDestination.MAP&#10;                    }&#10;                )&#10;            }&#10;&#10;            NavDestination.MAP -&gt; {&#10;                MapScreen(&#10;                    currentLocation = currentLocation,&#10;                    nearbySecrets = nearbySecrets,&#10;                    onSecretClick = onSecretClick,&#10;                    onLocationPermissionGranted = onLocationPermissionGranted&#10;                )&#10;            }&#10;&#10;            NavDestination.CREATE -&gt; {&#10;                // This is handled by navigation to DropSecretScreen&#10;                // So this case should never be reached as we navigate away&#10;            }&#10;&#10;            NavDestination.TRENDS -&gt; {&#10;                TrendsScreen(&#10;                    onProfileClick = { currentDestination = NavDestination.PROFILE }&#10;                )&#10;            }&#10;&#10;            NavDestination.PROFILE -&gt; {&#10;                ProfileScreen(&#10;                    user = currentUser,&#10;                    mySecrets = mySecrets,&#10;                    onSignOut = onSignOut,&#10;                    onUpdateProfile = onUpdateProfile,&#10;                    onMySecretsClick = {&#10;                        // TODO: Navigate to MySecrets if needed&#10;                    },&#10;                    onBackClick = {&#10;                        currentDestination = NavDestination.HOME&#10;                    },&#10;                    isLoading = isLoading&#10;                )&#10;            }&#10;        }&#10;&#10;        // Bottom Navigation Bar - Always visible&#10;        BottomNavigationBar(&#10;            currentDestination = currentDestination,&#10;            onNavigate = { destination -&gt;&#10;                when (destination) {&#10;                    NavDestination.HOME -&gt; {&#10;                        currentDestination = NavDestination.HOME&#10;                    }&#10;                    NavDestination.MAP -&gt; {&#10;                        currentDestination = NavDestination.MAP&#10;                    }&#10;                    NavDestination.CREATE -&gt; {&#10;                        onDropSecretClick()&#10;                    }&#10;                    NavDestination.TRENDS -&gt; {&#10;                        currentDestination = NavDestination.TRENDS&#10;                    }&#10;                    NavDestination.PROFILE -&gt; {&#10;                        currentDestination = NavDestination.PROFILE&#10;                    }&#10;                }&#10;            },&#10;            modifier = Modifier.align(Alignment.BottomCenter)&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/secretspaces32/android/ui/screens/MapScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/secretspaces32/android/ui/screens/MapScreen.kt" />
              <option name="originalContent" value="package com.secretspaces32.android.ui.screens&#10;&#10;import android.location.Location&#10;import androidx.compose.animation.*&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.lazy.rememberLazyListState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import com.google.gson.JsonPrimitive&#10;import com.secretspaces32.android.BuildConfig&#10;import com.secretspaces32.android.data.model.Secret&#10;import com.secretspaces32.android.ui.components.*&#10;import com.secretspaces32.android.ui.theme.*&#10;import com.secretspaces32.android.utils.LocationHelper&#10;import kotlinx.coroutines.delay&#10;import org.maplibre.android.MapLibre&#10;import org.maplibre.android.camera.CameraUpdateFactory&#10;import org.maplibre.android.geometry.LatLng&#10;import org.maplibre.android.maps.MapView&#10;import org.maplibre.android.plugins.annotation.SymbolManager&#10;import org.maplibre.android.plugins.annotation.SymbolOptions&#10;&#10;// Define 3 states for the bottom sheet&#10;enum class SheetState { COLLAPSED, HALF_EXPANDED, FULLY_EXPANDED }&#10;&#10;@Composable&#10;fun MapScreen(&#10;    currentLocation: Location?,&#10;    nearbySecrets: List&lt;Secret&gt;,&#10;    onSecretClick: (Secret) -&gt; Unit,&#10;    onSheetStateChange: (String) -&gt; Unit = {},&#10;    onLocationPermissionGranted: () -&gt; Unit = {}&#10;) {&#10;    var showSecretPreview by remember { mutableStateOf&lt;Secret?&gt;(null) }&#10;    var focusedSecret by remember { mutableStateOf&lt;Secret?&gt;(null) }&#10;    onSheetStateChange: (String) -&gt; Unit = {}&#10;    val locationPermissions = rememberMultiplePermissionsState(&#10;        permissions = listOf(&#10;            Manifest.permission.ACCESS_FINE_LOCATION,&#10;            Manifest.permission.ACCESS_COARSE_LOCATION&#10;                secrets = nearbySecrets,&#10;                onMarkerClick = { showSecretPreview = it },&#10;        if (currentLocation != null) {&#10;                onFocusHandled = { focusedSecret = null }&#10;            )&#10;        } else {&#10;            // Show map placeholder with location permission request&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;            // Show map placeholder while loading location&#10;                androidx.compose.foundation.Image(&#10;                    painter = painterResource(id = com.secretspaces32.android.R.drawable.map_placeholder),&#10;                    contentDescription = &quot;Map Placeholder&quot;,&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentScale = ContentScale.Crop&#10;                )&#10;&#10;                // Dark overlay for better text visibility&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .background(Color.Black.copy(alpha = 0.5f))&#10;                )&#10;&#10;                // Permission request UI&#10;                Column(&#10;                        .background(Color.Black.copy(alpha = 0.4f))&#10;                    verticalArrangement = Arrangement.spacedBy(16.dp),&#10;                    modifier = Modifier.padding(32.dp)&#10;                // Loading indicator&#10;                    // Map icon&#10;                    Icon(&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                        tint = TealPrimary,&#10;                    CircularProgressIndicator(&#10;                        color = TealPrimary,&#10;                        modifier = Modifier.size(42.dp)&#10;                        style = MaterialTheme.typography.headlineSmall,&#10;                    )&#10;                        text = &quot;Loading map...&quot;,&#10;                    Text(&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        fontWeight = FontWeight.SemiBold&#10;                    )&#10;                    Text(&#10;                        text = &quot;Fetching your location&quot;,&#10;                        color = Color.White.copy(alpha = 0.8f),&#10;                        style = MaterialTheme.typography.bodySmall&#10;                    )&#10;        AnimatedVisibility(&#10;            visible = showSecretPreview != null,&#10;            enter = fadeIn() + scaleIn(initialScale = 0.8f),&#10;            exit = fadeOut() + scaleOut(targetScale = 0.8f)&#10;        ) {&#10;            showSecretPreview?.let { secret -&gt;&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .background(Color.Black.copy(alpha = 0.6f))&#10;                        .clickable { showSecretPreview = null },&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Card(&#10;                        modifier = Modifier.fillMaxWidth(0.9f),&#10;                        shape = RoundedCornerShape(24.dp),&#10;                        colors = CardDefaults.cardColors(containerColor = DarkSurface),&#10;                        elevation = CardDefaults.cardElevation(10.dp)&#10;                    ) {&#10;                        Column(modifier = Modifier.padding(24.dp)) {&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.SpaceBetween,&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot; Secret&quot;,&#10;                                    style = MaterialTheme.typography.titleLarge,&#10;                                    color = TealPrimary,&#10;                                    fontWeight = FontWeight.Bold&#10;                                )&#10;                                IconButton(&#10;                                    onClick = { showSecretPreview = null },&#10;                                    modifier = Modifier.size(32.dp)&#10;                                ) {&#10;                                    Icon(&#10;                                        imageVector = Icons.Default.Close,&#10;                                        contentDescription = &quot;Close&quot;,&#10;                                        tint = Color.White.copy(alpha = 0.7f)&#10;                                    )&#10;                                }&#10;                            }&#10;&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;                            Text(&#10;                                text = secret.text,&#10;                                style = MaterialTheme.typography.bodyLarge,&#10;                                color = Color.White,&#10;                                lineHeight = 24.sp&#10;                            )&#10;&#10;                            Spacer(modifier = Modifier.height(20.dp))&#10;&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.SpaceBetween,&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                secret.distance?.let { distance -&gt;&#10;                                    Row(&#10;                                        horizontalArrangement = Arrangement.spacedBy(6.dp),&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        Icon(&#10;                                            imageVector = Icons.Default.LocationOn,&#10;                                            contentDescription = null,&#10;                                            tint = AquaGreen,&#10;                                            modifier = Modifier.size(18.dp)&#10;                                        )&#10;                                        Text(&#10;                                            text = LocationHelper.formatDistance(distance),&#10;                                            style = MaterialTheme.typography.bodyMedium,&#10;                                            color = AquaGreen&#10;                                        )&#10;                                    }&#10;                                }&#10;&#10;                                Button(&#10;                                    onClick = {&#10;                                        showSecretPreview = null&#10;                                        onSecretClick(secret)&#10;                                    },&#10;                                    colors = ButtonDefaults.buttonColors(containerColor = TealPrimary),&#10;                                    shape = RoundedCornerShape(12.dp)&#10;                                ) {&#10;                                    Text(&quot;View Details&quot;)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;fun MapViewComposable(&#10;    currentLocation: Location,&#10;    secrets: List&lt;Secret&gt;,&#10;    onMarkerClick: (Secret) -&gt; Unit,&#10;    focusedSecret: Secret? = null,&#10;    onFocusHandled: () -&gt; Unit = {}&#10;) {&#10;    val lifecycleOwner = LocalLifecycleOwner.current&#10;    val lifecycle = lifecycleOwner.lifecycle&#10;&#10;    var mapView by remember { mutableStateOf&lt;MapView?&gt;(null) }&#10;    var symbolManager by remember { mutableStateOf&lt;SymbolManager?&gt;(null) }&#10;    var isMapReady by remember { mutableStateOf(false) }&#10;    var mapLibreMapInstance by remember { mutableStateOf&lt;org.maplibre.android.maps.MapLibreMap?&gt;(null) }&#10;&#10;    // Handle focusing on a specific secret when requested&#10;    LaunchedEffect(focusedSecret) {&#10;        focusedSecret?.let { secret -&gt;&#10;            mapLibreMapInstance?.let { map -&gt;&#10;                try {&#10;                    val secretPosition = LatLng(secret.latitude, secret.longitude)&#10;                    map.animateCamera(&#10;                        CameraUpdateFactory.newLatLngZoom(secretPosition, 16.0),&#10;                        1500&#10;                    )&#10;                    onFocusHandled()&#10;                } catch (e: Exception) {&#10;                    onFocusHandled()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            try {&#10;                symbolManager?.onDestroy()&#10;                mapView?.onPause()&#10;                mapView?.onStop()&#10;                mapView?.onDestroy()&#10;            } catch (_: Exception) {&#10;            }&#10;            symbolManager = null&#10;            mapView = null&#10;        }&#10;    }&#10;&#10;    Box(modifier = Modifier.fillMaxSize().background(DarkBackground)) {&#10;        AndroidView(&#10;            factory = { ctx -&gt;&#10;                try {&#10;&#10;                    // Initialize MapLibre BEFORE creating MapView&#10;                    try {&#10;                        MapLibre.getInstance(ctx)&#10;                    } catch (_: Exception) {&#10;                        // MapLibre not initialized, initialize it now&#10;                        MapLibre.getInstance(ctx)&#10;                    }&#10;&#10;                    MapView(ctx).apply {&#10;                        this.id = android.view.View.generateViewId()&#10;                        setBackgroundColor(android.graphics.Color.BLACK)&#10;&#10;                        // Store reference immediately&#10;                        mapView = this&#10;&#10;                        // Initialize lifecycle immediately in factory&#10;                        this.onCreate(null)&#10;                        this.onStart()&#10;                        this.onResume()&#10;&#10;                        // Setup map directly in factory using post to ensure view is attached&#10;                        this.post {&#10;                            try {&#10;                                this.getMapAsync { mapLibreMap -&gt;&#10;                                    // Store the map instance for camera control&#10;                                    mapLibreMapInstance = mapLibreMap&#10;                                    try {&#10;                                        val styleUrl = &quot;https://api.maptiler.com/maps/streets-v2/style.json?key=${BuildConfig.MAPTILER_API_KEY}&quot;&#10;&#10;                                        mapLibreMap.setStyle(styleUrl) { style -&gt;&#10;                                            try {&#10;                                                // Clean up old symbol manager&#10;                                                symbolManager?.onDestroy()&#10;&#10;                                                // Create symbol manager&#10;                                                val newSymbolManager = SymbolManager(this, mapLibreMap, style)&#10;                                                newSymbolManager.iconAllowOverlap = true&#10;                                                newSymbolManager.textAllowOverlap = true&#10;                                                symbolManager = newSymbolManager&#10;&#10;                                                // Current location marker&#10;                                                newSymbolManager.create(&#10;                                                    SymbolOptions()&#10;                                                        .withLatLng(LatLng(currentLocation.latitude, currentLocation.longitude))&#10;                                                        .withTextField(&quot;&quot;)&#10;                                                        .withTextSize(18f)&#10;                                                        .withTextColor(&quot;rgb(0, 217, 208)&quot;)&#10;                                                )&#10;&#10;                                                // Secret markers&#10;                                                secrets.forEach { secret -&gt;&#10;                                                    newSymbolManager.create(&#10;                                                        SymbolOptions()&#10;                                                            .withLatLng(LatLng(secret.latitude, secret.longitude))&#10;                                                            .withTextField(&quot;&quot;)&#10;                                                            .withTextSize(18f)&#10;                                                            .withTextColor(&quot;rgb(123, 97, 255)&quot;)&#10;                                                            .withData(JsonPrimitive(secret.id))&#10;                                                    )&#10;                                                }&#10;&#10;                                                newSymbolManager.addClickListener { symbol -&gt;&#10;                                                    symbol.data?.let { data -&gt;&#10;                                                        secrets.find { it.id == data.asString }?.let(onMarkerClick)&#10;                                                    }&#10;                                                    true&#10;                                                }&#10;&#10;                                                isMapReady = true&#10;                                            } catch (e: Exception) {&#10;                                                isMapReady = true&#10;                                            }&#10;                                        }&#10;                                    } catch (e: Exception) {&#10;                                        isMapReady = true&#10;                                    }&#10;                                }&#10;                            } catch (e: Exception) {&#10;                                isMapReady = true&#10;                            }&#10;                        }&#10;                    }&#10;                } catch (e: Exception) {&#10;                    // Return a fallback view if map creation fails&#10;                    android.widget.FrameLayout(ctx).apply {&#10;                        setBackgroundColor(android.graphics.Color.BLACK)&#10;                    }&#10;                }&#10;            },&#10;            modifier = Modifier.fillMaxSize()&#10;&#10;        )&#10;&#10;        // Show loading indicator while map initializes&#10;        if (!isMapReady) {&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    CircularProgressIndicator(color = TealPrimary)&#10;                    Text(&#10;                        text = &quot;Initializing map...&quot;,&#10;                        color = Color.White,&#10;                        style = MaterialTheme.typography.bodyMedium&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Timeout fallback&#10;    LaunchedEffect(Unit) {&#10;        delay(15000)&#10;        if (!isMapReady) {&#10;            isMapReady = true&#10;        }&#10;    }&#10;&#10;    DisposableEffect(lifecycle) {&#10;        val observer = LifecycleEventObserver { _, event -&gt;&#10;            when (event) {&#10;                Lifecycle.Event.ON_PAUSE -&gt; {&#10;                    try {&#10;                        mapView?.onPause()&#10;                    } catch (_: Exception) {&#10;                    }&#10;                }&#10;                Lifecycle.Event.ON_RESUME -&gt; {&#10;                    try {&#10;                        mapView?.onResume()&#10;                    } catch (_: Exception) {&#10;                    }&#10;                }&#10;                Lifecycle.Event.ON_STOP -&gt; {&#10;                    try {&#10;                        mapView?.onStop()&#10;                    } catch (_: Exception) {&#10;                    }&#10;                }&#10;                Lifecycle.Event.ON_START -&gt; {&#10;                    try {&#10;                        mapView?.onStart()&#10;                    } catch (_: Exception) {&#10;                    }&#10;                }&#10;                Lifecycle.Event.ON_DESTROY -&gt; {&#10;                    try {&#10;                        symbolManager?.onDestroy()&#10;                        symbolManager = null&#10;                        mapView?.onDestroy()&#10;                        mapView = null&#10;                    } catch (_: Exception) {&#10;                    }&#10;                }&#10;                else -&gt; {}&#10;            }&#10;        }&#10;&#10;        lifecycle.addObserver(observer)&#10;&#10;        onDispose {&#10;            lifecycle.removeObserver(observer)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.secretspaces32.android.ui.screens&#10;&#10;import android.Manifest&#10;import android.location.Location&#10;import androidx.compose.animation.*&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.lazy.rememberLazyListState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import com.google.accompanist.permissions.ExperimentalPermissionsApi&#10;import com.google.accompanist.permissions.rememberMultiplePermissionsState&#10;import com.google.accompanist.permissions.isGranted&#10;import com.google.gson.JsonPrimitive&#10;import com.secretspaces32.android.BuildConfig&#10;import com.secretspaces32.android.data.model.Secret&#10;import com.secretspaces32.android.ui.components.*&#10;import com.secretspaces32.android.ui.theme.*&#10;import com.secretspaces32.android.utils.LocationHelper&#10;import kotlinx.coroutines.delay&#10;import org.maplibre.android.MapLibre&#10;import org.maplibre.android.camera.CameraUpdateFactory&#10;import org.maplibre.android.geometry.LatLng&#10;import org.maplibre.android.maps.MapView&#10;import org.maplibre.android.plugins.annotation.SymbolManager&#10;import org.maplibre.android.plugins.annotation.SymbolOptions&#10;&#10;// Define 3 states for the bottom sheet&#10;enum class SheetState { COLLAPSED, HALF_EXPANDED, FULLY_EXPANDED }&#10;&#10;@OptIn(ExperimentalPermissionsApi::class)&#10;@Composable&#10;fun MapScreen(&#10;    currentLocation: Location?,&#10;    nearbySecrets: List&lt;Secret&gt;,&#10;    onSecretClick: (Secret) -&gt; Unit,&#10;    onSheetStateChange: (String) -&gt; Unit = {},&#10;    onLocationPermissionGranted: () -&gt; Unit = {}&#10;) {&#10;    var showSecretPreview by remember { mutableStateOf&lt;Secret?&gt;(null) }&#10;    var focusedSecret by remember { mutableStateOf&lt;Secret?&gt;(null) }&#10;&#10;    // Location permissions state&#10;    val locationPermissions = rememberMultiplePermissionsState(&#10;        permissions = listOf(&#10;            Manifest.permission.ACCESS_FINE_LOCATION,&#10;            Manifest.permission.ACCESS_COARSE_LOCATION&#10;        )&#10;    )&#10;&#10;    // Update location when permission is granted&#10;    LaunchedEffect(locationPermissions.allPermissionsGranted) {&#10;        if (locationPermissions.allPermissionsGranted &amp;&amp; currentLocation == null) {&#10;            onLocationPermissionGranted()&#10;        }&#10;    }&#10;&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Map View - Only show if permissions are granted&#10;        if (locationPermissions.allPermissionsGranted) {&#10;            // Show map if we have location OR show loading if location is being fetched&#10;            if (currentLocation != null) {&#10;                MapViewComposable(&#10;                    currentLocation = currentLocation,&#10;                    secrets = nearbySecrets,&#10;                    onMarkerClick = { showSecretPreview = it },&#10;                    focusedSecret = focusedSecret,&#10;                    onFocusHandled = { focusedSecret = null }&#10;                )&#10;            } else {&#10;                // Permissions granted but location still loading&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    androidx.compose.foundation.Image(&#10;                        painter = painterResource(id = com.secretspaces32.android.R.drawable.map_placeholder),&#10;                        contentDescription = &quot;Map Placeholder&quot;,&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentScale = ContentScale.Crop&#10;                    )&#10;&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .background(Color.Black.copy(alpha = 0.5f))&#10;                    )&#10;&#10;                    Column(&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        CircularProgressIndicator(&#10;                            color = TealPrimary,&#10;                            modifier = Modifier.size(42.dp)&#10;                        )&#10;                        Text(&#10;                            text = &quot;Getting your location...&quot;,&#10;                            color = Color.White,&#10;                            style = MaterialTheme.typography.bodyLarge,&#10;                            fontWeight = FontWeight.SemiBold&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        } else {&#10;            // Show map placeholder with location permission request&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                // Map placeholder image&#10;                androidx.compose.foundation.Image(&#10;                    painter = painterResource(id = com.secretspaces32.android.R.drawable.map_placeholder),&#10;                    contentDescription = &quot;Map Placeholder&quot;,&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentScale = ContentScale.Crop&#10;                )&#10;&#10;                // Dark overlay for better text visibility&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .background(Color.Black.copy(alpha = 0.5f))&#10;                )&#10;&#10;                // Permission request UI&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                    verticalArrangement = Arrangement.spacedBy(16.dp),&#10;                    modifier = Modifier.padding(32.dp)&#10;                ) {&#10;                    // Map icon&#10;                    Icon(&#10;                        imageVector = Icons.Default.LocationOn,&#10;                        contentDescription = &quot;Location&quot;,&#10;                        tint = TealPrimary,&#10;                        modifier = Modifier.size(80.dp)&#10;                    )&#10;&#10;                    Text(&#10;                        text = &quot;Enable Location&quot;,&#10;                        color = Color.White,&#10;                        style = MaterialTheme.typography.headlineSmall,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;&#10;                    Text(&#10;                        text = &quot;To view nearby secrets on the map, we need access to your location.&quot;,&#10;                        color = Color.White.copy(alpha = 0.9f),&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        textAlign = TextAlign.Center,&#10;                        lineHeight = 20.sp&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    // Permission request button&#10;                    Button(&#10;                        onClick = {&#10;                            locationPermissions.launchMultiplePermissionRequest()&#10;                        },&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = TealPrimary&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        modifier = Modifier&#10;                            .fillMaxWidth(0.8f)&#10;                            .height(56.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.MyLocation,&#10;                            contentDescription = null,&#10;                            modifier = Modifier.size(24.dp)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Text(&#10;                            text = &quot;Allow Location Access&quot;,&#10;                            fontSize = 16.sp,&#10;                            fontWeight = FontWeight.SemiBold&#10;                        )&#10;                    }&#10;&#10;                    // Show different message if permission was denied&#10;                    if (locationPermissions.permissions.any { !it.status.isGranted } &amp;&amp; !locationPermissions.allPermissionsGranted) {&#10;                        Text(&#10;                            text = &quot;Location permission is required to show the map. Please grant permission in the dialog above.&quot;,&#10;                            color = Color.White.copy(alpha = 0.7f),&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            textAlign = TextAlign.Center,&#10;                            lineHeight = 18.sp&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Secret Preview Modal&#10;        AnimatedVisibility(&#10;            visible = showSecretPreview != null,&#10;            enter = fadeIn() + scaleIn(initialScale = 0.8f),&#10;            exit = fadeOut() + scaleOut(targetScale = 0.8f)&#10;        ) {&#10;            showSecretPreview?.let { secret -&gt;&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .background(Color.Black.copy(alpha = 0.6f))&#10;                        .clickable { showSecretPreview = null },&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Card(&#10;                        modifier = Modifier.fillMaxWidth(0.9f),&#10;                        shape = RoundedCornerShape(24.dp),&#10;                        colors = CardDefaults.cardColors(containerColor = DarkSurface),&#10;                        elevation = CardDefaults.cardElevation(10.dp)&#10;                    ) {&#10;                        Column(modifier = Modifier.padding(24.dp)) {&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.SpaceBetween,&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot; Secret&quot;,&#10;                                    style = MaterialTheme.typography.titleLarge,&#10;                                    color = TealPrimary,&#10;                                    fontWeight = FontWeight.Bold&#10;                                )&#10;                                IconButton(&#10;                                    onClick = { showSecretPreview = null },&#10;                                    modifier = Modifier.size(32.dp)&#10;                                ) {&#10;                                    Icon(&#10;                                        imageVector = Icons.Default.Close,&#10;                                        contentDescription = &quot;Close&quot;,&#10;                                        tint = Color.White.copy(alpha = 0.7f)&#10;                                    )&#10;                                }&#10;                            }&#10;&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;                            Text(&#10;                                text = secret.text,&#10;                                style = MaterialTheme.typography.bodyLarge,&#10;                                color = Color.White,&#10;                                lineHeight = 24.sp&#10;                            )&#10;&#10;                            Spacer(modifier = Modifier.height(20.dp))&#10;&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.SpaceBetween,&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                secret.distance?.let { distance -&gt;&#10;                                    Row(&#10;                                        horizontalArrangement = Arrangement.spacedBy(6.dp),&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        Icon(&#10;                                            imageVector = Icons.Default.LocationOn,&#10;                                            contentDescription = null,&#10;                                            tint = AquaGreen,&#10;                                            modifier = Modifier.size(18.dp)&#10;                                        )&#10;                                        Text(&#10;                                            text = LocationHelper.formatDistance(distance),&#10;                                            style = MaterialTheme.typography.bodyMedium,&#10;                                            color = AquaGreen&#10;                                        )&#10;                                    }&#10;                                }&#10;&#10;                                Button(&#10;                                    onClick = {&#10;                                        showSecretPreview = null&#10;                                        onSecretClick(secret)&#10;                                    },&#10;                                    colors = ButtonDefaults.buttonColors(containerColor = TealPrimary),&#10;                                    shape = RoundedCornerShape(12.dp)&#10;                                ) {&#10;                                    Text(&quot;View Details&quot;)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;fun MapViewComposable(&#10;    currentLocation: Location,&#10;    secrets: List&lt;Secret&gt;,&#10;    onMarkerClick: (Secret) -&gt; Unit,&#10;    focusedSecret: Secret? = null,&#10;    onFocusHandled: () -&gt; Unit = {}&#10;) {&#10;    val lifecycleOwner = LocalLifecycleOwner.current&#10;    val lifecycle = lifecycleOwner.lifecycle&#10;&#10;    var mapView by remember { mutableStateOf&lt;MapView?&gt;(null) }&#10;    var symbolManager by remember { mutableStateOf&lt;SymbolManager?&gt;(null) }&#10;    var isMapReady by remember { mutableStateOf(false) }&#10;    var mapLibreMapInstance by remember { mutableStateOf&lt;org.maplibre.android.maps.MapLibreMap?&gt;(null) }&#10;&#10;    // Handle focusing on a specific secret when requested&#10;    LaunchedEffect(focusedSecret) {&#10;        focusedSecret?.let { secret -&gt;&#10;            mapLibreMapInstance?.let { map -&gt;&#10;                try {&#10;                    val secretPosition = LatLng(secret.latitude, secret.longitude)&#10;                    map.animateCamera(&#10;                        CameraUpdateFactory.newLatLngZoom(secretPosition, 16.0),&#10;                        1500&#10;                    )&#10;                    onFocusHandled()&#10;                } catch (e: Exception) {&#10;                    onFocusHandled()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            try {&#10;                symbolManager?.onDestroy()&#10;                mapView?.onPause()&#10;                mapView?.onStop()&#10;                mapView?.onDestroy()&#10;            } catch (_: Exception) {&#10;            }&#10;            symbolManager = null&#10;            mapView = null&#10;        }&#10;    }&#10;&#10;    Box(modifier = Modifier.fillMaxSize().background(DarkBackground)) {&#10;        AndroidView(&#10;            factory = { ctx -&gt;&#10;                try {&#10;&#10;                    // Initialize MapLibre BEFORE creating MapView&#10;                    try {&#10;                        MapLibre.getInstance(ctx)&#10;                    } catch (_: Exception) {&#10;                        // MapLibre not initialized, initialize it now&#10;                        MapLibre.getInstance(ctx)&#10;                    }&#10;&#10;                    MapView(ctx).apply {&#10;                        this.id = android.view.View.generateViewId()&#10;                        setBackgroundColor(android.graphics.Color.BLACK)&#10;&#10;                        // Store reference immediately&#10;                        mapView = this&#10;&#10;                        // Initialize lifecycle immediately in factory&#10;                        this.onCreate(null)&#10;                        this.onStart()&#10;                        this.onResume()&#10;&#10;                        // Setup map directly in factory using post to ensure view is attached&#10;                        this.post {&#10;                            try {&#10;                                this.getMapAsync { mapLibreMap -&gt;&#10;                                    // Store the map instance for camera control&#10;                                    mapLibreMapInstance = mapLibreMap&#10;                                    try {&#10;                                        val styleUrl = &quot;https://api.maptiler.com/maps/streets-v2/style.json?key=${BuildConfig.MAPTILER_API_KEY}&quot;&#10;&#10;                                        mapLibreMap.setStyle(styleUrl) { style -&gt;&#10;                                            try {&#10;                                                // Set initial camera position to user's location&#10;                                                mapLibreMap.moveCamera(&#10;                                                    CameraUpdateFactory.newLatLngZoom(&#10;                                                        LatLng(currentLocation.latitude, currentLocation.longitude),&#10;                                                        14.0&#10;                                                    )&#10;                                                )&#10;&#10;                                                // Clean up old symbol manager&#10;                                                symbolManager?.onDestroy()&#10;&#10;                                                // Create symbol manager&#10;                                                val newSymbolManager = SymbolManager(this, mapLibreMap, style)&#10;                                                newSymbolManager.iconAllowOverlap = true&#10;                                                newSymbolManager.textAllowOverlap = true&#10;                                                symbolManager = newSymbolManager&#10;&#10;                                                // Current location marker&#10;                                                newSymbolManager.create(&#10;                                                    SymbolOptions()&#10;                                                        .withLatLng(LatLng(currentLocation.latitude, currentLocation.longitude))&#10;                                                        .withTextField(&quot;&quot;)&#10;                                                        .withTextSize(18f)&#10;                                                        .withTextColor(&quot;rgb(0, 217, 208)&quot;)&#10;                                                )&#10;&#10;                                                // Secret markers&#10;                                                secrets.forEach { secret -&gt;&#10;                                                    newSymbolManager.create(&#10;                                                        SymbolOptions()&#10;                                                            .withLatLng(LatLng(secret.latitude, secret.longitude))&#10;                                                            .withTextField(&quot;&quot;)&#10;                                                            .withTextSize(18f)&#10;                                                            .withTextColor(&quot;rgb(123, 97, 255)&quot;)&#10;                                                            .withData(JsonPrimitive(secret.id))&#10;                                                    )&#10;                                                }&#10;&#10;                                                newSymbolManager.addClickListener { symbol -&gt;&#10;                                                    symbol.data?.let { data -&gt;&#10;                                                        secrets.find { it.id == data.asString }?.let(onMarkerClick)&#10;                                                    }&#10;                                                    true&#10;                                                }&#10;&#10;                                                isMapReady = true&#10;                                            } catch (e: Exception) {&#10;                                                isMapReady = true&#10;                                            }&#10;                                        }&#10;                                    } catch (e: Exception) {&#10;                                        isMapReady = true&#10;                                    }&#10;                                }&#10;                            } catch (e: Exception) {&#10;                                isMapReady = true&#10;                            }&#10;                        }&#10;                    }&#10;                } catch (e: Exception) {&#10;                    // Return a fallback view if map creation fails&#10;                    android.widget.FrameLayout(ctx).apply {&#10;                        setBackgroundColor(android.graphics.Color.BLACK)&#10;                    }&#10;                }&#10;            },&#10;            modifier = Modifier.fillMaxSize()&#10;&#10;        )&#10;&#10;        // Show loading indicator while map initializes&#10;        if (!isMapReady) {&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    CircularProgressIndicator(color = TealPrimary)&#10;                    Text(&#10;                        text = &quot;Initializing map...&quot;,&#10;                        color = Color.White,&#10;                        style = MaterialTheme.typography.bodyMedium&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Timeout fallback&#10;    LaunchedEffect(Unit) {&#10;        delay(15000)&#10;        if (!isMapReady) {&#10;            isMapReady = true&#10;        }&#10;    }&#10;&#10;    DisposableEffect(lifecycle) {&#10;        val observer = LifecycleEventObserver { _, event -&gt;&#10;            when (event) {&#10;                Lifecycle.Event.ON_PAUSE -&gt; {&#10;                    try {&#10;                        mapView?.onPause()&#10;                    } catch (_: Exception) {&#10;                    }&#10;                }&#10;                Lifecycle.Event.ON_RESUME -&gt; {&#10;                    try {&#10;                        mapView?.onResume()&#10;                    } catch (_: Exception) {&#10;                    }&#10;                }&#10;                Lifecycle.Event.ON_STOP -&gt; {&#10;                    try {&#10;                        mapView?.onStop()&#10;                    } catch (_: Exception) {&#10;                    }&#10;                }&#10;                Lifecycle.Event.ON_START -&gt; {&#10;                    try {&#10;                        mapView?.onStart()&#10;                    } catch (_: Exception) {&#10;                    }&#10;                }&#10;                Lifecycle.Event.ON_DESTROY -&gt; {&#10;                    try {&#10;                        symbolManager?.onDestroy()&#10;                        symbolManager = null&#10;                        mapView?.onDestroy()&#10;                        mapView = null&#10;                    } catch (_: Exception) {&#10;                    }&#10;                }&#10;                else -&gt; {}&#10;            }&#10;        }&#10;&#10;        lifecycle.addObserver(observer)&#10;&#10;        onDispose {&#10;            lifecycle.removeObserver(observer)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/secretspaces32/android/viewmodel/MainViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/secretspaces32/android/viewmodel/MainViewModel.kt" />
              <option name="originalContent" value="package com.secretspaces32.android.viewmodel&#10;&#10;import android.content.Context&#10;import android.location.Location&#10;import android.net.Uri&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.secretspaces32.android.data.model.Comment&#10;import com.secretspaces32.android.data.model.Like&#10;import com.secretspaces32.android.data.model.Secret&#10;import com.secretspaces32.android.data.model.User&#10;import com.secretspaces32.android.data.model.UpdateUserRequest&#10;import com.secretspaces32.android.data.repository.AuthRepository&#10;import com.secretspaces32.android.data.repository.FirebaseSecretRepository&#10;import com.secretspaces32.android.data.repository.FirebaseUserRepository&#10;import com.secretspaces32.android.utils.LocationHelper&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;data class AppUiState(&#10;    val isAuthenticated: Boolean = false,&#10;    val currentUser: User? = null,&#10;    val currentLocation: Location? = null,&#10;    val secrets: List&lt;Secret&gt; = emptyList(),&#10;    val mySecrets: List&lt;Secret&gt; = emptyList(),&#10;    val selectedSecret: Secret? = null,&#10;    val selectedSecretComments: List&lt;Comment&gt; = emptyList(),&#10;    val selectedSecretLikes: List&lt;Like&gt; = emptyList(),&#10;    val isLoading: Boolean = false,&#10;    val isEmailAuthLoading: Boolean = false,&#10;    val isGoogleAuthLoading: Boolean = false,&#10;    val errorMessage: String? = null&#10;)&#10;&#10;class MainViewModel(&#10;    private val context: Context&#10;) : ViewModel() {&#10;&#10;    private val authRepository = AuthRepository()&#10;    private val userRepository = FirebaseUserRepository()&#10;    private val secretRepository = FirebaseSecretRepository()&#10;    private val locationHelper = LocationHelper(context)&#10;&#10;    private val _uiState = MutableStateFlow(AppUiState())&#10;    val uiState: StateFlow&lt;AppUiState&gt; = _uiState.asStateFlow()&#10;&#10;    init {&#10;        checkAuthState()&#10;    }&#10;&#10;    private fun checkAuthState() {&#10;        viewModelScope.launch {&#10;            authRepository.currentUser.collect { firebaseUser -&gt;&#10;                if (firebaseUser != null) {&#10;                    loadCurrentUser(firebaseUser.uid)&#10;                } else {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isAuthenticated = false,&#10;                        currentUser = null&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun loadCurrentUser(userId: String) {&#10;        val result = userRepository.getUser(userId)&#10;        result.onSuccess { user -&gt;&#10;            _uiState.value = _uiState.value.copy(&#10;                isAuthenticated = true,&#10;                currentUser = user&#10;            )&#10;        }.onFailure {&#10;            _uiState.value = _uiState.value.copy(&#10;                isAuthenticated = true,&#10;                currentUser = null,&#10;                errorMessage = &quot;Failed to load user profile&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    fun signUp(email: String, password: String, username: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isEmailAuthLoading = true)&#10;&#10;            val authResult = authRepository.signUp(email, password, username)&#10;            authResult.onSuccess { firebaseUser -&gt;&#10;                val userResult = userRepository.createUser(&#10;                    userId = firebaseUser.uid,&#10;                    email = email,&#10;                    username = username&#10;                )&#10;&#10;                userResult.onSuccess { user -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isAuthenticated = true,&#10;                        currentUser = user,&#10;                        isEmailAuthLoading = false&#10;                    )&#10;                }.onFailure { e -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isEmailAuthLoading = false,&#10;                        errorMessage = &quot;Failed to create user profile: ${e.message}&quot;&#10;                    )&#10;                }&#10;            }.onFailure { e -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isEmailAuthLoading = false,&#10;                    errorMessage = &quot;Sign up failed: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun signIn(email: String, password: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isEmailAuthLoading = true)&#10;&#10;            val result = authRepository.signIn(email, password)&#10;            result.onSuccess {&#10;                _uiState.value = _uiState.value.copy(isEmailAuthLoading = false)&#10;            }.onFailure { e -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isEmailAuthLoading = false,&#10;                    errorMessage = &quot;Sign in failed: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun signInWithGoogle(idToken: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isGoogleAuthLoading = true)&#10;&#10;            val authResult = authRepository.signInWithGoogle(idToken)&#10;            authResult.onSuccess { firebaseUser -&gt;&#10;                // Check if user exists in Firestore&#10;                val userResult = userRepository.getUser(firebaseUser.uid)&#10;&#10;                userResult.onSuccess { user -&gt;&#10;                    // User already exists&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isAuthenticated = true,&#10;                        currentUser = user,&#10;                        isGoogleAuthLoading = false&#10;                    )&#10;                }.onFailure {&#10;                    // Create new user profile&#10;                    val createResult = userRepository.createUser(&#10;                        userId = firebaseUser.uid,&#10;                        email = firebaseUser.email ?: &quot;&quot;,&#10;                        username = firebaseUser.displayName ?: &quot;User&quot;&#10;                    )&#10;&#10;                    createResult.onSuccess { user -&gt;&#10;                        _uiState.value = _uiState.value.copy(&#10;                            isAuthenticated = true,&#10;                            currentUser = user,&#10;                            isGoogleAuthLoading = false&#10;                        )&#10;                    }.onFailure { e -&gt;&#10;                        _uiState.value = _uiState.value.copy(&#10;                            isGoogleAuthLoading = false,&#10;                            errorMessage = &quot;Failed to create user profile: ${e.message}&quot;&#10;                        )&#10;                    }&#10;                }&#10;            }.onFailure { e -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isGoogleAuthLoading = false,&#10;                    errorMessage = &quot;Google sign in failed: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun signOut() {&#10;        authRepository.signOut()&#10;        _uiState.value = AppUiState()&#10;    }&#10;&#10;    fun updateProfile(username: String, bio: String, imageUri: Uri?) {&#10;        viewModelScope.launch {&#10;            val userId = _uiState.value.currentUser?.id ?: return@launch&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;            try {&#10;                var profilePictureUrl: String? = null&#10;&#10;                if (imageUri != null) {&#10;                    val uploadResult = userRepository.uploadProfilePicture(userId, imageUri)&#10;                    uploadResult.onSuccess { url -&gt;&#10;                        profilePictureUrl = url&#10;                    }&#10;                }&#10;&#10;                val updateRequest = UpdateUserRequest(&#10;                    username = username,&#10;                    bio = bio,&#10;                    profilePictureUrl = profilePictureUrl&#10;                )&#10;&#10;                val result = userRepository.updateUser(userId, updateRequest)&#10;                result.onSuccess {&#10;                    loadCurrentUser(userId)&#10;                    _uiState.value = _uiState.value.copy(isLoading = false)&#10;                }.onFailure { e -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Failed to update profile: ${e.message}&quot;&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Error: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateLocation() {&#10;        viewModelScope.launch {&#10;            try {&#10;                println(&quot;DEBUG: Starting location update...&quot;)&#10;&#10;                if (!locationHelper.hasLocationPermission()) {&#10;                    println(&quot;DEBUG: Location permission not granted - using default location&quot;)&#10;                    // Use a default location (e.g., San Francisco)&#10;                    val defaultLocation = Location(&quot;default&quot;).apply {&#10;                        latitude = 37.7749&#10;                        longitude = -122.4194&#10;                    }&#10;                    _uiState.value = _uiState.value.copy(currentLocation = defaultLocation)&#10;                    fetchNearbySecrets(defaultLocation.latitude, defaultLocation.longitude)&#10;                    return@launch&#10;                }&#10;&#10;                if (!locationHelper.isLocationEnabled()) {&#10;                    println(&quot;DEBUG: Location services not enabled - using default location&quot;)&#10;                    // Use a default location&#10;                    val defaultLocation = Location(&quot;default&quot;).apply {&#10;                        latitude = 37.7749&#10;                        longitude = -122.4194&#10;                    }&#10;                    _uiState.value = _uiState.value.copy(currentLocation = defaultLocation)&#10;                    fetchNearbySecrets(defaultLocation.latitude, defaultLocation.longitude)&#10;                    return@launch&#10;                }&#10;&#10;                println(&quot;DEBUG: Fetching location...&quot;)&#10;                val location = locationHelper.getCurrentLocation()&#10;&#10;                if (location == null) {&#10;                    println(&quot;DEBUG: Location is null - using default location&quot;)&#10;                    // Use a default location&#10;                    val defaultLocation = Location(&quot;default&quot;).apply {&#10;                        latitude = 37.7749&#10;                        longitude = -122.4194&#10;                    }&#10;                    _uiState.value = _uiState.value.copy(currentLocation = defaultLocation)&#10;                    fetchNearbySecrets(defaultLocation.latitude, defaultLocation.longitude)&#10;                    return@launch&#10;                }&#10;&#10;                println(&quot;DEBUG: ✅ Location obtained - Lat: ${location.latitude}, Lng: ${location.longitude}&quot;)&#10;                _uiState.value = _uiState.value.copy(currentLocation = location)&#10;&#10;                // Fetch nearby secrets with the obtained location&#10;                fetchNearbySecrets(location.latitude, location.longitude)&#10;&#10;            } catch (e: Exception) {&#10;                println(&quot;DEBUG: ❌ Location error - ${e.message}, using default location&quot;)&#10;                e.printStackTrace()&#10;                // Use default location on error&#10;                val defaultLocation = Location(&quot;default&quot;).apply {&#10;                    latitude = 37.7749&#10;                    longitude = -122.4194&#10;                }&#10;                _uiState.value = _uiState.value.copy(currentLocation = defaultLocation)&#10;                fetchNearbySecrets(defaultLocation.latitude, defaultLocation.longitude)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun fetchNearbySecrets(latitude: Double, longitude: Double) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;            val result = secretRepository.getNearbySecrets(latitude, longitude)&#10;&#10;            result.onSuccess { secrets -&gt;&#10;                val secretsWithDistance = secrets.map { secret -&gt;&#10;                    val distance = LocationHelper.calculateDistance(&#10;                        latitude, longitude,&#10;                        secret.latitude, secret.longitude&#10;                    )&#10;                    secret.copy(distance = distance)&#10;                }&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    secrets = secretsWithDistance,&#10;                    isLoading = false&#10;                )&#10;            }.onFailure { e -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Failed to fetch secrets: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun createSecret(text: String, imageUri: Uri?, isAnonymous: Boolean, mood: String? = null, category: String? = null, hashtags: String? = null) {&#10;        viewModelScope.launch {&#10;            val location = _uiState.value.currentLocation&#10;            val user = _uiState.value.currentUser&#10;&#10;            if (location == null) {&#10;                _uiState.value = _uiState.value.copy(errorMessage = &quot;Location not available&quot;)&#10;                return@launch&#10;            }&#10;&#10;            if (user == null) {&#10;                _uiState.value = _uiState.value.copy(errorMessage = &quot;User not authenticated&quot;)&#10;                return@launch&#10;            }&#10;&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;            val result = secretRepository.createSecret(&#10;                text = text,&#10;                imageUri = imageUri,&#10;                latitude = location.latitude,&#10;                longitude = location.longitude,&#10;                username = user.username,&#10;                userProfilePicture = user.profilePictureUrl,&#10;                isAnonymous = isAnonymous,&#10;                mood = mood,&#10;                category = category,&#10;                hashtags = hashtags&#10;            )&#10;&#10;            result.onSuccess {&#10;                _uiState.value = _uiState.value.copy(isLoading = false)&#10;                fetchNearbySecrets(location.latitude, location.longitude)&#10;            }.onFailure { e -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Failed to post secret: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun toggleLike(secret: Secret) {&#10;        viewModelScope.launch {&#10;            val user = _uiState.value.currentUser ?: return@launch&#10;&#10;            val result = secretRepository.toggleLike(secret.id, user.username)&#10;            result.onSuccess { isLiked -&gt;&#10;                // Update the secret in the list&#10;                val updatedSecrets = _uiState.value.secrets.map { s -&gt;&#10;                    if (s.id == secret.id) {&#10;                        s.copy(&#10;                            isLikedByCurrentUser = isLiked,&#10;                            likeCount = if (isLiked) s.likeCount + 1 else maxOf(0, s.likeCount - 1)&#10;                        )&#10;                    } else s&#10;                }&#10;                _uiState.value = _uiState.value.copy(secrets = updatedSecrets)&#10;&#10;                // Update selected secret if it's the same&#10;                if (_uiState.value.selectedSecret?.id == secret.id) {&#10;                    loadSecretDetails(secret.id)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun selectSecret(secret: Secret?) {&#10;        _uiState.value = _uiState.value.copy(selectedSecret = secret)&#10;        secret?.let { loadSecretDetails(it.id) }&#10;    }&#10;&#10;    fun loadSecretDetails(secretId: String) {&#10;        viewModelScope.launch {&#10;            val commentsResult = secretRepository.getComments(secretId)&#10;            val likesResult = secretRepository.getLikes(secretId)&#10;&#10;            commentsResult.onSuccess { comments -&gt;&#10;                _uiState.value = _uiState.value.copy(selectedSecretComments = comments)&#10;            }&#10;&#10;            likesResult.onSuccess { likes -&gt;&#10;                _uiState.value = _uiState.value.copy(selectedSecretLikes = likes)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun addComment(secretId: String, text: String) {&#10;        viewModelScope.launch {&#10;            val user = _uiState.value.currentUser ?: return@launch&#10;&#10;            println(&quot;DEBUG: Adding comment for secret $secretId&quot;)&#10;&#10;            val result = secretRepository.addComment(&#10;                secretId = secretId,&#10;                text = text,&#10;                username = user.username,&#10;                userProfilePicture = user.profilePictureUrl&#10;            )&#10;&#10;            result.onSuccess { newComment -&gt;&#10;                println(&quot;DEBUG: Comment added successfully: ${newComment.text}&quot;)&#10;&#10;                // Add small delay to ensure Firebase propagates the comment&#10;                kotlinx.coroutines.delay(800)&#10;&#10;                println(&quot;DEBUG: Reloading secret details...&quot;)&#10;                // Reload comments and likes&#10;                val commentsResult = secretRepository.getComments(secretId)&#10;                val likesResult = secretRepository.getLikes(secretId)&#10;&#10;                commentsResult.onSuccess { comments -&gt;&#10;                    println(&quot;DEBUG: Loaded ${comments.size} comments&quot;)&#10;                    _uiState.value = _uiState.value.copy(selectedSecretComments = comments)&#10;                }&#10;&#10;                likesResult.onSuccess { likes -&gt;&#10;                    _uiState.value = _uiState.value.copy(selectedSecretLikes = likes)&#10;                }&#10;&#10;                // Update comment count in the secrets list&#10;                val updatedSecrets = _uiState.value.secrets.map { s -&gt;&#10;                    if (s.id == secretId) {&#10;                        s.copy(commentCount = s.commentCount + 1)&#10;                    } else s&#10;                }&#10;&#10;                // Update the selected secret with new comment count&#10;                val updatedSelectedSecret = _uiState.value.selectedSecret?.let { secret -&gt;&#10;                    if (secret.id == secretId) {&#10;                        secret.copy(commentCount = secret.commentCount + 1)&#10;                    } else secret&#10;                }&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    secrets = updatedSecrets,&#10;                    selectedSecret = updatedSelectedSecret&#10;                )&#10;&#10;                println(&quot;DEBUG: UI state updated with ${_uiState.value.selectedSecretComments.size} comments&quot;)&#10;            }.onFailure { e -&gt;&#10;                println(&quot;DEBUG: Failed to add comment: ${e.message}&quot;)&#10;                _uiState.value = _uiState.value.copy(&#10;                    errorMessage = &quot;Failed to add comment: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun loadMySecrets() {&#10;        viewModelScope.launch {&#10;            val userId = _uiState.value.currentUser?.id ?: return@launch&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;            val result = secretRepository.getUserSecrets(userId)&#10;            result.onSuccess { secrets -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    mySecrets = secrets,&#10;                    isLoading = false&#10;                )&#10;            }.onFailure { e -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Failed to load your secrets: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearError() {&#10;        _uiState.value = _uiState.value.copy(errorMessage = null)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.secretspaces32.android.viewmodel&#10;&#10;import android.content.Context&#10;import android.location.Location&#10;import android.net.Uri&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.secretspaces32.android.data.model.Comment&#10;import com.secretspaces32.android.data.model.Like&#10;import com.secretspaces32.android.data.model.Secret&#10;import com.secretspaces32.android.data.model.User&#10;import com.secretspaces32.android.data.model.UpdateUserRequest&#10;import com.secretspaces32.android.data.repository.AuthRepository&#10;import com.secretspaces32.android.data.repository.FirebaseSecretRepository&#10;import com.secretspaces32.android.data.repository.FirebaseUserRepository&#10;import com.secretspaces32.android.utils.LocationHelper&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;data class AppUiState(&#10;    val isAuthenticated: Boolean = false,&#10;    val currentUser: User? = null,&#10;    val currentLocation: Location? = null,&#10;    val secrets: List&lt;Secret&gt; = emptyList(),&#10;    val mySecrets: List&lt;Secret&gt; = emptyList(),&#10;    val selectedSecret: Secret? = null,&#10;    val selectedSecretComments: List&lt;Comment&gt; = emptyList(),&#10;    val selectedSecretLikes: List&lt;Like&gt; = emptyList(),&#10;    val isLoading: Boolean = false,&#10;    val isEmailAuthLoading: Boolean = false,&#10;    val isGoogleAuthLoading: Boolean = false,&#10;    val errorMessage: String? = null&#10;)&#10;&#10;class MainViewModel(&#10;    private val context: Context&#10;) : ViewModel() {&#10;&#10;    private val authRepository = AuthRepository()&#10;    private val userRepository = FirebaseUserRepository()&#10;    private val secretRepository = FirebaseSecretRepository()&#10;    private val locationHelper = LocationHelper(context)&#10;&#10;    private val _uiState = MutableStateFlow(AppUiState())&#10;    val uiState: StateFlow&lt;AppUiState&gt; = _uiState.asStateFlow()&#10;&#10;    init {&#10;        checkAuthState()&#10;    }&#10;&#10;    private fun checkAuthState() {&#10;        viewModelScope.launch {&#10;            authRepository.currentUser.collect { firebaseUser -&gt;&#10;                if (firebaseUser != null) {&#10;                    loadCurrentUser(firebaseUser.uid)&#10;                } else {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isAuthenticated = false,&#10;                        currentUser = null&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun loadCurrentUser(userId: String) {&#10;        val result = userRepository.getUser(userId)&#10;        result.onSuccess { user -&gt;&#10;            _uiState.value = _uiState.value.copy(&#10;                isAuthenticated = true,&#10;                currentUser = user&#10;            )&#10;        }.onFailure {&#10;            _uiState.value = _uiState.value.copy(&#10;                isAuthenticated = true,&#10;                currentUser = null,&#10;                errorMessage = &quot;Failed to load user profile&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    fun signUp(email: String, password: String, username: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isEmailAuthLoading = true)&#10;&#10;            val authResult = authRepository.signUp(email, password, username)&#10;            authResult.onSuccess { firebaseUser -&gt;&#10;                val userResult = userRepository.createUser(&#10;                    userId = firebaseUser.uid,&#10;                    email = email,&#10;                    username = username&#10;                )&#10;&#10;                userResult.onSuccess { user -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isAuthenticated = true,&#10;                        currentUser = user,&#10;                        isEmailAuthLoading = false&#10;                    )&#10;                }.onFailure { e -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isEmailAuthLoading = false,&#10;                        errorMessage = &quot;Failed to create user profile: ${e.message}&quot;&#10;                    )&#10;                }&#10;            }.onFailure { e -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isEmailAuthLoading = false,&#10;                    errorMessage = &quot;Sign up failed: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun signIn(email: String, password: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isEmailAuthLoading = true)&#10;&#10;            val result = authRepository.signIn(email, password)&#10;            result.onSuccess {&#10;                _uiState.value = _uiState.value.copy(isEmailAuthLoading = false)&#10;            }.onFailure { e -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isEmailAuthLoading = false,&#10;                    errorMessage = &quot;Sign in failed: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun signInWithGoogle(idToken: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isGoogleAuthLoading = true)&#10;&#10;            val authResult = authRepository.signInWithGoogle(idToken)&#10;            authResult.onSuccess { firebaseUser -&gt;&#10;                // Check if user exists in Firestore&#10;                val userResult = userRepository.getUser(firebaseUser.uid)&#10;&#10;                userResult.onSuccess { user -&gt;&#10;                    // User already exists&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isAuthenticated = true,&#10;                        currentUser = user,&#10;                        isGoogleAuthLoading = false&#10;                    )&#10;                }.onFailure {&#10;                    // Create new user profile&#10;                    val createResult = userRepository.createUser(&#10;                        userId = firebaseUser.uid,&#10;                        email = firebaseUser.email ?: &quot;&quot;,&#10;                        username = firebaseUser.displayName ?: &quot;User&quot;&#10;                    )&#10;&#10;                    createResult.onSuccess { user -&gt;&#10;                        _uiState.value = _uiState.value.copy(&#10;                            isAuthenticated = true,&#10;                            currentUser = user,&#10;                            isGoogleAuthLoading = false&#10;                        )&#10;                    }.onFailure { e -&gt;&#10;                        _uiState.value = _uiState.value.copy(&#10;                            isGoogleAuthLoading = false,&#10;                            errorMessage = &quot;Failed to create user profile: ${e.message}&quot;&#10;                        )&#10;                    }&#10;                }&#10;            }.onFailure { e -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isGoogleAuthLoading = false,&#10;                    errorMessage = &quot;Google sign in failed: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun signOut() {&#10;        authRepository.signOut()&#10;        _uiState.value = AppUiState()&#10;    }&#10;&#10;    fun updateProfile(username: String, bio: String, imageUri: Uri?) {&#10;        viewModelScope.launch {&#10;            val userId = _uiState.value.currentUser?.id ?: return@launch&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;            try {&#10;                var profilePictureUrl: String? = null&#10;&#10;                if (imageUri != null) {&#10;                    val uploadResult = userRepository.uploadProfilePicture(userId, imageUri)&#10;                    uploadResult.onSuccess { url -&gt;&#10;                        profilePictureUrl = url&#10;                    }&#10;                }&#10;&#10;                val updateRequest = UpdateUserRequest(&#10;                    username = username,&#10;                    bio = bio,&#10;                    profilePictureUrl = profilePictureUrl&#10;                )&#10;&#10;                val result = userRepository.updateUser(userId, updateRequest)&#10;                result.onSuccess {&#10;                    loadCurrentUser(userId)&#10;                    _uiState.value = _uiState.value.copy(isLoading = false)&#10;                }.onFailure { e -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isLoading = false,&#10;                        errorMessage = &quot;Failed to update profile: ${e.message}&quot;&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Error: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateLocation() {&#10;        viewModelScope.launch {&#10;            try {&#10;                println(&quot;DEBUG: Starting location update...&quot;)&#10;&#10;                if (!locationHelper.hasLocationPermission()) {&#10;                    println(&quot;DEBUG: Location permission not granted - skipping location update&quot;)&#10;                    // Don't set any location - let the UI handle permission request&#10;                    return@launch&#10;                }&#10;&#10;                if (!locationHelper.isLocationEnabled()) {&#10;                    println(&quot;DEBUG: Location services not enabled - skipping location update&quot;)&#10;                    // Don't set any location - let the UI handle this&#10;                    return@launch&#10;                }&#10;&#10;                println(&quot;DEBUG: Fetching location...&quot;)&#10;                val location = locationHelper.getCurrentLocation()&#10;&#10;                if (location == null) {&#10;                    println(&quot;DEBUG: Location is null - could not fetch location&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                println(&quot;DEBUG: ✅ Location obtained - Lat: ${location.latitude}, Lng: ${location.longitude}&quot;)&#10;                _uiState.value = _uiState.value.copy(currentLocation = location)&#10;&#10;                // Fetch nearby secrets with the obtained location&#10;                fetchNearbySecrets(location.latitude, location.longitude)&#10;&#10;            } catch (e: Exception) {&#10;                println(&quot;DEBUG: ❌ Location error - ${e.message}&quot;)&#10;                e.printStackTrace()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun fetchNearbySecrets(latitude: Double, longitude: Double) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;            val result = secretRepository.getNearbySecrets(latitude, longitude)&#10;&#10;            result.onSuccess { secrets -&gt;&#10;                val secretsWithDistance = secrets.map { secret -&gt;&#10;                    val distance = LocationHelper.calculateDistance(&#10;                        latitude, longitude,&#10;                        secret.latitude, secret.longitude&#10;                    )&#10;                    secret.copy(distance = distance)&#10;                }&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    secrets = secretsWithDistance,&#10;                    isLoading = false&#10;                )&#10;            }.onFailure { e -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Failed to fetch secrets: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun createSecret(text: String, imageUri: Uri?, isAnonymous: Boolean, mood: String? = null, category: String? = null, hashtags: String? = null) {&#10;        viewModelScope.launch {&#10;            val location = _uiState.value.currentLocation&#10;            val user = _uiState.value.currentUser&#10;&#10;            if (location == null) {&#10;                _uiState.value = _uiState.value.copy(errorMessage = &quot;Location not available&quot;)&#10;                return@launch&#10;            }&#10;&#10;            if (user == null) {&#10;                _uiState.value = _uiState.value.copy(errorMessage = &quot;User not authenticated&quot;)&#10;                return@launch&#10;            }&#10;&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;            val result = secretRepository.createSecret(&#10;                text = text,&#10;                imageUri = imageUri,&#10;                latitude = location.latitude,&#10;                longitude = location.longitude,&#10;                username = user.username,&#10;                userProfilePicture = user.profilePictureUrl,&#10;                isAnonymous = isAnonymous,&#10;                mood = mood,&#10;                category = category,&#10;                hashtags = hashtags&#10;            )&#10;&#10;            result.onSuccess {&#10;                _uiState.value = _uiState.value.copy(isLoading = false)&#10;                fetchNearbySecrets(location.latitude, location.longitude)&#10;            }.onFailure { e -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Failed to post secret: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun toggleLike(secret: Secret) {&#10;        viewModelScope.launch {&#10;            val user = _uiState.value.currentUser ?: return@launch&#10;&#10;            val result = secretRepository.toggleLike(secret.id, user.username)&#10;            result.onSuccess { isLiked -&gt;&#10;                // Update the secret in the list&#10;                val updatedSecrets = _uiState.value.secrets.map { s -&gt;&#10;                    if (s.id == secret.id) {&#10;                        s.copy(&#10;                            isLikedByCurrentUser = isLiked,&#10;                            likeCount = if (isLiked) s.likeCount + 1 else maxOf(0, s.likeCount - 1)&#10;                        )&#10;                    } else s&#10;                }&#10;                _uiState.value = _uiState.value.copy(secrets = updatedSecrets)&#10;&#10;                // Update selected secret if it's the same&#10;                if (_uiState.value.selectedSecret?.id == secret.id) {&#10;                    loadSecretDetails(secret.id)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun selectSecret(secret: Secret?) {&#10;        _uiState.value = _uiState.value.copy(selectedSecret = secret)&#10;        secret?.let { loadSecretDetails(it.id) }&#10;    }&#10;&#10;    fun loadSecretDetails(secretId: String) {&#10;        viewModelScope.launch {&#10;            val commentsResult = secretRepository.getComments(secretId)&#10;            val likesResult = secretRepository.getLikes(secretId)&#10;&#10;            commentsResult.onSuccess { comments -&gt;&#10;                _uiState.value = _uiState.value.copy(selectedSecretComments = comments)&#10;            }&#10;&#10;            likesResult.onSuccess { likes -&gt;&#10;                _uiState.value = _uiState.value.copy(selectedSecretLikes = likes)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun addComment(secretId: String, text: String) {&#10;        viewModelScope.launch {&#10;            val user = _uiState.value.currentUser ?: return@launch&#10;&#10;            println(&quot;DEBUG: Adding comment for secret $secretId&quot;)&#10;&#10;            val result = secretRepository.addComment(&#10;                secretId = secretId,&#10;                text = text,&#10;                username = user.username,&#10;                userProfilePicture = user.profilePictureUrl&#10;            )&#10;&#10;            result.onSuccess { newComment -&gt;&#10;                println(&quot;DEBUG: Comment added successfully: ${newComment.text}&quot;)&#10;&#10;                // Add small delay to ensure Firebase propagates the comment&#10;                kotlinx.coroutines.delay(800)&#10;&#10;                println(&quot;DEBUG: Reloading secret details...&quot;)&#10;                // Reload comments and likes&#10;                val commentsResult = secretRepository.getComments(secretId)&#10;                val likesResult = secretRepository.getLikes(secretId)&#10;&#10;                commentsResult.onSuccess { comments -&gt;&#10;                    println(&quot;DEBUG: Loaded ${comments.size} comments&quot;)&#10;                    _uiState.value = _uiState.value.copy(selectedSecretComments = comments)&#10;                }&#10;&#10;                likesResult.onSuccess { likes -&gt;&#10;                    _uiState.value = _uiState.value.copy(selectedSecretLikes = likes)&#10;                }&#10;&#10;                // Update comment count in the secrets list&#10;                val updatedSecrets = _uiState.value.secrets.map { s -&gt;&#10;                    if (s.id == secretId) {&#10;                        s.copy(commentCount = s.commentCount + 1)&#10;                    } else s&#10;                }&#10;&#10;                // Update the selected secret with new comment count&#10;                val updatedSelectedSecret = _uiState.value.selectedSecret?.let { secret -&gt;&#10;                    if (secret.id == secretId) {&#10;                        secret.copy(commentCount = secret.commentCount + 1)&#10;                    } else secret&#10;                }&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    secrets = updatedSecrets,&#10;                    selectedSecret = updatedSelectedSecret&#10;                )&#10;&#10;                println(&quot;DEBUG: UI state updated with ${_uiState.value.selectedSecretComments.size} comments&quot;)&#10;            }.onFailure { e -&gt;&#10;                println(&quot;DEBUG: Failed to add comment: ${e.message}&quot;)&#10;                _uiState.value = _uiState.value.copy(&#10;                    errorMessage = &quot;Failed to add comment: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun loadMySecrets() {&#10;        viewModelScope.launch {&#10;            val userId = _uiState.value.currentUser?.id ?: return@launch&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;&#10;            val result = secretRepository.getUserSecrets(userId)&#10;            result.onSuccess { secrets -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    mySecrets = secrets,&#10;                    isLoading = false&#10;                )&#10;            }.onFailure { e -&gt;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isLoading = false,&#10;                    errorMessage = &quot;Failed to load your secrets: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearError() {&#10;        _uiState.value = _uiState.value.copy(errorMessage = null)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>